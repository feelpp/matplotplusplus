{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Matplot++","text":"<p>A C++ Graphics Library for Data Visualization</p> <p></p> <p></p> <p>Data visualization can help programmers and scientists identify trends in their data and efficiently communicate these results with their peers. Modern C++ is being used for a variety of scientific applications, and this environment can benefit considerably from graphics libraries that attend the typical design goals toward scientific data visualization. Besides the option of exporting results to other environments, the customary alternatives in C++ are either non-dedicated libraries that depend on existing user interfaces or bindings to other languages. Matplot++ is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.</p> <p></p> <p> </p> <p></p> <p> </p> <p></p> <p> </p>"},{"location":"COMPLETE_GALLERY/","title":"Complete Gallery","text":""},{"location":"COMPLETE_GALLERY/#line-plots","title":"Line Plots","text":""},{"location":"COMPLETE_GALLERY/#line-plot","title":"Line Plot","text":"<p><code>examples/line_plot/plot/plot_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_5.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_6.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_7.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_8.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_9.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_10.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_11.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot/plot_12.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#line-plot-3d","title":"Line Plot 3D","text":"<p><code>examples/line_plot/plot3/plot3_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_5.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_6.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_7.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_8.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_9.cpp</code>: </p> <p></p> <p><code>examples/line_plot/plot3/plot3_10.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#stairs","title":"Stairs","text":"<p><code>examples/line_plot/stairs/stairs_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_5.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_6.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_7.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_8.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_9.cpp</code>: </p> <p></p> <p><code>examples/line_plot/stairs/stairs_10.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#error-bars","title":"Error Bars","text":"<p><code>examples/line_plot/errorbar/errorbar_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_5.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_6.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_7.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_8.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_9.cpp</code>: </p> <p></p> <p><code>examples/line_plot/errorbar/errorbar_10.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#area","title":"Area","text":"<p><code>examples/line_plot/area/area_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/area/area_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/area/area_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/area/area_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#loglog-plot","title":"Loglog Plot","text":"<p><code>examples/line_plot/loglog/loglog_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_5.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_6.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_7.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_8.cpp</code>: </p> <p></p> <p><code>examples/line_plot/loglog/loglog_9.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#semilogx-plot","title":"Semilogx Plot","text":"<p><code>examples/line_plot/semilogx/semilogx_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#semilogy-plot","title":"Semilogy Plot","text":"<p><code>examples/line_plot/semilogy/semilogy_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#function-plot","title":"Function Plot","text":"<p><code>examples/line_plot/fplot/fplot_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot/fplot_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot/fplot_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot/fplot_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot/fplot_5.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot/fplot_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#function-plot-3d","title":"Function Plot 3D","text":"<p><code>examples/line_plot/fplot3/fplot3_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot3/fplot3_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot3/fplot3_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot3/fplot3_4.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fplot3/fplot3_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#implicit-function","title":"Implicit function","text":"<p><code>examples/line_plot/fimplicit/fimplicit_1.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fimplicit/fimplicit_2.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fimplicit/fimplicit_3.cpp</code>: </p> <p></p> <p><code>examples/line_plot/fimplicit/fimplicit_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#data-distribution","title":"Data Distribution","text":""},{"location":"COMPLETE_GALLERY/#histogram","title":"Histogram","text":"<p><code>examples/data_distribution/histogram/histogram_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_5.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_6.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_7.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_8.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_9.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_10.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_11.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_12.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/histogram/histogram_14.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#boxplot","title":"Boxplot","text":"<p><code>examples/data_distribution/boxplot/boxplot_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/boxplot/boxplot_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/boxplot/boxplot_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#scatter-plot","title":"Scatter Plot","text":"<p><code>examples/data_distribution/scatter/scatter_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_5.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_6.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_7.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter/scatter_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#scatter-plot-3d","title":"Scatter Plot 3D","text":"<p><code>examples/data_distribution/scatter3/scatter3_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter3/scatter3_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter3/scatter3_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter3/scatter3_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter3/scatter3_5.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/scatter3/scatter3_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#binned-scatter-plots","title":"Binned Scatter Plots","text":"<p><code>examples/data_distribution/binscatter/binscatter_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/binscatter/binscatter_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/binscatter/binscatter_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/binscatter/binscatter_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/binscatter/binscatter_5.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/binscatter/binscatter_6.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/binscatter/binscatter_7.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#plot-matrix","title":"Plot Matrix","text":"<p><code>examples/data_distribution/plotmatrix/plotmatrix_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/plotmatrix/plotmatrix_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/plotmatrix/plotmatrix_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/plotmatrix/plotmatrix_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#parallel-coordinates","title":"Parallel Coordinates","text":"<p><code>examples/data_distribution/parallelplot/parallelplot_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/parallelplot/parallelplot_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/parallelplot/parallelplot_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#pie-chart","title":"Pie Chart","text":"<p><code>examples/data_distribution/pie/pie_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/pie/pie_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/pie/pie_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/pie/pie_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/pie/pie_5.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/pie/pie_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#heatmap","title":"Heatmap","text":"<p><code>examples/data_distribution/heatmap/heatmap_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/heatmap/heatmap_2.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/heatmap/heatmap_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/heatmap/heatmap_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/heatmap/heatmap_5.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/heatmap/heatmap_6.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/heatmap/heatmap_7.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#word-cloud","title":"Word Cloud","text":"<p><code>examples/data_distribution/wordcloud/wordcloud_1.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/wordcloud/wordcloud_3.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/wordcloud/wordcloud_4.cpp</code>: </p> <p></p> <p><code>examples/data_distribution/wordcloud/wordcloud_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#discrete-data","title":"Discrete Data","text":""},{"location":"COMPLETE_GALLERY/#bar-plot","title":"Bar Plot","text":"<p><code>examples/discrete_data/bar/bar_1.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_2.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_3.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_4.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_5.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_6.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_7.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_8.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_9.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_10.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_11.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_12.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/bar/bar_13.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#pareto-chart","title":"Pareto Chart","text":"<p><code>examples/discrete_data/pareto/pareto_1.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/pareto/pareto_2.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/pareto/pareto_3.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/pareto/pareto_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#stem-plot","title":"Stem Plot","text":"<p><code>examples/discrete_data/stem/stem_1.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_2.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_3.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_4.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_5.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_6.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_7.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_8.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem/stem_9.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#stem-plot-3d","title":"Stem Plot 3D","text":"<p><code>examples/discrete_data/stem3/stem3_1.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_2.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_3.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_4.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_5.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_6.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_7.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_8.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_9.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_10.cpp</code>: </p> <p></p> <p><code>examples/discrete_data/stem3/stem3_11.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#geography","title":"Geography","text":""},{"location":"COMPLETE_GALLERY/#geoplot","title":"Geoplot","text":"<p><code>examples/geography/geoplot/geoplot_1.cpp</code>: </p> <p></p> <p><code>examples/geography/geoplot/geoplot_2.cpp</code>: </p> <p></p> <p><code>examples/geography/geoplot/geoplot_3.cpp</code>: </p> <p></p> <p><code>examples/geography/geoplot/geoplot_4.cpp</code>: </p> <p></p> <p><code>examples/geography/geoplot/geoplot_5.cpp</code>: </p> <p></p> <p><code>examples/geography/geoplot/geoplot_6.cpp</code>: </p> <p></p> <p><code>examples/geography/geoplot/geoplot_7.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#geoscatter-plot","title":"Geoscatter Plot","text":"<p><code>examples/geography/geoscatter/geoscatter_1.cpp</code>: </p> <p></p> <p><code>examples/geography/geoscatter/geoscatter_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#geobubble","title":"Geobubble","text":"<p><code>examples/geography/geobubble/geobubble_1.cpp</code>: </p> <p></p> <p><code>examples/geography/geobubble/geobubble_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#geodensity-plot","title":"Geodensity Plot","text":"<p><code>examples/geography/geodensityplot/geodensityplot_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#polar-plots","title":"Polar Plots","text":""},{"location":"COMPLETE_GALLERY/#polar-line-plot","title":"Polar Line Plot","text":"<p><code>examples/polar_plots/polarplot/polarplot_1.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_2.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_3.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_4.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_5.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_6.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_7.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarplot/polarplot_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#polar-scatter-plot","title":"Polar Scatter Plot","text":"<p><code>examples/polar_plots/polarscatter/polarscatter_1.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarscatter/polarscatter_2.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarscatter/polarscatter_3.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarscatter/polarscatter_4.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarscatter/polarscatter_5.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarscatter/polarscatter_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#polar-histogram","title":"Polar Histogram","text":"<p><code>examples/polar_plots/polarhistogram/polarhistogram_1.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarhistogram/polarhistogram_2.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarhistogram/polarhistogram_3.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarhistogram/polarhistogram_4.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/polarhistogram/polarhistogram_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#compass","title":"Compass","text":"<p><code>examples/polar_plots/compass/compass_1.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/compass/compass_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#polar-function","title":"Polar Function","text":"<p><code>examples/polar_plots/ezpolar/ezpolar_1.cpp</code>: </p> <p></p> <p><code>examples/polar_plots/ezpolar/ezpolar_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#contour-plots","title":"Contour Plots","text":""},{"location":"COMPLETE_GALLERY/#contour","title":"Contour","text":"<p><code>examples/contour_plots/contour/contour_1.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_2.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_3.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_4.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_5.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_6.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_7.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contour/contour_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#filled-contour","title":"Filled Contour","text":"<p><code>examples/contour_plots/contourf/contourf_1.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contourf/contourf_2.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contourf/contourf_3.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contourf/contourf_4.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contourf/contourf_5.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/contourf/contourf_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#function-contour","title":"Function Contour","text":"<p><code>examples/contour_plots/fcontour/fcontour_1.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_2.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_3.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_4.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_5.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_6.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_7.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_8.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_9.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_10.cpp</code>: </p> <p></p> <p><code>examples/contour_plots/fcontour/fcontour_11.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#vector-fields","title":"Vector Fields","text":""},{"location":"COMPLETE_GALLERY/#quiver","title":"Quiver","text":"<p><code>examples/vector_fields/quiver/quiver_1.cpp</code>: </p> <p></p> <p><code>examples/vector_fields/quiver/quiver_2.cpp</code>: </p> <p></p> <p><code>examples/vector_fields/quiver/quiver_3.cpp</code>: </p> <p></p> <p><code>examples/vector_fields/quiver/quiver_4.cpp</code>: </p> <p></p> <p><code>examples/vector_fields/quiver/quiver_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#quiver-3d","title":"Quiver 3D","text":"<p><code>examples/vector_fields/quiver3/quiver3_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#feather","title":"Feather","text":"<p><code>examples/vector_fields/feather/feather_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#surfaces","title":"Surfaces","text":""},{"location":"COMPLETE_GALLERY/#surface","title":"Surface","text":"<p><code>examples/surfaces/surf/surf_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surf/surf_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surf/surf_3.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surf/surf_4.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surf/surf_5.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surf/surf_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#surface-with-contour","title":"Surface with Contour","text":"<p><code>examples/surfaces/surfc/surfc_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surfc/surfc_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surfc/surfc_3.cpp</code>: </p> <p></p> <p><code>examples/surfaces/surfc/surfc_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#mesh","title":"Mesh","text":"<p><code>examples/surfaces/mesh/mesh_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/mesh/mesh_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/mesh/mesh_3.cpp</code>: </p> <p></p> <p><code>examples/surfaces/mesh/mesh_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#mesh-with-contour","title":"Mesh with Contour","text":"<p><code>examples/surfaces/meshc/meshc_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/meshc/meshc_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/meshc/meshc_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#mesh-with-curtain","title":"Mesh with Curtain","text":"<p><code>examples/surfaces/meshz/meshz_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/meshz/meshz_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/meshz/meshz_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#function-surface","title":"Function Surface","text":"<p><code>examples/surfaces/fsurf/fsurf_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_3.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_4.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_5.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_6.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_7.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fsurf/fsurf_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#function-mesh","title":"Function Mesh","text":"<p><code>examples/surfaces/fmesh/fmesh_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fmesh/fmesh_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fmesh/fmesh_3.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fmesh/fmesh_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#waterfall","title":"Waterfall","text":"<p><code>examples/surfaces/waterfall/waterfall_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/waterfall/waterfall_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/waterfall/waterfall_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#fence","title":"Fence","text":"<p><code>examples/surfaces/fence/fence_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fence/fence_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/fence/fence_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#ribbon","title":"Ribbon","text":"<p><code>examples/surfaces/ribbon/ribbon_1.cpp</code>: </p> <p></p> <p><code>examples/surfaces/ribbon/ribbon_2.cpp</code>: </p> <p></p> <p><code>examples/surfaces/ribbon/ribbon_3.cpp</code>: </p> <p></p> <p><code>examples/surfaces/ribbon/ribbon_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#graphs","title":"Graphs","text":""},{"location":"COMPLETE_GALLERY/#undirected-graph","title":"Undirected Graph","text":"<p><code>examples/graphs/graph/graph_1.cpp</code>: </p> <p></p> <p><code>examples/graphs/graph/graph_2.cpp</code>: </p> <p></p> <p><code>examples/graphs/graph/graph_3.cpp</code>: </p> <p></p> <p><code>examples/graphs/graph/graph_4.cpp</code>: </p> <p></p> <p><code>examples/graphs/graph/graph_5.cpp</code>: </p> <p></p> <p><code>examples/graphs/graph/graph_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#directed-graph","title":"Directed Graph","text":"<p><code>examples/graphs/digraph/digraph_1.cpp</code>: </p> <p></p> <p><code>examples/graphs/digraph/digraph_2.cpp</code>: </p> <p></p> <p><code>examples/graphs/digraph/digraph_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#images","title":"Images","text":""},{"location":"COMPLETE_GALLERY/#image-show","title":"Image Show","text":"<p><code>examples/images/imshow/imshow_1.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_2.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_3.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_4.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_5.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_6.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_7.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_8.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_9.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_10.cpp</code>: </p> <p></p> <p><code>examples/images/imshow/imshow_11.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#image-matrix","title":"Image Matrix","text":"<p><code>examples/images/image/image_1.cpp</code>: </p> <p></p> <p><code>examples/images/image/image_2.cpp</code>: </p> <p></p> <p><code>examples/images/image/image_3.cpp</code>: </p> <p></p> <p><code>examples/images/image/image_4.cpp</code>: </p> <p></p> <p><code>examples/images/image/image_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#scaled-image","title":"Scaled Image","text":"<p><code>examples/images/imagesc/imagesc_1.cpp</code>: </p> <p></p> <p><code>examples/images/imagesc/imagesc_2.cpp</code>: </p> <p></p> <p><code>examples/images/imagesc/imagesc_3.cpp</code>: </p> <p></p> <p><code>examples/images/imagesc/imagesc_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#annotations","title":"Annotations","text":""},{"location":"COMPLETE_GALLERY/#text","title":"Text","text":"<p><code>examples/annotations/text/text_1.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_2.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_3.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_4.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_5.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_6.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_7.cpp</code>: </p> <p></p> <p><code>examples/annotations/text/text_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#text-with-arrow","title":"Text with Arrow","text":"<p><code>examples/annotations/textarrow/textarrow_1.cpp</code>: </p> <p></p> <p><code>examples/annotations/textarrow/textarrow_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#rectangle","title":"Rectangle","text":"<p><code>examples/annotations/rectangle/rectangle_1.cpp</code>: </p> <p></p> <p><code>examples/annotations/rectangle/rectangle_2.cpp</code>: </p> <p></p> <p><code>examples/annotations/rectangle/rectangle_3.cpp</code>: </p> <p></p> <p><code>examples/annotations/rectangle/rectangle_4.cpp</code>: </p> <p></p> <p><code>examples/annotations/rectangle/rectangle_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#filled-polygon","title":"Filled Polygon","text":"<p><code>examples/annotations/fill/fill_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#ellipse","title":"Ellipse","text":"<p><code>examples/annotations/ellipse/ellipse_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#textbox","title":"Textbox","text":"<p><code>examples/annotations/textbox/textbox_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#arrow","title":"Arrow","text":"<p><code>examples/annotations/arrow/arrow_1.cpp</code>: </p> <p></p> <p><code>examples/annotations/arrow/arrow_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#line","title":"Line","text":"<p><code>examples/annotations/line/line_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#appearance","title":"Appearance","text":""},{"location":"COMPLETE_GALLERY/#labels","title":"Labels","text":""},{"location":"COMPLETE_GALLERY/#title","title":"Title","text":"<p><code>examples/appearance/labels/title/title_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/title/title_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#subplot-title","title":"Subplot Title","text":"<p><code>examples/appearance/labels/sgtitle/sgtitle_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/sgtitle/sgtitle_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#x-label","title":"X Label","text":"<p><code>examples/appearance/labels/xlabel/xlabel_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/xlabel/xlabel_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#y-label","title":"Y Label","text":"<p><code>examples/appearance/labels/ylabel/ylabel_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/ylabel/ylabel_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#z-label","title":"Z Label","text":"<p><code>examples/appearance/labels/zlabel/zlabel_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/zlabel/zlabel_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/zlabel/zlabel_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#legend","title":"Legend","text":"<p><code>examples/appearance/labels/legend/legend_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_8.cpp</code>: </p> <p></p> <p><code>examples/appearance/labels/legend/legend_9.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#axis","title":"Axis","text":""},{"location":"COMPLETE_GALLERY/#x-limits","title":"X Limits","text":"<p><code>examples/appearance/axis/xlim/xlim_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/xlim/xlim_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/xlim/xlim_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/xlim/xlim_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/xlim/xlim_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/xlim/xlim_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#y-limits","title":"Y Limits","text":"<p><code>examples/appearance/axis/ylim/ylim_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/ylim/ylim_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/ylim/ylim_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/ylim/ylim_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/ylim/ylim_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/ylim/ylim_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#z-limits","title":"Z Limits","text":"<p><code>examples/appearance/axis/zlim/zlim_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/zlim/zlim_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/zlim/zlim_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/zlim/zlim_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/zlim/zlim_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/zlim/zlim_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#adjust-axis","title":"Adjust Axis","text":"<p><code>examples/appearance/axis/axis/axis_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/axis/axis_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#box","title":"Box","text":"<p><code>examples/appearance/axis/box/box_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/box/box_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/axis/box/box_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#grid","title":"Grid","text":""},{"location":"COMPLETE_GALLERY/#grid_1","title":"Grid","text":"<p><code>examples/appearance/grid/grid/grid_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/grid/grid_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/grid/grid_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/grid/grid_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#x-ticks","title":"X Ticks","text":"<p><code>examples/appearance/grid/xticks/xticks_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticks/xticks_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#y-ticks","title":"Y Ticks","text":"<p><code>examples/appearance/grid/yticks/yticks_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticks/yticks_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#z-ticks","title":"Z Ticks","text":"<p><code>examples/appearance/grid/zticks/zticks_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/zticks/zticks_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/zticks/zticks_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/zticks/zticks_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/zticks/zticks_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/zticks/zticks_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#x-tick-labels","title":"X Tick Labels","text":"<p><code>examples/appearance/grid/xticklabels/xticklabels_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticklabels/xticklabels_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticklabels/xticklabels_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xticklabels/xticklabels_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#y-tick-labels","title":"Y Tick Labels","text":"<p><code>examples/appearance/grid/yticklabels/yticklabels_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticklabels/yticklabels_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticklabels/yticklabels_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/yticklabels/yticklabels_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#x-tick-format","title":"X Tick Format","text":"<p><code>examples/appearance/grid/xtickformat/xtickformat_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xtickformat/xtickformat_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xtickformat/xtickformat_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xtickformat/xtickformat_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xtickformat/xtickformat_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#y-tick-format","title":"Y Tick Format","text":"<p><code>examples/appearance/grid/ytickformat/ytickformat_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ytickformat/ytickformat_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ytickformat/ytickformat_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ytickformat/ytickformat_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ytickformat/ytickformat_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#z-tick-format","title":"Z Tick Format","text":"<p><code>examples/appearance/grid/ztickformat/ztickformat_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ztickformat/ztickformat_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ztickformat/ztickformat_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ztickformat/ztickformat_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ztickformat/ztickformat_5.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#x-tick-angle","title":"X Tick Angle","text":"<p><code>examples/appearance/grid/xtickangle/xtickangle_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xtickangle/xtickangle_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/xtickangle/xtickangle_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#y-tick-angle","title":"Y Tick Angle","text":"<p><code>examples/appearance/grid/ytickangle/ytickangle_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ytickangle/ytickangle_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/grid/ytickangle/ytickangle_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#multiplot","title":"Multiplot","text":""},{"location":"COMPLETE_GALLERY/#hold","title":"Hold","text":"<p><code>examples/appearance/multiplot/hold/hold_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/hold/hold_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/hold/hold_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/hold/hold_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#yy-axis","title":"YY-axis","text":"<p><code>examples/appearance/multiplot/yyaxis/yyaxis_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/yyaxis/yyaxis_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/yyaxis/yyaxis_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/yyaxis/yyaxis_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/yyaxis/yyaxis_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/yyaxis/yyaxis_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/yyaxis/yyaxis_7.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#color-order","title":"Color Order","text":"<p><code>examples/appearance/multiplot/colororder/colororder_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/colororder/colororder_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/colororder/colororder_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/colororder/colororder_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/colororder/colororder_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/colororder/colororder_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/colororder/colororder_7.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#subplots","title":"Subplots","text":"<p><code>examples/appearance/multiplot/subplot/subplot_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_8.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_9.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_10.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_11.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_12.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/subplot/subplot_13.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#tiled-layout","title":"Tiled Layout","text":"<p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/multiplot/tiledlayout/tiledlayout_8.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#colormaps","title":"Colormaps","text":""},{"location":"COMPLETE_GALLERY/#colormap","title":"Colormap","text":"<p><code>examples/appearance/colormaps/colormap/colormap_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_7.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_8.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colormap/colormap_9.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#color-bar","title":"Color Bar","text":"<p><code>examples/appearance/colormaps/colorbar/colorbar_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colorbar/colorbar_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colorbar/colorbar_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colorbar/colorbar_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colorbar/colorbar_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colorbar/colorbar_6.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/colorbar/colorbar_7.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#rgb-plot","title":"RGB Plot","text":"<p><code>examples/appearance/colormaps/rgbplot/rgbplot_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/colormaps/rgbplot/rgbplot_2.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#camera","title":"Camera","text":""},{"location":"COMPLETE_GALLERY/#view","title":"View","text":"<p><code>examples/appearance/camera/view/view_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/view/view_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/view/view_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/view/view_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/view/view_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/view/view_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#lighting","title":"Lighting","text":"<p><code>examples/appearance/camera/lighting/lighting_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/lighting/lighting_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/lighting/lighting_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/lighting/lighting_4.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/lighting/lighting_5.cpp</code>: </p> <p></p> <p><code>examples/appearance/camera/lighting/lighting_6.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#figure-object","title":"Figure Object","text":"<p><code>examples/appearance/figure/figure_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/figure/figure_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/figure/figure_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#line-specs","title":"Line Specs","text":"<p><code>examples/appearance/line_spec/line_spec_1.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#axes-object","title":"Axes Object","text":"<p><code>examples/appearance/axes/axes_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/axes/axes_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/axes/axes_3.cpp</code>: </p> <p></p> <p><code>examples/appearance/axes/axes_4.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#clear-axes","title":"Clear Axes","text":"<p><code>examples/appearance/cla/cla_1.cpp</code>: </p> <p></p> <p><code>examples/appearance/cla/cla_2.cpp</code>: </p> <p></p> <p><code>examples/appearance/cla/cla_3.cpp</code>: </p> <p></p>"},{"location":"COMPLETE_GALLERY/#exporting","title":"Exporting","text":""},{"location":"COMPLETE_GALLERY/#saving","title":"Saving","text":"<p><code>examples/exporting/save/save_1.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_2.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_3.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_4.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_5.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_6.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_7.cpp</code>: </p> <p></p> <p><code>examples/exporting/save/save_8.cpp</code>: </p> <p></p>"},{"location":"references/","title":"References","text":"<p>These are some references we used for this work:</p> <ul> <li> <p>Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, Devin M, Ghemawat S, Irving G,Isard M,et al.(2016). \"Tensorflow: A system for large-scale machine learning.\" In 12th USENIX symposium on operating systems design and implementation (OSDI 16), pp.265-283.</p> </li> <li> <p>Angerson E, Bai Z, Dongarra J, Greenbaum A, McKenney A, Du Croz J, Hammarling S,Demmel J, Bischof C, Sorensen D (1990). \"LAPACK: A portable linear algebra library for high-performance computers.\" In Supercomputing'90: Proceedings of the 1990 ACM/IEEE Conference on Supercomputing, pp. 2-11. IEEE.</p> </li> <li> <p>Antcheva I, Ballintijn M, Bellenot B, Biskup M, Brun R, Buncic N, Canal P, Casadei D, CouetO, Fine V, et al.(2011). \"ROOT-A C++ framework for petabyte data storage, statistical analysis and visualization.\"Computer Physics Communications,182(6), 1384-1385.</p> </li> <li> <p>Baratov R (2019). Hunter. URL: https://hunter.readthedocs.io.</p> </li> <li> <p>Barrett P, Hunter J, Miller JT, Hsu JC, Greenfield P (2005). \"matplotlib-A Portable Python Plotting Package.\" In Astronomical data analysis software and systems XIV, volume 347,p. 91.</p> </li> <li> <p>Bezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing. \"SIAM review,59(1), 65-98.</p> </li> <li> <p>CEGUI Team (2020). CEGUI. URL: http://cegui.org.uk.</p> </li> <li> <p>Cornut O (2020). Dear ImGui: Bloat-free Immediate Mode Graphical User Interface for C++ with minimal dependencies. URL: https://github.com/ocornut/imgui.</p> </li> <li> <p>de Guzman J (2020). Elements. URL: http://cycfi.github.io/elements/.</p> </li> <li> <p>Eichhammer E (2020). QCustomPlot. URL: https://www.qcustomplot.com.</p> </li> <li> <p>Evers B (2019). Matplotlib-cpp. URL: https://github.com/lava/matplotlib-cpp.</p> </li> <li> <p>Freitas A (2020). Pareto Front Library.   URL: https://github.com/alandefreitas/pareto-front.</p> </li> <li> <p>Frigo M, Johnson SG (1998). \"FFTW: An adaptive software architecture for the FFT.\" In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP'98 (Cat. No. 98CH36181), volume 3, pp. 1381-1384. IEEE.</p> </li> <li> <p>Fruchterman TM, Reingold EM (1991). \"Graph drawing by force-directed placement. \"Software: Practice and experience, 21(11), 1129-1164.</p> </li> <li> <p>GNU Project (2020). GNU Octave: Introduction to Plotting. URL: https://octave.org/doc/v4.2.2/Introduction-to-Plotting.html.</p> </li> <li> <p>Guy Eric Schalnat Andreas Dilger GRP (2020). Libpng. URL: https://sourceforge.net/p/libpng/.</p> </li> <li> <p>Hao J (2020). Nana. URL: http://nanapro.org/.</p> </li> <li> <p>Hunter JD (2007).  \"Matplotlib: A 2D graphics environment. \"Computing in Science &amp; Engineering, 9(3), 90-95. doi:10.1109/MCSE.2007.55.</p> </li> <li> <p>Idea4good (2020). GuiLite. URL: https://github.com/idea4good/GuiLite.</p> </li> <li> <p>ImageMagick Studio LLC (2020). Magick++. URL: https://imagemagick.org/Magick++/.</p> </li> <li> <p>Independent JPEG Group (2020). Libjpeg. URL: http://libjpeg.sourceforge.net.</p> </li> <li> <p>Intel Corporation, Willow Garage I (2020). Open Source Computer Vision Library (OpenCV). URL: https://opencv.org/.</p> </li> <li> <p>Jakob W (2017). PyBind11. URL: https://pybind11.readthedocs.io/en/stable/.</p> </li> <li> <p>Kagstrom B LP, C VL (2020). Basic Linear Algebra Subprograms (BLAS).  URL: http://www.netlib.org/blas/.</p> </li> <li> <p>Kainz F, Bogart R, Hess D (2003). \"The OpenEXR image file format.\"SIGGRAPH TechnicalSketches.</p> </li> <li> <p>Kamada T, Kawai S,et al.(1989). \"An algorithm for drawing general undirected graphs.\"Information processing letters,31(1), 7-15.</p> </li> <li> <p>Loup Gailly J, Adler M (2020). Zlib. URL: https://github.com/madler/zlib.</p> </li> <li> <p>Martin K, Hoffman B (2010). Mastering CMake: a cross-platform build system. Kitware.</p> </li> <li> <p>McKinney W,et al.(2011). \"Pandas: a foundational Python library for data analysis and statistics. \"Python for High Performance and Scientific Computing, 14(9).</p> </li> <li> <p>Conan.io (2020). Conan. URL: https://conan.io.</p> </li> <li> <p>Melchior L (2020). CPM.cmake. URL: https://github.com/TheLartians/CPM.cmake.</p> </li> <li> <p>Murray Cumming DE (2020). Gtkmm. URL: https://www.gtkmm.org/.</p> </li> <li> <p>Natural Earth (2018). \"Natural earth. Free vector and raster map data.\" URL: http://www.naturalearthdata.com/downloads/.</p> </li> <li> <p>NetworkX developers (2020). NetworkX. URL: https://networkx.github.io.</p> </li> <li> <p>Olivier Birot (2020). nodesoup. URL: https://github.com/olvb/nodesoup.</p> </li> <li> <p>Pezent E (2020). ImPlot. URL: https://github.com/epezent/implot.</p> </li> <li> <p>Sam Leffler SG (2020). Libtiff. URL: https://gitlab.com/libtiff/libtiff.</p> </li> <li> <p>Schaling B (2011). The boost C++ libraries. Boris Schaling.</p> </li> <li> <p>Spitzak B, et al.(2004). \"Fast Light Toolkit (FLTK).\" FTLK: Fast light toolkit. Available: http://www.fltk.org/</p> </li> <li> <p>Stahlke D (2020). Gnuplot-Iostream. URL: http://stahlke.org/dan/gnuplot-iostream/.</p> </li> <li> <p>Storer J (2020). JUCE. URL: https://juce.com.</p> </li> <li> <p>Terra Informatica Software, Inc (2020). Sciter. URL: https://sciter.com.</p> </li> <li> <p>The FLTK Team (2020). FLTK. URL: https://www.fltk.org.</p> </li> <li> <p>The MathWorks, Inc (2020). MatlabGraphics. URL: https://www.mathworks.com/help/matlab/graphics.html.</p> </li> <li> <p>The Qt Company (2020). Qt. URL: https://www.qt.io.</p> </li> <li> <p>Tschumperle D (2020). CImg. URL: http://cimg.eu.</p> </li> <li> <p>van der Zijp J (2020). Fox toolkit. URL: http://fox-toolkit.org.</p> </li> <li> <p>Vasilev V, Canal P, Naumann A, Russo P (2012). \"Cling-the new interactive interpreter for root 6.\" In Journal of Physics: Conference Series, volume 396, p. 052071.</p> </li> <li> <p>Walt Svd, Colbert SC, Varoquaux G (2011). \"The NumPy array: a structure for efficient numerical computation.\" Computing in science &amp; engineering,13(2), 22-30.</p> </li> <li> <p>Wei V (2020). MiniGUI. URL: http://www.minigui.com.</p> </li> <li> <p>Williams T, Kelley C, Bersch C, Broker HB, Campbell J, Cunningham R, Denholm D, Elber G, Fearick R, Grammes C,et al.(2017). \"gnuplot 5.2.\"</p> </li> <li> <p>wxWidgets (2020). WxWidgets. URL: https://wxwidgets.org.</p> </li> <li> <p>XOrg Foundation (2020). X11. URL: https://www.x.org/.</p> </li> <li> <p>Zaitsev S (2020). Webview. URL: https://github.com/zserge/webview.</p> </li> <li> <p>Zakai A (2011). \"Emscripten: an LLVM-to-JavaScript compiler.\" In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion, pp. 301-312.</p> </li> </ul>"},{"location":"white-paper/","title":"Matplot++: A C++ Graphics Library for Data Visualization","text":"<p>Data visualization can help programmers and scientists identify trends in their data and efficiently communicate these results with their peers.</p> <p>Modern C++ is being used for a variety of scientific applications, and this environment can benefit considerably from graphics libraries that attend the typical design goals toward scientific data visualization.</p> <p>Besides the option of exporting results to other environments, the customary alternatives in C++ are either non-dedicated libraries that depend on existing user interfaces or bindings to other languages.</p> <p>Matplot++ is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.</p>"},{"location":"white-paper/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Data Visualization in C++</li> <li>Data Visualization</li> <li>Scientific Computing in C++</li> <li>Alternatives for Data Visualization in C++<ul> <li>Bindings</li> <li>Exporting Data</li> <li>Plotting widgets</li> <li>Gnuplot Pipes</li> </ul> </li> <li>The Matplot   library</li> <li>Figures and Axes</li> <li>Plot Categories</li> <li>Line Plots</li> <li>Data Distribution</li> <li>Discrete Data</li> <li>Geography</li> <li>Polar Plots</li> <li>Contour Plots</li> <li>Vector Fields</li> <li>Surfaces</li> <li>Graphs</li> <li>Images</li> <li>Annotations</li> <li>Appearance</li> <li>Coding Styles</li> <li>Member vs. Free-standing Functions</li> <li>Reactive figures</li> <li>Method Chaining</li> <li>Ranges</li> <li>Utilities</li> <li>Backend Interface</li> <li>Examples</li> <li>Interface</li> <li>A Minimal Application</li> <li>Applications Managing Plot Handles</li> <li>Exporting Figures</li> <li>Creating new plot types</li> <li>Backends</li> <li>Performance</li> <li>Conclusion</li> <li>References</li> </ul>"},{"location":"white-paper/#introduction","title":"Introduction","text":"<p>Data visualization is fundamental to scientific computing and metrics-driven development. Programmers can use interactive plotting to monitor their quality metrics more efficiently. Scientists rely on these tools to export their graphics in high-quality formats for scientific writings. The process of generating these graphics cannot be more expensive in terms of development time than the resources spent on the main problem at hand (Section Data Visualization). While C++ has been valuable for a variety of scientific problems (Section Scientific Computing in C++), there is currently no alternative for data visualization that attends the design goals we habitually expect from scientific libraries (Section Alternatives for Data Visualization in C++). </p> <p>For this reason, this article presents Matplot++ (Section The Matplot++ Library), a graphics library for data visualization in C++. The library maintains a high-level hierarchical structure to manage plots the user can create transparently with single function calls.</p> <p>The main library objects represent figures and axes that can hierarchically store child objects that can collectively represent plots in many categories (Section Figures and Axes). Each plot category includes algorithms to solve numerous hurdles demanded in data visualization (Section Plot Categories). For instance, producing plots might involve calculating multi-dimensional histogram bins, generating word clouds, efficiently cropping maps, converting data between coordinate systems, identifying contour lines, producing network layouts, and applying filters to images.</p> <p>Like present libraries for different programming languages, Matplot++ allows flexible coding styles (Section Coding Styles). The user can choose between object-oriented programming or free-standing functions (Section Member vs. Free-Standing Functions), reactive or quiet figures (Section Reactive Figures), method chaining or smart pointers to adjust plot properties (Section Method Chaining), and use any convertible range data type as input for the algorithms (Section Ranges). Matplot++ also includes simple convenience functions to manipulate data (Section Utilities) and the backend interface makes it viable to use Matplot++ in countless contexts (Section Backend Interface).</p> <p>In Section Examples, we examine how Matplot++ relates to other comparable libraries and environments by addressing its interface (Section Interface), provide extra examples of intricate integration into existent applications (Sections Minimal Application and Applications Managing Plot Handles), illustrate the results for varying image formats (Sections Exporting Data), and consider more high-level practices, like conceiving novel plot categories (Section Creating New Plot Categories) and backends for unique environments (Section Backends). </p>"},{"location":"white-paper/#data-visualization-in-c","title":"Data Visualization in C++","text":""},{"location":"white-paper/#data-visualization","title":"Data Visualization","text":"<p>Data visualization can help us promptly recognize trends in data. It is an indispensable means to interpret large volumes of data and to watch high-performance applications. Besides tests and benchmarks, data visualization also enables programmers to benefit more effectively from metrics-driven development. These metrics are particularly critical for high-performance computing, where unit tests can only identify bugs in scenarios we know about. Also, benchmarks cannot ordinarily identify bottlenecks for code optimization that replicate the production environment and its edge cases. It is ineffective to work to improve systems without proper instruments to measure their performance.</p> <p>For these purposes, tools for data experts usually incorporate functions for graphics. The design goals of these libraries tend to revolve around three aims:</p> <ul> <li>Interactive plotting: plots usually comprise reactive objects that get refreshed as soon as the figure attributes change. These reactive objects are valuable for monitoring systems in real-time.</li> <li>Exporting tools: libraries should have the means to export images in high-quality formats to communicate results in scientific writings.</li> <li>Productivity: the interface should incorporate commands to instantly produce the most well-known varieties of plots with a single function call.</li> </ul> <p>Additional commands should be required solely to attach supplementary plots to a figure or to customize plot features. Programmers should not spend substantial development time to produce plots. The development cost of including plots should be near zero. Matplotlib had the philosophy that it should take as few commands as possible to generate a plot. If feasible, that would be only one command. For instance, one should be able to create a line plot from <code>x</code> and <code>y</code> by</p> <pre><code>plt.plot(x,y)\n</code></pre> <p>The Matlab environment embeds one of these graphic libraries. It incorporates a comfortable interface to interactively update plots and generate high-quality graphics for publications. Since then, this is one of the peculiarities that made Matlab a highly valuable environment for data analysis. Many scientists and programmers export their data to Matlab to adopt it as a mechanism for generating publication-quality images.</p> <p>Likewise, Octave incorporates a similar syntax for the equivalent kinds of graphics. The earliest versions of Octave used Gnuplot as a backend for its graphics. Since then, it has transitioned to a backend based on FLTK. Julia is yet another programming language that combines data visualization as part of its standard libraries.</p> <p>Meanwhile, Python has increasingly matured as a powerful means for data analysis, with libraries such as Pandas and Numpy. Python provides a compromise between abstraction and performance by transparently integrating high-performance compiled code.</p> <p>In this context, Matplotlib became a dominant tool that satisfied the demand for a Python graphics library. Matplotlib has a syntax comparable to the Matlab graphics library, which simplifies the transition from Matlab to Python for data scientists. Matplotlib  incorporates functions to plot anything directly on an <code>Axes</code> object. Differently from Matlab, though, Matplotlib supports two coding styles. The first coding style uses the object-oriented class methods while the second is a wrapper around these objects to make the plots available as free-standing functions. The object-oriented style is more natural to Python programmers. Given an <code>Axes</code> object <code>ax</code>, one can create a line plot from <code>x</code> and <code>y</code> by</p> <pre><code>ax-&gt;plot(x,y)\n</code></pre> <p>The second coding style is designed to emulate the Matlab environment for transitioning users. In the first versions of Matplotlib, barrett2005matplotlib had a major express plan to conceive an interface as similar as possible to Matlab.</p>"},{"location":"white-paper/#scientific-computing-in-c","title":"Scientific Computing in C++","text":"<p>Since C++11, often referred to as Modern C++, C++ has become a very useful language for scientific computing. Features such as functional programming, type inference, constant expressions, structured binding declarations, ranges, concepts, smart pointers, variant types, and move semantics enabled C++ to catch up with most high-level programming languages. At the same time, C++ was capable of implementing these innovations without dropping its zero-overhead principle, which makes high-performance code expedient.</p> <p>There are several compelling reasons to use C++ in scientific computing:</p> <ul> <li>Performance: scientific applications that rely on approximations through iterative heuristics tend to benefit the greatest from C++.</li> <li>Numeric libraries: there are many reliable numeric libraries available for C++.</li> <li>Integration: it is accessible to integrate C++ libraries into other languages and tools.</li> <li>Licenses: there is no necessity of special licenses, like in Matlab</li> <li>Bindings: one can always call their C++ code from Python, Matlab, or R, for instance.</li> <li>Distribution: if you intend to distribute your compiled code, high-performance machine code circumvents the necessity of creating prototypes in one programming language and then repeating all the work once your experiments are successful.</li> </ul> <p>In parallel with the rising notoriety of Python, it has also become very prevalent the address the most computationally expensive pieces of a Python project in C++. A representative illustration of this strategy is the TensorFlow library. Modern libraries, such as PyBind11, expedite the generation of bindings connecting the two languages, making it easy for C++ programmers to provide performance to libraries in other programming languages.</p> <p>Although the C++ compilation process is how it accomplishes its performance, it might be oftentimes inconvenient to data scientists, who want to smoothly experiment with data more dynamically. An intermediary solution in this regard is CERN's ROOT data analysis framework, which provides Cling, a C++ interpreter. Another option to alleviate this obstacle is to maintain smaller shared libraries with a build tool, which makes the compilation process greatly faster.</p> <p>The absence of a cross-platform building system used to be a limitation of C++ over other languages for scientific computing. However, various recent C++ projects are based on CMake, which is a set of tools for building platform and compiler independent software. With the broad adoption of CMake, projects can be easily rebuilt on different platforms. By combining CMake and Emscripten, zakai2011emscripten makes it possible to even run high-performance C++ on the web with near-native speed. Some popular IDEs, such as CLion and Cevelop, use CMake as a standard format for its C++ projects.</p> <p>Package-management systems are likewise a relevant component of scientific programming, as it allows programmers to quickly experiment with combinations of algorithms. The typical solution to share libraries in C++ used to be header-only libraries, which do not need to be separately compiled. Most packages in the Boost libraries are header-only and work well with the C++ standard library. However, header-only libraries lead to longer compilation times and large libraries, such as Boost, might include too many unnecessary dependencies in our projects.</p> <p>An alternative to header-only libraries has been incorporated into CMake. CMake introduces commands such as <code>ExternalProject</code> and <code>FetchContent</code> to add custom targets to a project. These commands can download subprojects from usual URLs or Git repositories. If the external project is header-only or also based on CMake, the integration is particularly straightforward. Some packages, such as CPM.cmake, extend these features to provide light dependency management to C++ projects. Other packages, such as Conan and Hunter, provide more elaborate package managers. Finally, C++20 offers a feature for modules, which overcome the constraints of header files and make it more accessible to provide packages to existing projects.</p> <p>The standard library in Modern C++ offers many data structures based on templates with minimal computational overhead. This is an extra opportunity for data scientists to optimize their code in styles that are impractical in more simplistic high-level languages. For instance, while Matlab is extremely comfortable for matrix operations, it might become quite inconvenient for projects whose performance depends profoundly on more distinct data structures.</p> <p>There are innumerable C++ libraries for Graphical User Interfaces (GUIs) and low-level High-Performance Graphics. However, in a context where C++ is becoming increasingly more suitable to scientific applications, programmers must have access to libraries for accessible data visualization, for the very same purposes discussed in Section Data Visualization. </p>"},{"location":"white-paper/#alternatives-for-data-visualization-in-c","title":"Alternatives for Data Visualization in C++","text":""},{"location":"white-paper/#bindings","title":"Bindings","text":"<p>One possibility is to use bindings to libraries meant for other high-level languages, such as Matplotlib. One such solution is matplotlib-cpp. These bindings create a convenient environment without too much effort on the user side. For instance, one can produce a line plot in matplotlib-cpp by</p> <pre><code>plt::plot(x,y);\n</code></pre> <p>However, these bindings (i) might create the necessity of large extra dependencies in our project, (ii) could partially eliminate the performance advantages for which developers are likely to have transitioned to C++, (iii) has an integration cost that affects the productivity design goal discussed in Section Data Visualization, (iv) would make integration with native GUIs tough or even impracticable in some circumstances, (v) rely on the maintainers to catch up with the primary package, and (vi) are invariably restricted by the features of the original library.</p> <p>In these situations, depending on the complexity of the project and how much the programmers need data visualization, a more suitable possibility might be to leave the C++ environment entirely, which might be proper to some projects but, as argued in Section Scientific Computing in C++, could deny programmers of gains C++ can offer to many high-performance projects.</p>"},{"location":"white-paper/#exporting-data","title":"Exporting Data","text":"<p>A customary solution among C++ programmers is to export the data from a C++ application in a common format to other environments. The most informal format for exporting data is probably files with Comma-Separated Values (CSV). Excel, Gnuplot, Matlab, or Python can effortlessly import these files.</p> <p>The benefit of this strategy is that programmers can use other mechanisms to produce high-quality plots that are suitable for scientific publications while bypassing the nuisance of learning, integrating, or even implementing a native library. However, this hand-operated method is very unproductive in terms of development cost. Data visualization cannot occur interactively, so the user cannot watch the relevant metrics in real-time. This makes the development cycle longer since various failures cannot be recognized until all experiments are finished.</p> <p>If we avoid this manual process by programmatically exporting and importing the data in real-time to the secondary environment, we can get quasi-interactive plots. However, this requires a significantly higher development cost that could be better employed on the main project. Besides, if plots are refreshed very frequently, this would be comparable to a cumbersome and wasteful implementation of bindings, inheriting all their difficulties discussed in Section Bindings.</p>"},{"location":"white-paper/#plotting-widgets","title":"Plotting widgets","text":"<p>There are innumerable libraries for GUIs in C++. Some representative examples are Qt, wxWidgets, Dear ImGui, Webview, Nana, gtkmm, FLTK, JUCE, Fox toolkit, CEGUI, Sciter, MiniGUI, GuiLite, and Elements. GUI libraries in other programming languages are often bindings to these libraries.</p> <p>There are usually plotting widgets for these libraries. For instance, Qt has its objects for Charts. Libraries such as QCustomPlot can further extend these functionalities. Dear ImGui also incorporates objects for simplistic line plots and histograms. ImPlot provides additional objects for shaded plots, scatter plots, bar graphs, error bars, pie charts, and heatmaps. Some different libraries, like Webview, can take full advantage of any other plotting libraries for HTML.</p> <p>Despite being normally quite restricted in their functionalities, plotting widgets for GUI libraries have many advantages. Once a project has settled on a GUI library for the application, these plotting widgets are appropriate for incorporating supplemental plots into graphical interfaces. They enable interactive plots that communicate excellently with the main application and the final user.</p> <p>However, these are not suited for prototyping or scientific computing. If the programmer has not already engaged to a given GUI library for the project, including these libraries merely for producing plots to observe data might be more costly in terms of development time than the main application. This is particularly true for the initial stages of scientific applications where there is regularly no need for a user interface at all. However, in high-performance computing, these early stages of prototypes might be when we demand data visualization the most. This defeats the productivity criterion discussed in Section Data Visualization. A second obstacle with these widgets is that are usually not meant to produce high-quality graphics for scientific publications. This makes it more troublesome to communicate results.</p>"},{"location":"white-paper/#gnuplot-pipes","title":"Gnuplot Pipes","text":"<p>A popular solution for plots in C++ is to create a pipe to a process running Gnuplot through direct commands. Gnuplot-Iostream implements an <code>istream</code> object that can communicate programmatically with Gnuplot. The chief benefit of this procedure is that we can interactively manage Gnuplot without multiple dependencies.</p> <p>Besides the general weaknesses of bindings (Section Bindings), process pipes to Gnuplot require programmers to compose functions that form strings with the source code to create a given plot in Gnuplot. The user needs to study a different language for plots and this might involve an extensive number of commands even for uncomplicated line plots, which does not make plotting as smooth as expected from data visualization libraries.</p>"},{"location":"white-paper/#the-matplot-library","title":"The Matplot++ library","text":"<p>This article presents the Matplot++ library, a native object-oriented library for data visualization in C++. Objects are organized in a hierarchical structure where parent objects recursively render themselves and their child objects. Meanwhile, users can stream data to these objects with short commands that update these elements to create plots in many representative categories.</p> <p>The follow diagram summarizes the main classes in Matplot++. </p> <p></p> <p>The <code>figure</code> object is the object the ultimately connects to a backend. This might be a backend to render interactive plots or to export graphics to a file. A <code>figure</code> object might have multiple plots represented by <code>axes</code> objects. Each <code>axes</code> object has eight <code>axis</code> objects. For inexperienced users, the most critical of these <code>axis</code> objects are the ones for the coordinates \\(x\\), \\(y\\), and \\(z\\). We discuss these objects in more detail in Section Figures and Axes.</p> <p>An <code>axes object</code> is an abstract class that can hold a collection of primitives representing plots. These are the objects that ultimately embody the plot categories. We list these categories in Section Plot Categories. Lastly, a <code>legend</code> object is responsible for storing a list of labels we can associate to each <code>axes object</code>, and the appearance of the box where we present these labels.</p> <p>For convenience, the library interface has a syntax similar to Matplotlib and Matlab. This is helpful to accommodate users transitioning from these environments. Like Matplotlib, we support two coding styles, based on object-oriented programming and free-standing functions. We address these coding styles in Section Coding Styles. Our interface also employs templates to enable the functions to operate on a range of data types and data structures. We further use method chaining to allow for a more compact syntax.</p> <p>In Section Examples we examine the interface, provide some more high-level usage examples, illustrate the data formats for images, enumerate some limitations of our current implementation, and contrast our library with similar solutions. We supply numerous emblematic samples for all plot categories in this paper. Besides these instances, the library repository further includes a gallery with hundreds of examples that cover all plot categories and subcategories.</p>"},{"location":"white-paper/#figures-and-axes","title":"Figures and Axes","text":"<p>The central object in Matplot++ is a <code>figure</code>, which describes a window or image on which we can plot one or more <code>axes</code> objects. The following Figure depict these main classes in more detail.</p> <p></p> <p>Note that, unless the user needs to control these objects directly, this entire procedure of generating and maintaining the relevant <code>figure</code> for a plot is transparent to the user. The data scientist running a short experiment would probably just call a single command to stream their data to whatever plot category seems more suitable to visualize the data.</p> <p>A simple <code>figure</code> will usually have one <code>axes</code> object that stores the plots. A figure in quiet mode (non-reactive mode), will only be updated when the user calls the <code>draw</code> function, which recursively calls the <code>draw</code> function on all its child objects. This is the function we call to send the appropriate commands or vertices to the backend. If a figure is not in quiet mode, updating a property in any child object will automatically call the <code>draw</code> function. By default, figures are not in quiet mode.</p> <p>The <code>show</code> function is a variant of <code>draw</code> that blocks the execution until the user closes the figure or interacts with the console. This is useful to ensure one can visualize the results before the execution terminates. While this function is helpful for experiments, it should not be employed inside a library that will be used non-interactively. The <code>touch</code> function is intended to be used internally by child objects. The function calls <code>draw</code> only if the figure is in reactive mode.</p> <p>The commands <code>add_axes</code>, <code>add_subplot</code>, and <code>nexttile</code> create and properly position new axes in the figure. <code>add_axes</code> adds a new <code>axes</code> object in any absolute position on the figure, and we can choose to replace an existent <code>axes</code> object if it overlaps with the new axes. <code>add_subplot</code> will construct a new <code>axes</code> object in a position consistent with a layout of <code>rows</code> rows and <code>cols</code> columns. <code>nexttile</code> adds a subplot coherent with the rows, columns, and id defined by <code>tiledlayout</code> and <code>currenttile</code>.</p> <p>All these functions return an <code>axes_handle</code> object, which is a shared pointer to an <code>axes</code> object. The user can use this handle to update axes properties. When the last shared pointer to an <code>axes</code> objects ceases to exist, the <code>axes</code> object is deallocated from memory. The figure also holds a handle <code>current_axes</code>, which points to the last axes we added to the figure unless the user modifies it.</p> <p>The user can create multiple figures in the same process. If they are all interactive figures, this will open multiple windows in the same process. All new figures go to a global figure registry of figure handles. If the user calls a plotting command, it will use the current figure in the registry. The free-standing function <code>gcf()</code> returns a handle to the current figure in the registry. If there is no figure in the registry, <code>gcf()</code> adds a new figure to the registry and returns its handle. Because free-standing functions to create plots rely on <code>gcf()</code>, if there is no current figure in the registry, the registry creates a new figure for any initial plot the command. This allows users to use the library as a resource to stream their data transparently.</p> <p>The <code>axes</code> object is the object responsible for maintaining the plots. The following Figure presents more details.</p> <p></p> <p>A new <code>axes</code> object will have no child objects and no legend. It has only its original collection of <code>axis</code> objects with default attributes for each coordinate. If we draw this new <code>axes</code> object, we get a figure like:</p> <p></p> <p>In this Section, we export the figures with a gray background to help the reader differentiate the figure and axes objects. Analogous to <code>gcf()</code>, the method <code>gca()</code> returns a handle to the current axes in the current figure. If there is no current <code>axes</code> object in the figure, <code>gca()</code> will create a new <code>axes</code>.</p> <p>The method <code>emplace_object</code> pushes a new <code>axes object</code> to the <code>axes</code>. However, this method is not expected to be used directly. A variety of auxiliary methods create the appropriate <code>axes object</code> for a given plot category and make necessary calls to <code>emplace_object</code>. For instance,</p> <pre><code>vector&lt;int&gt; y = {2, 4, 7, 7, 6, 3, 9, 7, 3, 5};\nplot(y);\n</code></pre> <p>is internally equivalent to</p> <pre><code>vector&lt;int&gt; y = {2, 4, 7, 7, 6, 3, 9, 7, 3, 5};\nline_handle l = make_shared&lt;class line&gt;(gca(), y);\ngca()-&gt;emplace_object(l);\n</code></pre> <p>Both would generate this line plot:</p> <p></p> <p>For convenience, we assume throughout this paper we are operating in the <code>matplot</code> and <code>std</code> namespaces. This practice, nevertheless, is probably not recommendable in large projects and surely not advisable in header files.</p> <p>Besides the functions presented in last diagram, the <code>axes</code> object has dozens of methods to control its appearance. The methods can determine the <code>axes</code> location, camera positioning (for 3D plots), shortcuts to define the appearance of <code>axis</code> objects, its title, font properties, colors, grids behind the data, and boxes around the axes. These methods are described in detail in the documentation. There are also dozens of shortcuts to construct and emplace objects representing diverse plot categories. We discuss these categories in Section Plot Categories.</p> <p>The <code>axis</code> objects depict a specific coordinate. The \\(x\\) and \\(y\\) coordinates are used in two-dimensional plots. Two-dimensional plots can also use the extra coordinates \\(x_2\\) and \\(y_2\\). The \\(x\\), \\(y\\), \\(z\\) coordinates are used in three-dimensional plots. The \\(r\\) and \\(t\\) coordinates are used in polar plots. Finally, the \\(cb\\) coordinate is used to determine the range of colorbars. Colorbars are useful to provide a third dimension to two-dimensional plots. For instance, we can use the \\(y_2\\) axis by</p> <pre><code>vector&lt;int&gt; y1 = {1,10,7,6,7,7,4,6,1,6};\nvector&lt;int&gt; y2 = {7,2,9,1,9,7,2,1,10,5};\nplot(y1);\nhold(on);\nplot(y2)-&gt;use_y2(true);\n</code></pre> <p>The <code>hold</code> function determines the <code>next_plot_replace</code> property of the current <code>axes</code>. This property decides whether the next object we emplace in the axes should replace the current objects. The <code>hold</code> function expects a <code>bool</code> as a parameter. As a convenience for users transitioning from Matlab, we use <code>constexpr</code> to define <code>on</code> and <code>off</code> as aliases for <code>true</code> and <code>false</code>. As an extra convenience, note how we call <code>use_y2</code> through method chaining, which can directly alter properties on the handle. The following Figure shows the resulting plot.</p> <p></p> <p>Lastly, if the <code>axes</code> object has a <code>legend</code> object, it will store labels for the data in the axes and manage the presentation of the box with these labels. The <code>legend</code> function can be used to create such an object in the current axes. The function returns a <code>legend_handle</code> we can use to set its appearance. The axes objects can get their labels from the <code>legend</code> object or their <code>display_name</code>. For instance, given a set of line plots, we can combine both strategies by</p> <pre><code>vector&lt;line_handle&gt; ls = plot(random_lines);\nlegend(\"Line 1\", \"Line 2\");\nls[2]-&gt;display_name(\"Line 3\");\n</code></pre> <p>This would create the plot presented in the following Figure:</p> <p></p> <p>In this example, the plot receives four lines as input and returns a list of line handles. We use <code>legend</code> function to attribute a label to the first two line handles that have no display name. The third line has its label directly defined with <code>display_name</code>. The fourth line has no legend.</p>"},{"location":"white-paper/#plot-categories","title":"Plot Categories","text":"<p>An <code>axes</code> object can hold plots in many categories. An <code>axes object</code> is an abstract class that represents what should be drawn in the axes. The following Figure  shows the objects that inherit from <code>axes objects</code>.</p> <p></p> <p>These objects represent primitives that can compose a plot. A plot category might depend on more than one <code>axes object</code>. For instance, contour lines might depend on <code>contours</code> and <code>labels</code>. The same <code>axes object</code> can also serve a number of plot categories. For instance, a <code>matrix</code> can represent heatmaps and images. By composing <code>axes objects</code>, the library offers functions to create plots in the following main categories:</p> <ul> <li>Line Plots (Section Line Plots)</li> <li>Data Distribution (Section Data Distribution)</li> <li>Discrete Data (Section Discrete Data)</li> <li>Geography (Section Geography)</li> <li>Polar Plots (Section Polar Plots)</li> <li>Contour Plots (Section Contour Plots)</li> <li>Vector Fields (Section Vector Fields)</li> <li>Surfaces (Section Surfaces)</li> <li>Graphs (Section Graphs)</li> <li>Images (Section Images)</li> <li>Annotations (Section Annotations)</li> </ul> <p>In the following subsections, we discuss some important details of the algorithms in each of these categories.</p>"},{"location":"white-paper/#line-plots","title":"Line Plots","text":"<p>The Line Plots cover the following subcategories: Line Plot; Line Plot 3D; Stairs; Error Bars; Area; Loglog Plot; Semilogx Plot; Semilogy Plot; Function Plot; Function Plot 3D; and Implicit function. Plots in this category depend on the <code>line</code> object. This object stores data for two or three-dimensional lines.</p> <p>The <code>error bar</code> object includes extra lines to represent error around data points. Log plots are utility functions that adjust the \\(x\\) or \\(y\\) axes to a logarithmic scale. The <code>stair</code> object renders the line with stairs between data points to denote discrete data. Instead of storing data points, the objects <code>function line</code> and <code>string function</code> store a function as a lambda function or as a string with an expression. These objects use lazy evaluation to generate absolute data points. The data is generated only when the <code>draw</code> function is called.</p> <p>The <code>filled area</code> object creates a polygon filling the area between the \\(x\\) axis and each line. Each of these plots can be created by</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; Y = { {1, 3, 4, 0}, {2, 5, 4, 7}, {6, 4, 5, 3} };\narea(Y, -4, stacked);\n</code></pre> <p>where <code>stacked</code> is a boolean that tells whether the lines in <code>Y</code> should be stacked.</p>"},{"location":"white-paper/#data-distribution","title":"Data Distribution","text":"<p>The Data Distribution category includes the following subcategories: Histogram; Boxplot; Scatter Plot; Scatter Plot 3D; Binned Scatter Plots; Plot Matrix; Parallel Coordinates; Pie Chart; Heatmap; and Word Cloud. These plot subcategories depend on the <code>axes object</code> types <code>histogram</code>, <code>box chart</code>, <code>line</code>, <code>matrix</code>, <code>parallel lines</code>, <code>circles</code>, <code>labels</code>.</p> <p>The <code>histogram</code> object creates the histogram edges and bins when the <code>draw</code> function is called for the first time with lazy evaluation. Lazy evaluation avoids calculating edges unnecessarily in case the user changes the object parameters before calling <code>draw</code>. This object includes several algorithms for automatically delimiting the edges and bins for the histograms. This Figure exemplifies some of these algorithms.</p> <p></p> <p>Like the Line Plot subcategories, Scatter plots also depend on the <code>line</code> object. As the line object can represent lines with markers, the <code>scatter</code> function simply creates markers without the lines. Binned scatter plots use variations of the histogram algorithms of the previous Figure as an extra step to place all the data into two-dimensional bins that can be represented with varying colors or sizes. This is useful when there are so many data points that a scatter plot would be impractical for visualizing the data. The Plot Matrix subcategory is a combination of histograms and scatter plots. It creates a matrix of <code>axes</code> objects on the <code>figure</code> and creates a scatter plot for each pair of data sets.</p> <p>The function <code>parallelplot</code> creates a plot with Parallel Coordinates. In this type of plot, a <code>parallel lines</code> object stores an arbitrary set of <code>axis</code> objects to represent multi-dimensional data. This Figure exemplifies the parallel coordinates we can generate by</p> <p></p> <pre><code>vector&lt;vector&lt;double&gt;&gt; X(4);\nX[0] = randn(100,50,200);\nX[1] = transform(X[0], [](double x){ return x + rand(-30, +30);});\nX[2] = transform(X[0], [](double x){ return x &gt; 50 ? +1. : -1.;});\nX[3] = transform(X[0], [](double x){ return cos(rand(-30, +30));});\nparallelplot(X,X[2]);\n</code></pre> <p>where <code>randn</code> and <code>transform</code> are shortcuts to generate random numbers with a normal distribution and to transform data. The second parameter of <code>parallelplot</code> determines the color of each data point, for which we use <code>X[2]</code>. Those axes are generated on top of a two-dimensional <code>axes</code> object.</p> <p>Word clouds are generated from text or pairs of words and their frequency. After attributing a size proportional to each word frequency, the algorithm to position the labels iterates words from the largest to the smallest. For each word, it spins the word in polar coordinates converted to Cartesian coordinates until it does not overlap with any other word. This Figure exemplifies a word cloud we can generate by</p> <p></p> <pre><code>wordcloud(tokens, count);\n</code></pre> <p>By default, the colors and the sizes depend on the word frequencies. We can customize the colors by passing a third parameter to the <code>wordcloud</code> function.</p>"},{"location":"white-paper/#discrete-data","title":"Discrete Data","text":"<p>The Discrete Data category includes the following subcategories: Bar Plot; Pareto Chart; Stem Plot; and Stem Plot 3D. These subcategories depend on the <code>axes object</code> types <code>bars</code> and <code>line</code>. Bar Plots depend on the <code>bars</code> object. Pareto Charts emplace a combination of <code>bars</code> and <code>line</code>. Stem plots rely on the <code>line</code> object.</p> <p>Pareto Charts are a type of chart that uses both \\(y\\) axes. The \\(y_1\\) axis is used to represent bars with the data values in descending order. The \\(y_2\\) axis is used to represent the cumulative distribution function of the data in the \\(y_1\\) axis. This next Figure exemplifies a Pareto chart generated by</p> <pre><code>vector&lt;double&gt; y = randn(20,500,1000);\npareto(y);\n</code></pre> <p></p> <p>By default, a Pareto Chart includes up to 10 items or as many items as needed to represent 95\\% of the cumulative distribution.</p> <p>If the reader needs Pareto fronts rather than Pareto charts, we refer to Scatter Plots for two-dimensional fronts, Plot matrices for three-dimensional fronts, or Parallel Coordinates for many-objective fronts. These plot subcategories are described in Section Data Distribution. If the user also needs a tool to calculate these fronts efficiently, we refer to the Pareto Front Library.</p>"},{"location":"white-paper/#geography","title":"Geography","text":"<p>The Geography category includes the following subcategories: Geoplot, Geoscatter, Geobubble, and Geodensity. All these subcategories depend on the <code>line</code> object to plot maps and data over these maps. For the first geography plot, we call <code>geoplot()</code>, which creates a filled polygon with the world map. This first plot receives the tag <code>\"map\"</code> so that subsequent geography plots recognize there is no need to recreate this world map.</p> <p>The data for the world map comes from Natural Earth. They provide data at 1:10m, 1:50m, and 1:110m scales. The <code>geoplot</code> function will initially use the data at the 1:110m scales. The <code>geolimits</code> function can be used to update the axis limits for geography plots. The difference between the usual functions for adjusting axis limits (<code>xlim</code> and <code>ylim</code>) and <code>geolimits</code> is that the latter will also update the map resolution according to the new limits for the \\(x\\) and \\(y\\) axis.</p> <p>The <code>geolimits</code> function will query the <code>figure</code> size and, depending on the new limits for the axes, update the map to the 1:10m, or 1:50m scales if needed. Because it would be very inefficient to render the whole world map at a 1:10m or 1:50m scale only to display a region of this map, the <code>geolimits</code> function also crops the data pertinent to the new region being displayed.</p> <p>Note that this does not only involve removing data points outside the new limits but it also needs to create new data points on the correct borders to create new polygons coherent with the map entry points in the region. For this reason, the algorithm needs to track all submaps represented as closed polygons in the original world map. If submaps are completely inside or outside the new ranges, we can respectively include or dismiss the data points. However, if the submap is only partially inside the new limits, to generate the correct borders for the polygons, we need to track all points outside the limits to classify the directions of these points outside the limits. We do that by only including points that change quadrants around the new limits so that the map entry points create polygons that look like they would if the complete world map were still being rendered outside these new limits.</p> <p>If the library user is not interested in geographic plots, the build script includes an option to remove the high-resolution maps at 1:10m and 1:50m scales from the library. In this case, the library will always use the map at a 1:110m scale no matter the axis limits. Figure exemplifies the map generated by</p> <p></p> <pre><code>auto [lon,lat,names] = world_cities(6,8);\nauto [lon2, lat2] = greedy_tsp(lon,lat);\ngeoplot(lat2,lon2)-&gt;marker(\"o\").marker_colors(iota(1,names.size()));\ntext(lon,lat,names);\n</code></pre> <p>The function <code>world_cities</code> returns a list of major world cities. Its parameters define the minimum distances between cities in the \\(x\\) and \\(y\\) axes. The <code>greedy_tsp</code> function is a naive greedy algorithm to find a route between these cities as a Traveling Salesman Problem (TSP). We use the <code>geoplot</code> function to draw this route. Note that we use method chaining to define some further plot properties. Finally, the <code>text</code> function includes the city names in the map.</p>"},{"location":"white-paper/#polar-plots","title":"Polar Plots","text":"<p>The Polar Plots category includes the following subcategories: Polar Line Plot, Polar Scatter Plot, Polar Histogram, Compass, and Polar Function. These subcategories depend on the <code>axes object</code> types <code>line</code>, <code>histogram</code>, <code>vectors</code>, <code>string function</code>, and <code>function line</code>. By emplacing a polar plot in the <code>axes</code>, the <code>axes</code> move to a polar mode, where we use the \\(r\\) and \\(t\\) axis instead of the \\(x\\) and \\(y\\) axis.</p> <p>From the backend point of view, these axes are an abstraction to the user. The data points in the \\(r\\) and \\(t\\) axis are drawn by converting the positions from the polar coordinates \\(r\\) and \\(t\\) to the Cartesian coordinates \\(x\\) and \\(y\\) with the relationships \\(x=r \\cos{t}\\) and \\(y=r \\sin{t}\\).</p> <p>Aside from this conversion, these plot subcategories are analogous to line plots, scatter plots, histograms, quiver plots, and line functions. The next Figure exemplifies the polar histogram generated by</p> <pre><code>vector&lt;double&gt; y = randp(100,1.0,0.5);\npolarhistogram(y, 25);\n</code></pre> <p></p> <p>The function <code>polarhistogram</code> distributes the data into the number of bins provided as its second parameter.</p>"},{"location":"white-paper/#contour-plots","title":"Contour Plots","text":"<p>The Contour Plots category includes the following subcategories: Contour Plots, Filled Contours, and Function Contour. All these subcategories depend on the <code>contours</code> type. They also depend on lazy evaluation for generating the contour lines. When the function <code>draw</code> is called in the <code>contours</code> class, it preprocesses all contour lines for a three-dimensional function.</p> <p>Although it is relatively simple to show a heatmap with the values for the \\(z\\)-axis, calculating contour lines relative to the \\(z\\)-axis is more complex than it might seem at first. We provide the function <code>contourc</code> for calculating contour lines. This function uses an adaptation of the algorithm adopted by Matplotlib.</p> <p>The algorithm creates a quad grid defined by the \\(x\\) and \\(y\\) values. It uses this grid to infer a contour line passing through positions with the same \\(z\\) value. The algorithm sweeps through the grid twice to generate these lines. The first sweep looks for lines that start on the boundaries. The second sweep looks for interior closed loops.</p> <p>Filled contours are closed polygons for pairs of contour levels. Some polygons for filled contours might be holes inside other polygons. The algorithm needs to keep track of these relationships so that we can render the polygons in their accurate order. To avoid an extra step that identifies this relationship between the polygons, the sweeping algorithm already identifies which polygons are holes for each level.</p> <p>Once we find the quads with the contour line, the line is generated by interpolating the \\(z\\) values around that quad. For instance, consider the Rastrigin function:</p> <pre><code>auto rastrigin = [](double x, double y) {\n    return 10 * 2 + pow(x,2) - 10 * cos(2*pi*x) + pow(y,2) - 10 * cos(2*pi*y);\n};\n</code></pre> <p>The next Figure exemplifies the filled contour lines generated for this function by</p> <pre><code>fcontour(rastrigin)-&gt;filled(true);\n</code></pre> <p></p> <p>By default, the function <code>fcontour</code> will generate 9 contour lines from a lambda function. The functions <code>contour</code> and <code>contourf</code>, on the other hand, plot contour lines and filled contour lines from a grid of data points for \\(x\\), \\(y\\), and \\(z\\).</p>"},{"location":"white-paper/#vector-fields","title":"Vector Fields","text":"<p>The Vector Fields category includes the following subcategories: Feather, Quiver, and Quiver 3D. All these subcategories depend on the <code>vectors</code> object type. In a two-dimensional plot, for each value of \\(x\\) and \\(y\\) with the position of a vector, it also requires the value of \\(u\\) and \\(v\\) indicating its direction and magnitude. In a three-dimensional plot, the direction and magnitude are defined by \\(u\\), \\(v\\), and \\(w\\).</p> <p>A quiver plot (or velocity plot) shows a grid of vectors whose direction and magnitude are scaled to prevent the overlap between vectors in subsequent quads. Still considering the Rastrigin function, we can generate a grid with its data values and its gradient by</p> <pre><code>auto [x,y] = meshgrid(iota(-5,.2,5));\nauto z = transform(x,y,rastrigin);\nauto [dx,dy] = gradient(z,.2,.2);\n</code></pre> <p>where <code>meshgrid</code>, <code>transform</code>, and <code>gradient</code> are simple convenience functions. We can then present the contours lines and the gradient directions by</p> <pre><code>contour(x,y,z);\nhold(on);\nquiver(x,y,dx,dy);\n</code></pre> <p>The following Figure quiver presents the results, where the quiver vectors help us identify the directions in which the function is decreasing in the contour plot.</p> <p></p>"},{"location":"white-paper/#surfaces","title":"Surfaces","text":"<p>The Surfaces category includes the following subcategories: Surface; Surface with Contour; Mesh; Mesh with Contour; Mesh with Curtain; Function Surface; Function Mesh; Waterfall; Fence; and Ribbon. All these subcategories depend on the <code>surface</code> class.</p> <p>The Waterfall, and Fence subcategories create surface slices for each value of \\(y\\). The Ribbon subcategory creates surface slices for each value of \\(x\\). Still considering the Rastrigin function, the next Figure exemplifies the Ribbon plot generated by</p> <pre><code>auto [X,Y] = meshgrid(iota(-5,1,5),iota(-5,.1,5));\nauto Z = transform(X,Y,rastrigin);\nribbon(X,Y,Z)-&gt;face_alpha(0.8);\n</code></pre> <p></p> <p>To make the visualization more comfortable, we define a larger step size on the \\(x\\) axis.</p>"},{"location":"white-paper/#graphs","title":"Graphs","text":"<p>The Graphs category includes the following subcategories: Undirected Graphs; and Directed Graphs. All these subcategories depend on the <code>network</code> class. Graphs are abstract structures that represent objects and relationships between these objects. The objects are represented as vertices and the relationships are depicted as edges.</p> <p>In an abstract graph, the vertices have no specific position in space. Mathematically, a graph does not depend on its layout. However, the graph layout has a large impact on its understandability. The <code>network</code> class can calculate appropriate positions for graph vertices with several algorithms: Kamada Kawai algorithm, Fruchterman-Reingold algorithm, circle layout, random layout, and automatic layout.</p> <p>The implementation of the Kamada Kawai and Fruchterman-Reingold algorithms depend on the NodeSoup library. The next Figure exemplifies the Undirected Graph generated by</p> <pre><code>vector&lt;pair&lt;size_t, size_t&gt;&gt; edges ={ {0, 1},\n                                      {0, 2},\n                                      {1, 2},\n                                      {1, 4},\n                                      {2, 3},\n                                      {3, 5},\n                                      {4, 5},\n                                      {4, 6},\n                                      {6, 8},\n                                      {8, 9},\n                                      {7, 9},\n                                      {8, 7},\n                                      {9, 10} };\nvector&lt;double&gt; weights = {4,4,2,1,1,4,2,1,3,3,2,4,1};\ngraph(edges)-&gt;edge_labels(weights);\n</code></pre> <p></p> <p>The automatic layout uses the Kamada Kawai algorithm for small graphs and the Fruchterman-Reingold algorithm for larger graphs.</p>"},{"location":"white-paper/#images","title":"Images","text":"<p>The Images category includes the following subcategories: Image Show; Image Matrix; and Scaled Image. These subcategories depend on the <code>matrix</code> class. The <code>matrix</code> class can have up to four matrices. If it has only one matrix, it is represented with a colormap. If it has three matrices, they represent the red, green, and blue channels. If it has four matrices, the fourth matrix represents an alpha channel to control the transparency of each pixel.</p> <p>We use the CImg library to load and save images. CImg can handle many common image formats as long as it has access to the appropriate libraries. The Matplot++ build script will look at compile-time for the following optional libraries: JPEG, TIFF, ZLIB, PNG, LAPACK, BLAS, OpenCV, X11, fftw3, OpenEXR, and Magick++. The build script will attempt to link all libraries from this list to Matplot++.</p> <p>Matplot++ includes a few convenience functions to manipulate matrices with images: <code>imread</code>, <code>rgb2gray</code>, <code>gray2rgb</code>, <code>imresize</code>, and <code>imwrite</code>. All these functions work with lists of matrices. The next Figure exemplifies the image generated by</p> <pre><code>auto image = imread(\"lena_gray.tiff\");\nimshow(image[0]);\ncolormap(palette::default_map());\n</code></pre> <p></p> <p>Because <code>image</code> is a list of matrices, <code>image[0]</code> is a matrix with the gray channel. If we used <code>imread</code> to load a colored image, <code>image[0]</code> would represent the red channel. Because the matrix has only one channel, it uses the default colormap. By default, the <code>imshow</code> function sets the grayscale colormap as the axes colormap. We use the <code>colormap</code> function to change it to the default colormap and generate a colored image.</p>"},{"location":"white-paper/#annotations","title":"Annotations","text":"<p>The Annotations category includes the following subcategories: Text; Text with Arrow; Rectangle; Filled Polygon; Ellipse; Textbox; Arrow; and Line. These subcategories depend on the <code>axes object</code> types <code>labels</code>, <code>line</code>, and <code>vectors</code>. The annotations category is meant to create individual objects on the plot rather than representations of data sets.</p> <p>An important difference between the annotations category and other categories is that, by default, the annotations do not replace the plot that already exists in the <code>axes</code> object, even if the user does not call the <code>hold</code> function. The next Figure exemplifies a number of annotations generated by</p> <pre><code>vector&lt;double&gt; x = {0,8,8,0};\nvector&lt;double&gt; y = {0,0,4,4};\npolygon(x, y, \"g\");\nrectangle(0,0,2,4,0)-&gt;fill(true).color(\"red\");\nrectangle(3,0,2,4,1)-&gt;fill(true).color(\"magenta\");\nrectangle(6,0,2,4,0.5)-&gt;fill(true).color(\"yellow\");\ntext(2,2,\"Curvature 0\")-&gt;alignment(labels::alignment::right);\ntext(4,2,\"Curvature 1\")-&gt;alignment(labels::alignment::center);\ntext(6,2,\"Curvature 0.5\")-&gt;alignment(labels::alignment::left);\narrow(4,2.2,3,3);\ntextarrow(6,1,8,0,\"Last corner\");\n</code></pre> <p></p> <p>The rectangle object can have a border curvature from \\(0\\) to \\(1\\). We can also annotate with text, arrows, polygons, and lines.</p>"},{"location":"white-paper/#appearance","title":"Appearance","text":"<p>All objects have numerous methods to control their appearance. This control is fundamental for high-quality publication images. As a convenience, the <code>colors.h</code> header contains many functions to generate colors from strings and vice-versa. It also contains dozens of functions to generate colormaps.</p> <p>The <code>axes</code> object has functions to control the labels for each axis, the subplot title, and the legends for child objects. Each <code>axis</code> object has functions to control its limits, manually adjust the axis ticks, define labels for manual ticks, and label formats for automatic ticks.</p> <p>There are various functions that allow and facilitate multiplots in a figure. The <code>hold</code> and <code>use_y2</code> functions allow multiple plots on the same <code>axes</code> object. The <code>subplot</code> and <code>nexttile</code> functions allow a layout with many <code>axes</code> objects on the same <code>figure</code>. Another option is to create extra <code>figure</code> objects, which would open more plot windows.</p> <p>The colormaps can be used with two-dimensional plots to represent an extra dimension.  Finally, the <code>view</code> and <code>lightning</code> functions can be used in three-dimensional plots to change the camera position and light intensity. The next Figure exemplifies two camera and lighting configurations for the Ackley function. The example is generated by</p> <pre><code>auto ackley = [](double x, double y) {\n    return -20 * exp(-0.2 * sqrt(0.5 * (pow(x,2)+pow(y,2))))\n           - exp(0.5 * (cos(2*pi*x) + cos(2*pi*y))) + exp(1) + 20;\n};\n\nsubplot(1,2,0);\nfsurf(ackley)-&gt;lighting(true).primary(0.7).specular(0.9);\n\nsubplot(1,2,1);\nfsurf(ackley);\nrotate(20,30);\n</code></pre> <p></p>"},{"location":"white-paper/#coding-styles","title":"Coding Styles","text":""},{"location":"white-paper/#member-vs-free-standing-functions","title":"Member vs. Free-standing Functions","text":"<p>Like in Matplotlib, we support two coding styles: Free-standing functions and an Object-oriented interface. With free-standing functions, we call functions to create plots on the current axes. The global current <code>axes</code> object is the current <code>axes</code> object in the current figure in the global figure registry (Section Figures and Axes). For instance, one can use <code>plot(y);</code> to create a line plot on the current axes (or create a new <code>axes</code> object if needed). Also, one can use <code>plot(ax,y);</code> to create a line plot on the <code>axes</code> object <code>ax</code>. This is less verbose for small projects and quick tests. The library looks for existing axes to create the plot.</p> <p>In the object-oriented interface, we explicitly create figures and call methods on them. For instance, one can use <code>ax-&gt;plot(y);</code> to plot on the <code>axes</code> object <code>ax</code>. We can create the same line plot on the current axes by <code>auto ax = gca(); ax-&gt;plot(y);</code>. This is less verbose and provides better control in large projects where we need to pass these objects around. The user manages axes handles containing plots.</p> <p>Assuming the user is explicitly managing the axes to create plots in another function, a more complete example of these styles could be</p> <pre><code>// Free-standing functions\nauto ax = gca();\nplot(ax, x, y)-&gt;color(\"red\").line_width(2);\nmy_function(ax);\n</code></pre> <p>and</p> <pre><code>// Object-oriented interface\nauto ax = gca();\nax-&gt;plot(x, y)-&gt;color(\"red\").line_width(2);\nmy_function(ax);\n</code></pre> <p>Both examples would generate the same plot. All free-standing functions are templated functions that use meta-programming to call the main function on the current <code>axes</code> object. If the first parameter is not an <code>axes_handle</code>, it will get an <code>axes_handle</code> from the figure registry with <code>gca</code> (Section Figures and Axes) and forward all parameters to the function in this <code>axes</code> object. If the first parameter is an <code>axes_handle</code>, the template function will forward all parameters, but the first one, to this <code>axes</code> object. This use of templates for the free-standing functions keeps both coding styles maintainable by the developers.</p> <p>Note that, because the example needs the <code>axes</code> object for the function <code>my_function</code>, we also need to get a reference to the <code>axes</code> object with the free-standing functions. In that case, the free-standing functions are not less verbose than the object-oriented interface.</p> <p>To adhere to free-standing functions, we could create two versions of <code>my_function</code>: one that receives an <code>axes_handle</code>, and a second version that would get an <code>axes_handle</code> from the figure registry and call the first version. If <code>my_function</code> is going to be exposed to other users as a library, this could be a convenience to these users. However, notice that this is only moving the verbosity from the main function to <code>my_function</code>. In fact, this is how the free-standing functions in Matplot++ work.</p>"},{"location":"white-paper/#reactive-figures","title":"Reactive figures","text":"<p>There are also two modes for figures: reactive (or interactive) mode and quiet mode. Figures in reactive mode are updated whenever any of their child objects change. This happens through the <code>touch</code> function, that gets called on any child object when it changes its appearance. This creates an interactive mode in which figures are updated as soon as we adjust their properties. If we combine interactive figures with free-standing functions, we have a \"Matlab-like style\" for plots. This is a coding pattern where the figure registry works as a stream for plots. The problem with this coding style is that the user might unnecessarily create useless intermediary plots.</p> <p>Figures in quiet mode are updated by calling the functions <code>draw()</code> or <code>show()</code> (Section Figures and Axes). Unless these functions are called, nothing changes in the figure. The combination of the object-oriented coding style and quiet mode is the \"OO-Matplotlib-like style\" for plots. This is a coding style in which the user explicitly decides when the plot is shown or updated. This is beneficial to applications that cannot waste computational resources on intermediary figures that might not be valuable to the application.</p> <p>We generally use free-standing functions with reactive mode and the object-oriented interface with quiet mode. By default, new figures are in reactive mode, unless it is using an non-interactive backend. One can turn this reactive mode on and off with:</p> <ul> <li><code>ion()</code> or <code>ioff()</code> free-standing functions</li> <li><code>reactive(bool)</code> or <code>quiet(bool)</code> function on the <code>figure</code> object</li> <li><code>figure(true)</code> or <code>figure(false)</code> when explicitly creating a new figure</li> </ul> <p>A more complete example of the reactive mode would be:</p> <pre><code>// Reactive mode\nauto f = gcf(false);\nauto ax = f-&gt;gca();\nauto p = ax-&gt;plot(ax, x, y);   // draws once\np-&gt;color(\"red\").line_width(2); // draws twice more\nwait();                        // pause console\n</code></pre> <p>For convenience, the examples in Section Plot Categories use the reactive mode. The <code>wait</code> function pauses the console until the user interacts with the plot window. If the backend is based on process pipes, because these are unidirectional, closing the window is not enough to resume. The user needs to use the console to unblock execution. A similar example is quiet mode would be</p> <pre><code>// Quiet mode\nauto f = gcf(true);\nauto ax = f-&gt;gca();\nauto p = ax-&gt;plot(x,y);        // does not draw\np-&gt;color(\"red\").line_width(2); // does not draw\nf-&gt;show();                     // draw only once and pause console\n</code></pre> <p>In this example, the figure is only updated once. The user could replace the <code>show</code> function with the <code>draw</code> function, but the window would close as soon as execution completes. It is important to use <code>wait()</code> and <code>show()</code> with caution. These functions are meant for some particular executables so that an interactive plot does not close before the user can see it. It is probably unreasonable to call these functions inside a library because the user would have to manually interfere with the execution to continue.</p>"},{"location":"white-paper/#method-chaining","title":"Method Chaining","text":"<p>To support a more compact syntax, the library allows method chaining on plot objects. For instance, we can create a simple line plot and modify its appearance by</p> <pre><code>// Using the line handle\nauto p = plot(x,y,\"--gs\");\np-&gt;line_width(2);\np-&gt;marker_size(10);\np-&gt;marker_color(\"b\");\np-&gt;marker_face_color({.5,.5,.5});\n</code></pre> <p>or</p> <pre><code>// Method chaining\nplot(x,y,\"--gs\")-&gt;line_width(2).marker_size(10).marker_color(\"b\").marker_face_color({.5,.5,.5});\n</code></pre> <p>The first code snippet works because <code>plot</code> returns a <code>line_handle</code> to the object in the <code>axes</code>. We can use this line handle to modify the line plot. Whenever we modify a property, the setter function calls <code>touch</code>, which will <code>draw</code> the figure again if it is in reactive mode. The second option works because setters return a reference to <code>*this</code> rather than void. </p>"},{"location":"white-paper/#ranges","title":"Ranges","text":"<p>The plotting functions work on any range of elements convertible to <code>double</code>. For instance, we can create a line plot from a set of elements by</p> <pre><code>set&lt;int&gt; y = {6,3,8,2,5};\nplot(y);\n</code></pre> <p>Any object that has the functions <code>begin</code> and <code>end</code> are considered iterable ranges. Most <code>axes object</code> subclasses use <code>vector&lt;double&gt;</code> or <code>vector&lt;vector&lt;double&gt;&gt;</code> to store their data. For convenience, the <code>common.h</code> header file includes the aliases <code>vector_1d</code> and <code>vector_2d</code> to these data types.</p> <p>These conversions also work on ranges of ranges:</p> <pre><code>vector&lt;set&lt;int&gt;&gt; Y = { {6, 3, 8, 2, 5}, {6, 3, 5, 8, 2} \n};\nplot(Y);\n</code></pre> <p>Unfortunately, because of how templated functions work, one exception is initializer lists. Initializer lists only work for functions that are explicitly defined for them.</p>"},{"location":"white-paper/#utilities","title":"Utilities","text":"<p>The headers <code>common.h</code> and <code>colors.h</code> include a number of utilities we use in our examples. These include naive functions to generate and manipulate vectors and strings; handle RGBA color arrays; convert points to and from polar coordinates; read files to strings; write strings to files; calculate gradients; read, write, and manipulate images; and generate vectors with random numbers. Although some of these functions might be helpful, most functions only operate on <code>vector&lt;double&gt;</code> and they are not intended to be a library of utilities. The sole purpose of these algorithms is to simplify the examples.</p>"},{"location":"white-paper/#backend-interface","title":"Backend Interface","text":"<p>While Matplot++ provides a shared representation for plots, there are innumerable technologies through which these objects can become interactive or non-interactive images. Users might want to export images, monitor metrics in real-time, or generate images for GUIs that might involve several libraries. It is unrealistic to anticipate the technologies involved in all applications that might benefit from Matplot++. </p> <p>The only way to open these possibilities to users is by separating the implementation layers managing objects from the layers that generate the images for a given application. This enables users to reuse the Matplot++ data structures in any application. For this reason, the <code>figure</code> object stores a shared pointer to a <code>backend_interface</code> that is responsible for ultimately drawing the plots.</p> <p>Libraries, such as Matplotlib, and languages with plotting capabilities, like Octave, usually have many backends for drawing objects, depending on the operating system and user demands. For interactive plots, these usually involve backends that are specific to the operating system.</p> <p>The <code>backend_interface</code> has many virtual functions that can be overridden to create new backends for these plots. The first set of functions in this interface are designed to identify the operation mode of a backend. The function <code>is_interactive</code> returns whether a backend is in interactive mode. Note that a backend can operate on both modes, depending on its parameters. For instance, a Gnuplot backend can work in interactive or non-interactive mode, depending on its terminal. Also, an OpenGL backend can work in non-interactive mode, in which case we would export its current pixels to an image file. The function <code>output</code> defines the output file name and file format for non-interactive plots.</p> <p>The next set of functions in the <code>backend_interface</code> are related to figure properties. These include functions to set or get the figure properties such as width, height, position, background color. The position is mostly relevant for interactive plots. Note that although we can set the image size through the <code>figure</code> object, the width and height properties are ultimately stored in the backend. The reason for this is that, in interactive plots, the user might manually move and resize the window, and the <code>figure</code> object has to respond accordingly.</p> <p>The last set of commands are related to drawing. In that regard, there are two types of backends. Some backends, like a Gnuplot backend, are based on commands and some backends, like an OpenGL backend, are based on vertices. We could try to recreate Gnuplot commands that would emulate a library based on vertices, but such a strategy would be wasteful. It would require the Gnuplot backends to find workarounds to bypass its default axes objects, manually recreate projections, and require the Gnuplot pipe to execute more commands than would be necessary for the plots. </p> <p>In that case, our preliminary solution has been to include interfaces for commands and vertices. If a backend is based on commands, functions such as <code>run_command</code> should be overridden to consume these commands. If a backend is based on vertices, functions such as <code>draw_path</code> and <code>draw_image</code> should be overridden to directly draw the specified vertices on the canvas.  Because the library is in an embryonic stage regarding its available backends, the <code>backend_interface</code> is open for change as we identify new demands from backend developers. These extensions might involve more complex strategies for unifying the types of backends, internal algorithms for 3D graphical projections, or abstractions to draw different types of objects through the backend.</p>"},{"location":"white-paper/#examples","title":"Examples","text":"<p>In this Section, we compare our interface with other similar libraries, provide examples integrating the library into some scientific applications, explain how unique plot categories can be defined, and discuss some limitations of the library.</p>"},{"location":"white-paper/#interface","title":"Interface","text":"<p>Although the internal structure of Matplot++ is not the same as Matplotlib or the Matlab graphics functions, all interfaces are very similar. The comparable function names are mostly intended as a convenience to the transitioning user who is not concerned about specific internal details of the library.</p> <p>We cover almost all plot categories that exist in Matplotlib and Matlab. However, it seems like Matplotlib has no special plot category for networks. In Python, this can be solved with NetworkX. It is also important to note that Matlab has innumerable astounding toolboxes for various categories of problems and these toolboxes tend to include graphics for their specific domains. Matplot++ has neither the intention nor the capacity to compete in that domain.</p>"},{"location":"white-paper/#a-minimal-application","title":"A Minimal Application","text":"<p>Section Plot Categories previously included many examples that cover each plot category. The repository contains hundreds of examples that include all subcategories. Thus, it would be redundant to spend this Section with disconnected examples of more plot subcategories. Rather, in this Section we exemplify a use case where the user wants to integrate plots into a minimal application. This provides an opportunity to discuss how one can manage handles and apply the coding styles of Section Coding Styles in an application.</p> <p>In this example, let us suppose our data scientist is using the Travelling Salesman Problem (TSP) as a model to plan an Eurotrip. We can define the city names and their geographical positions:</p> <pre><code>vector&lt;string&gt; names = {\"Tirana\", \"Andorra la Vella\", \"Vienna\" /*, ...*/};\nvector&lt;double&gt; lat = {+41.3317,+42.5075,+48.2092 /*,...*/};\nvector&lt;double&gt; lon = {+19.8172,+1.5218,+16.3728 /*,...*/};\n</code></pre> <p>The complete example, with 44 cities, is available in our repository. Because the <code>axes</code> object is going to be managed inside an application, we create a quiet figure and pass its only <code>axes</code> object to our object <code>eurotrip_solver</code> representing the application by</p> <pre><code>figure_handle f = figure(true);\neurotrip_solver s(lat,lon,names, f-&gt;current_axes());\ns.run();\n</code></pre> <p>The <code>eurotrip_solver</code> has the following interface:</p> <pre><code>class eurotrip_solver {\npublic:\n    eurotrip_solver(const vector&lt;double&gt;&amp; lat, const vector&lt;double&gt;&amp; lon, const vector&lt;string&gt;&amp; names, axes_handle ax);\n    void run(int iterations = 100);\n\nprivate:\n    void setup_starting_point(size_t iteration);\n    double tour_distance(const vector&lt;size_t&gt;&amp; tour);\n    void iteration();\n    static vector&lt;vector&lt;size_t&gt;&gt; get_neighbors(const std::vector&lt;size_t&gt;&amp; tour);\n    bool update_if_better(const vector&lt;size_t&gt; &amp;neighbor);\n    void draw_if_improvement();\n    void draw();\n\nprivate:\n    vector&lt;double&gt; lat_;\n    vector&lt;double&gt; lon_;\n    vector&lt;string&gt; names_;\n    axes_handle ax_;\n\n    // Current tour\n    double curr_dist_{0.0};\n    vector&lt;size_t&gt; curr_tour_;\n\n    // Best tour\n    double min_dist_{0.0};\n    vector&lt;size_t&gt; best_tour_;\n};\n</code></pre> <p>A note to programmers not familiar with C++ is that <code>size_t</code> is an unsigned integer type commonly used to represent sizes and indexes. The <code>eurotrip_solver</code> object includes a reference to an <code>axes_handle</code> and <code>vector</code>s with information about the cities. This is all the information we need to plot our map. The <code>run</code> function will generate a new starting tour <code>curr_tour_</code> and run an iteration of the algorithm <code>iterations</code> times:</p> <pre><code>void eurotrip_solver::run(int iterations) {\n    for (size_t i = 0; i &lt; iterations; ++i) {\n        setup_starting_point(i);\n        iteration();\n    }\n    ax_-&gt;draw();\n    ax_-&gt;parent()-&gt;save(\"eurotrip.svg\");\n}\n</code></pre> <p>The function <code>setup_starting_point</code> creates an initial tour with a greedy algorithm that uses the current iteration as seed for its starting point. This is meant to generate a different starting point for each iteration. The <code>iteration</code> function runs a local search algorithm on that starting point. It visits all neighbors of <code>curr_tour_</code> and stores any neighbors that happen to be better than <code>best_tour_</code>. Whenever we find a better solution, the <code>iteration</code> function calls the <code>draw</code> function:</p> <pre><code>void eurotrip_solver::iteration() {\n    bool improvement = true;\n    while (improvement) {\n        improvement = false;\n        for (const auto&amp; neighbor: get_neighbors(curr_tour_)) {\n            improvement = update_if_better(neighbor);\n            draw_if_improvement();\n            if (improvement) {\n                break;\n            }\n        }\n    }\n}\n</code></pre> <p>While calling a <code>get_neighbors(curr_tour_)</code> to pre-calculate all neighbors is certainly not an efficient solution, it is an abstraction that serves this example well by abstracting away unnecessary details of the search algorithm. The function <code>update_if_better</code> will update <code>curr_tour_</code> and <code>best_tour_</code> if the <code>neighbor</code> solution happens to be better than any of them.</p> <p>The <code>draw_if_improvement</code> function will only call the <code>draw</code> if there has been some improvement on the best solution. We also use this opportunity to check the last time we called <code>draw</code> and skip the function call if the frame rate happens to be higher than necessary. This is useful in this sort of algorithm to make sure we do not spend more time plotting than searching for solutions.</p> <pre><code>void eurotrip_solver::draw_if_improvement() {\n    static auto last_draw = chrono::high_resolution_clock::now()\n                                           - chrono::seconds(1);\n    static auto min_dist_when_last_draw = min_dist_;\n    const auto current_time = chrono::high_resolution_clock::now();\n    const bool its_been_a_while = current_time - last_draw &gt; chrono::seconds(1);\n    const bool things_are_better = min_dist_ &lt; min_dist_when_last_draw;\n    if (its_been_a_while &amp;&amp; things_are_better) {\n        last_draw = current_time;\n        min_dist_when_last_draw = min_dist_;\n        draw();\n    }\n}\n</code></pre> <p>Finally, the <code>draw</code> function uses our <code>axes_handle</code> to update the figure whenever we find a better solution:</p> <pre><code>void eurotrip_solver::draw() {\n    ax_-&gt;clear();\n    ax_-&gt;geolimits(min(lat_)-5,max(lat_)+5,min(lon_)-2,max(lon_)+10);\n\n    vector&lt;double&gt; sorted_lat;\n    vector&lt;double&gt; sorted_lon;\n    for (const int &amp;idx : best_tour_) {\n        sorted_lat.emplace_back(lat_[idx]);\n        sorted_lon.emplace_back(lon_[idx]);\n    }\n    sorted_lat.emplace_back(lat_[best_tour_[0]]);\n    sorted_lon.emplace_back(lon_[best_tour_[0]]);\n    ax_-&gt;geoplot(sorted_lat, sorted_lon);\n\n    ax_-&gt;hold(true);\n    ax_-&gt;geoscatter(lat_,lon_);\n\n    auto [lon_c,lat_c,names_c] = clear_overlapping_labels(lon_,lat_,names_,1,1);\n    ax_-&gt;text(lon_c,lat_c,names_c);\n\n    ax_-&gt;title(\"Tour distance \" + num2str(min_dist_));\n\n    ax_-&gt;draw();\n}\n</code></pre> <p>Because we are moving the handles around, we use the object-oriented coding style. The <code>geolimits</code> function will adjust the map limits around Europe. The <code>draw</code> function will then create a line going through the cities according to the order indicated by the current best tour. The <code>geoscatter</code> function does not need the cities to be in order because it plots no lines. The <code>text</code> function creates an annotation on top of the map with the city names. The function <code>clear_overlapping_labels</code> is an auxiliary function to remove overlapping labels from the map. The <code>title</code> function creates a title with the current distance.</p> <p>Because the figure is in quiet mode, we need to call the <code>draw</code> function. In this case, the quiet mode avoided rendering the figure five times with unnecessary intermediary plots. Besides interactively showing intermediary results during the algorithm execution, the <code>run</code> function also saves the figure to a vector graphics, that is appropriate for printing the results at any size. The <code>save</code> function will temporarily and transparently change the <code>figure</code> backend to a non-interactive backend for Scalable Vector Graphics (SVG) and draw the figure to an output file. The following Figure shows the final image.</p> <p></p>"},{"location":"white-paper/#applications-managing-plot-handles","title":"Applications Managing Plot Handles","text":"<p>Notice in the previous example that we only keep a handle for the <code>axes</code> object in our application. Every time we call the <code>draw()</code> function, we clear the <code>axes</code> object and recreate its plots. For instance, this algorithm is recalculating the same <code>geolimits</code> every time we update the plot.</p> <p>In this Section, we examine a more high-level use case where we cache handles to the <code>axes</code> object and its plots to update the figure more efficiently. Whenever we find a better solution, we only update the plots instead of recreating them on the <code>axes</code> object. To differentiate the example, we consider the Americas for this example</p> <pre><code>vector&lt;string&gt; names = {\"Marigot\",\"The Valley\",\"Saint John's\"/*,...*/};\nvector&lt;double&gt; lat = {18.0731,18.2166,17.1166/*,...*/};\nvector&lt;double&gt; lon = {-63.0822,-63.0500,-61.8500/*,...*/};\n</code></pre> <p>The <code>americas_trip_solver</code> now has two extra-members in its interface:</p> <pre><code>class americas_trip_solver {\n// ...\nprivate:\n    void setup_axes();\n// ...\n    line_handle lh_;\n};\n</code></pre> <p>The extra handle to the line plot inside the <code>axes</code> object allows us to only modify the data in that plot instead of recreating all the plots. The code that was previously in <code>draw</code> will now be split between <code>draw</code> and <code>setup_axes</code>. We plot almost everything in the <code>setup_axes</code> function:</p> <pre><code>void americas_trip_solver::setup_axes() {\n    ax_-&gt;clear();\n    ax_-&gt;geolimits(min(lat_)-5,max(lat_)+5,min(lon_)-30,max(lon_)+50);\n    lh_ = ax_-&gt;geoplot(lat_, lon_);\n    ax_-&gt;hold(true);\n    ax_-&gt;geoscatter(lat_,lon_);\n    auto [lon_c,lat_c,names_c] = clear_overlapping_labels(lon_,lat_,names_,2,2);\n    ax_-&gt;text(lon_c,lat_c,names_c);\n    ax_-&gt;draw();\n}\n</code></pre> <p>Notice that we do not need to recreate the map, the scatter points, or the text annotation when drawing the plot. When plotting the route, we keep a handle to the <code>line</code> object in <code>lh_</code>. This is the only element we need to update when drawing the plot with a new route. Thus, the <code>draw</code> function is simplified to</p> <pre><code>void americas_trip_solver::draw() {\n    vector&lt;double&gt; sorted_lat;\n    vector&lt;double&gt; sorted_lon;\n    for (const int &amp;idx : best_tour_) {\n        sorted_lat.emplace_back(lat_[idx]);\n        sorted_lon.emplace_back(lon_[idx]);\n    }\n    sorted_lat.emplace_back(lat_[best_tour_[0]]);\n    sorted_lon.emplace_back(lon_[best_tour_[0]]);\n    lh_-&gt;x_data(sorted_lon);\n    lh_-&gt;y_data(sorted_lat);\n    ax_-&gt;title(\"Tour distance \" + num2str(min_dist_));\n    ax_-&gt;draw();\n}\n</code></pre> <p>The function is only responsible for creating a different line with the current route and updating the title. This significantly simplifies the process of refreshing the figure. All other <code>axes</code> children stay as they are. The rest of the <code>americas_trip_solver</code> class remains the same as <code>eurotrip_solver</code>. The following Figure displays the final image for this example.</p> <p></p> <p>With the examples from Section Plot Categories, the example from Section minimal_application and this Section should demonstrate how Matplot++ can work at various levels of complexity and abstraction. Section minimal_application exemplified Matplot++ as a solution for users who want to create simple plots for experiments, while this Section exemplifies a more complex application that requires more efficient interactive plots. Although more complicated, the library architecture also allows tighter integration with GUIs with the development of backends that are specific to the domain of a GUI library.</p>"},{"location":"white-paper/#exporting-figures","title":"Exporting Figures","text":"<p>Some previous examples involved the <code>save</code> function. There are two ways to save figures: manually and programmatically. The interactive plot window has a widget to save the current figure. Because this widget uses the same backend as the one used to produce the interactive image, the final image matches closely what the user sees in the window.</p> <p>The user can also programatically save the figure in a number of formats with the <code>save</code> function:</p> <pre><code>save(filename);\n</code></pre> <p>or</p> <pre><code>save(filename, fileformat);\n</code></pre> <p>The first option infers the appropriate file format from the filename extension. In both cases, this function temporarily changes the backend to a non-interactive backend appropriate to draw the figure. A different backend is used for each format and, depending on the format, the final image does not necessarily match what is on the interactive plot window. The reason is that some file formats purposefully do not include the same features.</p> <p>For instance, consider the bar chart generated by</p> <pre><code>vector&lt;double&gt; x = {29, 17, 14, 13, 12, 4, 11};\nbar(x);\n</code></pre> <p>If we export the image with</p> <pre><code>save(\"barchart.svg\");\n</code></pre> <p>we get the vector graphics </p> <p></p> <p>Exporting the image with</p> <pre><code>save(\"barchart.txt\");\n</code></pre> <p>generates a representation of the image appropriate for text or markdown files, such as</p> <pre><code>       30 +-----------------------------------------------------------+\n          |    *******   +       +      +       +      +       +      |\n          |    *     *                                                |\n       25 |-+  *     *                                              +-|\n          |    *     *                                                |\n          |    *     *                                                |\n       20 |-+  *     *                                              +-|\n          |    *     *                                                |\n          |    *     ********                                         |\n       15 |-+  *     **     *                                       +-|\n          |    *     **     * *******                                 |\n          |    *     **     * *     ******** *******                  |\n          |    *     **     * *     **     * *     *        *******   |\n       10 |-+  *     **     * *     **     * *     *        *     * +-|\n          |    *     **     * *     **     * *     *        *     *   |\n          |    *     **     * *     **     * *     *        *     *   |\n        5 |-+  *     **     * *     **     * *     ******** *     * +-|\n          |    *     **     * *     **     * *     **     * *     *   |\n          |    *  +  **  +  * *  +  **  +  * *  +  **  +  * *  +  *   |\n        0 +-----------------------------------------------------------+\n                  1      2       3      4       5      6       7\n</code></pre> <p>As the last example, saving an image with</p> <pre><code>save(\"barchart.tex\");\n</code></pre> <p>would save the image in a format appropriate to embed in latex documents, such as</p> <p> </p> <p>This exports the image in a format in which the labels are replaced by latex text so that the plot fits the rest of the document.</p>"},{"location":"white-paper/#creating-new-plot-types","title":"Creating new plot types","text":"<p>There are two options for creating new plot styles: concatenating the existing plotting styles or creating a class that inherits from <code>axes object</code>. The first is probably enough for most cases because there are already many primitives that can form new plot types. In fact, most plot types discussed in Section Plot Categories are combinations of <code>axes object</code> subcategories rather than different primitives.</p> <p>Creating a new class that inherits from <code>axes object</code> is only necessary if we are working on a new plot category that needs to manage its own pre-processed data, like networks, contours, and histograms. Note that, if it were not for the algorithms involved in these types of plots, we could comfortably replace networks, contours, and histograms by a combination of scatter plots, line plots, filled polygons, and bar plots.</p> <p>To create a new class inheriting from <code>axes object</code>, the user needs to override several virtual functions. Although the exact function types might slightly change between library versions, these functions should return the object boundaries in each axis (so that the <code>axes</code> object knows how to adjust automatic <code>axis</code> objects); return the valid object coordinates (two-dimensional, three-dimensional, or polar); consume labels from the <code>legend</code> object; and return an optional tag that describes the plot category.</p>"},{"location":"white-paper/#backends","title":"Backends","text":"<p>The repository includes a directory for complete backends and backends that exemplify how we can integrate other technologies with Matplot++. As usual in many C++ plotting libraries (Section Alternatives for Data Visualization in C++), this library offers a complete backend that uses pipes to Gnuplot processes as backends. Each Gnuplot output format represents a possible backend in Matplot++. That was also the approach in the early versions of Octave, which now provides an additional backend based on OpenGL. </p> <p>The main advantage of a default Gnuplot backend at this point is that it can work in interactive and non-interactive mode. Its various auxiliary terminals can be used as additional non-interactive backends to export plots to a variety of useful formats that would be impossible otherwise, such as the SVG and latex file formats examined in Section Exporting Data. The second benefit of Gnuplot is that it allows us to abstract away technologies that are specific to each operating system. Without Gnuplot, these features would only be possible through a large number of other backends. For this reason, we currently make this our default backend.</p> <p>Although we use Gnuplot as a default backend, this is transparent to the user and we attempt to limit the internal rendering functions to its most primitive methods, as in the subclasses of <code>axes object</code> described in Section Plot Categories. For instance, the library can independently calculate its contours, interpolations, automatic axis ticks, parallel axes, and histograms without recurring to the backend.</p> <p>This constraint on plotting primitives is intended to make it more straightforward to implement other backends we might need in the future. These new backends could be implemented in a Dear ImGui backend style, where the library is only responsible for creating plots for a rendering engine that has a render loop running on the main thread. The main difference in such an architecture is that Gnuplot expects commands rather than vertices. This is probably the case with other potential backends, such as non-interactive backends for exporting plots to image files.</p> <p>As an example, the repository also includes an instance of a backend implementation that uses OpenGL. The main drawback of Gnuplot as a default backend is that it depends on process pipes. Since a pipe is by definition unidirectional, the constrains some features we could have in interactive plots, such as:</p> <ul> <li>Parameters will come from the <code>figure</code> object and not from the interactive window. This means plots are not as responsive as they could when moving and resizing windows. For this reason, it is always best to programmatically set the window size on the figure object rather than manually changing it, especially when you intend to save the image programmatically.</li> <li>There is no straightforward way to query the exact word positions in Word Clouds (Section Data Distribution). This means the algorithm to generate clouds needs to estimate where the words are. This makes word clouds very sensitive to the backend. When saving a word cloud, it's best to save it non-programmatically.</li> <li>The interactive features of Gnuplot, like rotating three-dimensional plots, do not work well with subplots. </li> <li>Gnuplot pipes impose extra requirements on the backend interface (Section Backend Interface).</li> </ul> <p>The illustrative backends in our repository demonstrate that other backends could make it possible for plots to be more interactive in these regards. For instance, a backend based on OpenGL might offer much more control over interactive plots. However, these backends can have drawbacks that make them less appropriate as a default backend at this point. For instance, in some operating systems, OpenGL can only run on the main thread.</p> <p>One solution to this problem would be to defer plotting to another process. However, this would make the OpenGL backend very similar to the default Gnuplot pipe. The process of sending data to another process could be inefficient or depend on interprocess communication strategies for the operating system that could more complex than the backend.</p> <p>A second alternative to this problem is to create a backend that would always work on a secondary thread. OpenGL would block the main thread with its render loop and Matplot++ would create plots for this main application. In this sense, Matplotlib++ would work like backends for Dear ImGui. Although such a backend could be useful to many applications, that makes is less of a library for accessible data visualization and more like a widget for GUIs. </p> <p>Although most costly in terms of development, a more reliable strategy would be for developers to solve these problems with native backends targeted at specific operating systems. Because this imposes a high development cost, these backends should appear over time, as the demand for each of these backends grows.</p> <p>Note that all this discussion does not even include non-interactive backends. Users might need to handle technologies specific to the operating system, integrate plots into an existing GUI, display their plots on a web page through WebGL, export images for scientific papers, or stream their plots to the console. As discussed in Section Backend Interface, there are too many possibilities and use cases for data visualization, and that is precisely the rationale for the backend interface. What is most important is that the implementation layer is open for more advanced users to adapt the library to their needs.</p>"},{"location":"white-paper/#performance","title":"Performance","text":"<p>We are incrementally improving the code for performance and avoid any counter-productive coding patterns. The axes objects that depend on expensive calculations all use lazy evaluation to avoid calculating data for unnecessary plots. Having said that, Matplot++ concentrates intensively on the design goals described in Section Data Visualization: interactive plotting, high-quality exporting tools, and productivity. The rationale is that, for now, most applications of interest are environments where plotting is inexpensive compared to the processes we are monitoring.</p>"},{"location":"white-paper/#conclusion","title":"Conclusion","text":"<p>The paper presented Matplot++, an alternative for data visualization in C++. Aiming at scientific computing, the design goals of Matplot++ are interactive plotting, high-quality exporting tools, and simplicity. The library allows users to create sophisticated plots with a compact syntax. This enables programmers to monitor metrics and scientists to create high-quality figures for publications. Current work includes continuous performance gains, further specialized backends for multiple operating systems, and increasing support for more types of backends in the present plot categories.</p>"},{"location":"white-paper/#references","title":"References","text":"<ul> <li> <p>Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, Devin M, Ghemawat S, Irving G,Isard M,et al.(2016). \"Tensorflow: A system for large-scale machine learning.\" In 12th USENIX symposium on operating systems design and implementation (OSDI 16), pp.265-283.</p> </li> <li> <p>Angerson E, Bai Z, Dongarra J, Greenbaum A, McKenney A, Du Croz J, Hammarling S,Demmel J, Bischof C, Sorensen D (1990). \"LAPACK: A portable linear algebra library for high-performance computers.\" In Supercomputing'90: Proceedings of the 1990 ACM/IEEE Conference on Supercomputing, pp. 2-11. IEEE.</p> </li> <li> <p>Antcheva I, Ballintijn M, Bellenot B, Biskup M, Brun R, Buncic N, Canal P, Casadei D, CouetO, Fine V, et al.(2011). \"ROOT-A C++ framework for petabyte data storage, statistical analysis and visualization.\"Computer Physics Communications,182(6), 1384-1385.</p> </li> <li> <p>Baratov R (2019). Hunter. URL: https://hunter.readthedocs.io.</p> </li> <li> <p>Barrett P, Hunter J, Miller JT, Hsu JC, Greenfield P (2005). \"matplotlib-A Portable Python Plotting Package.\" In Astronomical data analysis software and systems XIV, volume 347,p. 91.</p> </li> <li> <p>Bezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing. \"SIAM review,59(1), 65-98.</p> </li> <li> <p>CEGUI Team (2020). CEGUI. URL: http://cegui.org.uk.</p> </li> <li> <p>Cornut O (2020). Dear ImGui: Bloat-free Immediate Mode Graphical User Interface for C++ with minimal dependencies. URL: https://github.com/ocornut/imgui.</p> </li> <li> <p>de Guzman J (2020). Elements. URL: http://cycfi.github.io/elements/.</p> </li> <li> <p>Eichhammer E (2020). QCustomPlot. URL: https://www.qcustomplot.com.</p> </li> <li> <p>Evers B (2019). Matplotlib-cpp. URL: https://github.com/lava/matplotlib-cpp.</p> </li> <li> <p>Freitas A (2020). Pareto Front Library.   URL: https://github.com/alandefreitas/pareto-front.</p> </li> <li> <p>Frigo M, Johnson SG (1998). \"FFTW: An adaptive software architecture for the FFT.\" In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP'98 (Cat. No. 98CH36181), volume 3, pp. 1381-1384. IEEE.</p> </li> <li> <p>Fruchterman TM, Reingold EM (1991). \"Graph drawing by force-directed placement. \"Software: Practice and experience, 21(11), 1129-1164.</p> </li> <li> <p>GNU Project (2020). GNU Octave: Introduction to Plotting. URL: https://octave.org/doc/v4.2.2/Introduction-to-Plotting.html.</p> </li> <li> <p>Guy Eric Schalnat Andreas Dilger GRP (2020). Libpng. URL: https://sourceforge.net/p/libpng/.</p> </li> <li> <p>Hao J (2020). Nana. URL: http://nanapro.org/.</p> </li> <li> <p>Hunter JD (2007).  \"Matplotlib: A 2D graphics environment. \"Computing in Science &amp; Engineering, 9(3), 90-95. doi:10.1109/MCSE.2007.55.</p> </li> <li> <p>Idea4good (2020). GuiLite. URL: https://github.com/idea4good/GuiLite.</p> </li> <li> <p>ImageMagick Studio LLC (2020). Magick++. URL: https://imagemagick.org/Magick++/.</p> </li> <li> <p>Independent JPEG Group (2020). Libjpeg. URL: http://libjpeg.sourceforge.net.</p> </li> <li> <p>Intel Corporation, Willow Garage I (2020). Open Source Computer Vision Library (OpenCV). URL: https://opencv.org/.</p> </li> <li> <p>Jakob W (2017). PyBind11. URL: https://pybind11.readthedocs.io/en/stable/.</p> </li> <li> <p>Kagstrom B LP, C VL (2020). Basic Linear Algebra Subprograms (BLAS).  URL: http://www.netlib.org/blas/.</p> </li> <li> <p>Kainz F, Bogart R, Hess D (2003). \"The OpenEXR image file format.\"SIGGRAPH TechnicalSketches.</p> </li> <li> <p>Kamada T, Kawai S,et al.(1989). \"An algorithm for drawing general undirected graphs.\"Information processing letters,31(1), 7-15.</p> </li> <li> <p>Loup Gailly J, Adler M (2020). Zlib. URL: https://github.com/madler/zlib.</p> </li> <li> <p>Martin K, Hoffman B (2010). Mastering CMake: a cross-platform build system. Kitware.</p> </li> <li> <p>McKinney W,et al.(2011). \"Pandas: a foundational Python library for data analysis and statistics. \"Python for High Performance and Scientific Computing, 14(9).</p> </li> <li> <p>Conan.io (2020). Conan. URL: https://conan.io.</p> </li> <li> <p>Melchior L (2020). CPM.cmake. URL: https://github.com/TheLartians/CPM.cmake.</p> </li> <li> <p>Murray Cumming DE (2020). Gtkmm. URL: https://www.gtkmm.org/.</p> </li> <li> <p>Natural Earth (2018). \"Natural earth. Free vector and raster map data.\" URL: http://www.naturalearthdata.com/downloads/.</p> </li> <li> <p>NetworkX developers (2020). NetworkX. URL: https://networkx.github.io.</p> </li> <li> <p>Olivier Birot (2020). nodesoup. URL: https://github.com/olvb/nodesoup.</p> </li> <li> <p>Pezent E (2020). ImPlot. URL: https://github.com/epezent/implot.</p> </li> <li> <p>Sam Leffler SG (2020). Libtiff. URL: https://gitlab.com/libtiff/libtiff.</p> </li> <li> <p>Schaling B (2011). The boost C++ libraries. Boris Schaling.</p> </li> <li> <p>Spitzak B, et al.(2004). \"Fast Light Toolkit (FLTK).\" FTLK: Fast light toolkit. Available: http://www.fltk.org/</p> </li> <li> <p>Stahlke D (2020). Gnuplot-Iostream. URL: http://stahlke.org/dan/gnuplot-iostream/.</p> </li> <li> <p>Storer J (2020). JUCE. URL: https://juce.com.</p> </li> <li> <p>Terra Informatica Software, Inc (2020). Sciter. URL: https://sciter.com.</p> </li> <li> <p>The FLTK Team (2020). FLTK. URL: https://www.fltk.org.</p> </li> <li> <p>The MathWorks, Inc (2020). MatlabGraphics. URL: https://www.mathworks.com/help/matlab/graphics.html.</p> </li> <li> <p>The Qt Company (2020). Qt. URL: https://www.qt.io.</p> </li> <li> <p>Tschumperle D (2020). CImg. URL: http://cimg.eu.</p> </li> <li> <p>van der Zijp J (2020). Fox toolkit. URL: http://fox-toolkit.org.</p> </li> <li> <p>Vasilev V, Canal P, Naumann A, Russo P (2012). \"Cling-the new interactive interpreter for root 6.\" In Journal of Physics: Conference Series, volume 396, p. 052071.</p> </li> <li> <p>Walt Svd, Colbert SC, Varoquaux G (2011). \"The NumPy array: a structure for efficient numerical computation.\" Computing in science &amp; engineering,13(2), 22-30.</p> </li> <li> <p>Wei V (2020). MiniGUI. URL: http://www.minigui.com.</p> </li> <li> <p>Williams T, Kelley C, Bersch C, Broker HB, Campbell J, Cunningham R, Denholm D, Elber G, Fearick R, Grammes C,et al.(2017). \"gnuplot 5.2.\"</p> </li> <li> <p>wxWidgets (2020). WxWidgets. URL: https://wxwidgets.org.</p> </li> <li> <p>XOrg Foundation (2020). X11. URL: https://www.x.org/.</p> </li> <li> <p>Zaitsev S (2020). Webview. URL: https://github.com/zserge/webview.</p> </li> <li> <p>Zakai A (2011). \"Emscripten: an LLVM-to-JavaScript compiler.\" In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion, pp. 301-312.</p> </li> </ul>"},{"location":"annotations/arrow/","title":"Arrow","text":"<pre><code>arrow(x1, y1, x2, y2);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    auto a = arrow(2.5, 6.5, 5, 5);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    auto a = arrow(2.5, 6.5, 5, 5);\n    a-&gt;color(\"blue\");\n    a-&gt;line_width(4);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"annotations/ellipse/","title":"Ellipse","text":"<pre><code>ellipse(x, y, w, h);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(-4, 4);\n    auto y = transform(x, [](double x) { return pow(x, 3) - 12 * x; });\n    plot(x, y);\n\n    auto e = ellipse(-3.5, 11, 3.5, 8);\n    auto r = rectangle(-3.5, 11, 3.5, 8);\n    r-&gt;color(\"red\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"annotations/filled-polygon/","title":"Filled Polygon","text":"<pre><code>polygon(x0, y0, color);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_1d t = iota(1. / 16, 1. / 8, 1);\n    t = transform(t, [](double t) { return t * 2. * pi; });\n    vector_1d x = transform(t, [](double t) { return cos(t); });\n    vector_1d y = transform(t, [](double t) { return sin(t); });\n    std::string color = \"r\";\n    matplot::fill(x, y, color);\n    axis(equal);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"annotations/line/","title":"Line","text":"<pre><code>line(x1, y1, x2, y2);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n\n    line(3, 3, 3, 4);\n    arrow(3, 4, 4, 4);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"annotations/rectangle/","title":"Rectangle","text":"<pre><code>rectangle(x, y, w, h);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_1d data = {2, 4, 6, 7, 8, 7, 5, 2};\n    stem(data);\n\n    auto r1 = rectangle(2.5, 5.5, 2, 2);\n    r1-&gt;color(\"red\");\n\n    auto r2 = rectangle(6.5, 4.5, 1, 1);\n    r2-&gt;fill(true);\n    r2-&gt;color({0.8f, 0.f, 0.f, 1.f});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    rectangle(0, 0, 2, 4, 0);\n    rectangle(3, 0, 2, 4, 1);\n    rectangle(6, 0, 2, 4, 0.5);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    rectangle(2, 4, 2, 2, 1.);\n    auto r2 = rectangle(2, 4, 2, 2, 0.);\n    r2-&gt;color(\"red\");\n    axis(equal);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r = rectangle(1, 2, 5, 10);\n    r-&gt;fill(true);\n    r-&gt;color({0, .5, .5});\n    r-&gt;line_width(3);\n\n    auto r2 = rectangle(1, 2, 5, 10);\n    r2-&gt;color(\"blue\");\n    r2-&gt;line_width(3);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    using namespace std;\n\n    vector&lt;double&gt; x = {0, 8, 8, 0};\n    vector&lt;double&gt; y = {0, 0, 4, 4};\n    polygon(x, y, \"g\");\n    rectangle(0, 0, 2, 4, 0)-&gt;fill(true).color(\"red\");\n    rectangle(3, 0, 2, 4, 1)-&gt;fill(true).color(\"magenta\");\n    rectangle(6, 0, 2, 4, 0.5)-&gt;fill(true).color(\"yellow\");\n    text(2, 2, \"Curvature 0\")-&gt;alignment(labels::alignment::right);\n    text(4, 2, \"Curvature 1\")-&gt;alignment(labels::alignment::center);\n    text(6, 2, \"Curvature 0.5\")-&gt;alignment(labels::alignment::left);\n    arrow(4, 2.2, 3, 3);\n    textarrow(6, 1, 8, 0, \"Last corner\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>The rectangle object can have a border curvature from  to . We can also annotate with text, arrows, polygons, and lines.</p>"},{"location":"annotations/text-with-arrow/","title":"Text with Arrow","text":"<pre><code>textarrow(x1, y1, x2, y2, str);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    auto [t, a] = textarrow(2.5, 6.5, 5, 5, \"y=x\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    auto [t, a] = textarrow(2.5, 6.5, 5, 5, \"y=x\");\n    t-&gt;color(\"red\").font_size(14);\n    a-&gt;color(\"blue\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"annotations/text/","title":"Text","text":"<p>The annotations category is meant to create individual objects on the plot rather than representations of data sets. An important difference between the annotations category and other categories is that, by default, the annotations do not replace the plot that already exists in the <code>axes</code> object, even if the user does not call the <code>hold</code> function.</p> <pre><code>text(x0, y0, str);\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, pi / 20, 2 * pi);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return sin(x); });\n    plot(x, y);\n    text(pi, 0, \"\u2190 sin(\u03c0)\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-5, +5);\n    std::vector&lt;double&gt; y =\n        transform(x, [](auto x) { return pow(x, 3) - 12 * x; });\n    plot(x, y);\n\n    std::vector&lt;double&gt; xt = {-2, +2};\n    std::vector&lt;double&gt; yt = {16, -16};\n    std::string str = \"dy/dx = 0\";\n    text(xt, yt, str);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-5, +5);\n    std::vector&lt;double&gt; y =\n        transform(x, [](auto x) { return pow(x, 3) - 12 * x; });\n    plot(x, y);\n\n    std::vector&lt;double&gt; xt = {-2, +2};\n    std::vector&lt;double&gt; yt = {16, -16};\n    std::vector&lt;std::string&gt; str = {\"local max\", \"local min\"};\n    text(xt, yt, str);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    text(2, 7, \"A simple plot\\\\nfrom 1 to 10\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    text({2, 8}, {7, 7},\n         std::vector&lt;std::string&gt;({\"A simple plot\\\\nfrom 1 to 10\", \"y=x\"}));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    auto t = text(2, 8, \"A simple plot\")-&gt;color(\"red\").font_size(14);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(-5, +5);\n    auto y = transform(x, [](double x) { return pow(x, 3) - 12 * x; });\n    plot(x, y);\n    auto t = text({-2, 2}, {16, -16}, \"dy/dx=0\");\n    t-&gt;colors({.0, 1.});\n    t-&gt;sizes({14, 10});\n    gca()-&gt;colormap({{1, 0, 0}, {0, 0, 0}});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto y = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(y);\n\n    text(3, 90, \"\u03bb_{12}^{3/2}/\u03c0 - \u03c0\u0394^{2/3}\");\n    text(4, 60, \"lambda12^{3/2}/pi - pi delta^{2/3}\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"annotations/textbox/","title":"Textbox","text":"<pre><code>textbox(x, y, w, h, str);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    textbox(2, 8, 4, 0.5, \"String line from 1 to 10\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/axes-object/","title":"Axes Object","text":"<pre><code>auto ax1 = gca();\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto ax1 = gca();\n    axis({-100, +100, -30, +30});\n    fplot(ax1, \"3*cos(3*x) + tan(x)\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n    auto ax1 = axes({0.1f, 0.1f, 0.7f, 0.7f});\n    auto ax2 = axes({0.65f, 0.65f, 0.28f, 0.28f});\n\n    auto [X, Y, Z] = peaks(20);\n    contour(ax1, X, Y, Z);\n    colorbar(ax1, off);\n    surf(ax2, X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n    auto ax1 = axes({0.1f, 0.1f, 0.6f, 0.6f});\n    auto ax2 = axes({0.35f, 0.35f, 0.6f, 0.6f});\n\n    ax1-&gt;box(true);\n    ax2-&gt;box(true);\n\n    axes(ax1);\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/clear-axes/","title":"Clear Axes","text":"<pre><code>cla();\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 2 * pi);\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    plot(x, y1);\n\n    hold(on);\n    auto y2 = transform(x, [](double x) { return sin(2 * x); });\n    plot(x, y2);\n\n    cla();\n\n    auto y3 = transform(x, [](double x) { return sin(3 * x); });\n    plot(x, y3);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n\n    auto ax2 = nexttile();\n    contour(x, y, z);\n\n    cla(ax1);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 2 * pi);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    axis({0, 5, -2, 2});\n    cla();\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/figure-object/","title":"Figure Object","text":"<pre><code>figure();\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto h = figure();\n    auto ax = h-&gt;current_axes();\n    fplot(ax, \"cos(x)\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto h = figure(true);\n    h-&gt;name(\"Measured Data\");\n    h-&gt;number_title(false);\n    h-&gt;color(\"green\");\n    h-&gt;position({0, 0, 600, 600});\n    h-&gt;size(500, 500);\n    h-&gt;draw();\n    h-&gt;font(\"Arial\");\n    h-&gt;font_size(40);\n    h-&gt;title(\"My experiment\");\n\n    constexpr float pi_f = 3.14f;\n    axis({-pi_f, pi_f, -1.5f, +1.5f});\n    fplot(\"cos(x)\");\n    h-&gt;draw();\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f1 = figure();\n    auto f2 = figure();\n    plot(vector_1d{1., 2., 3.}, vector_1d{2., 4., 6.});\n\n    figure(f1);\n    scatter(iota(1, 20), rand(20, 0, 1));\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/line-specs/","title":"Line Specs","text":"<pre><code>fplot(fn, spec_str);\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot(\"sin(x)\", \"-.r*\");\n    hold(on);\n    fplot(\"sin(x-pi/2)\", \"--mo\");\n    fplot(\"sin(x-pi)\", \":bs\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/axis/adjust-axis/","title":"Adjust Axis","text":"<pre><code>axis({xmin, xmax, ymin, ymax});\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot(\"sin(x)\", \"-o\");\n    axis({0, 2 * pi, -1.15, 1.5});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot(\"sin(4*x)/exp(0.1*x)\");\n    axis({-10, +10, 0, inf});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    fplot(ax1, \"sin(x)\");\n\n    auto ax2 = nexttile();\n    fplot(ax2, \"x &lt; 5 ? sin(x) : -1\");\n\n    axis({ax1, ax2}, {0, 10, -1, 1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    axis(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    axis(tight);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto c = eye(10);\n    pcolor(c);\n    colormap(palette::summer());\n    axis(ij);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    auto y2 = transform(x, [](double x) { return 2 * sin(x); });\n    hold(on);\n    axis(manual);\n    axis({0, 10, -1, +1});\n    plot(x, y2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    auto y2 = transform(x, [](double x) { return 2 * sin(x); });\n    hold(on);\n    axis(manual);\n    axis({0, 10, -1, +1});\n    plot(x, y2);\n    hold(off);\n\n    axis(automatic);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/axis/box/","title":"Box","text":"<pre><code>box(on);\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    box(off);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    box(on);\n\n    auto ax = gca();\n    ax-&gt;box_full(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, iota(1, 10));\n\n    auto ax2 = nexttile();\n    plot(ax2, iota(1, 10));\n    box(ax2, off);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/axis/x-limits/","title":"X Limits","text":"<pre><code>xlim({xmin,xmax});\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    xlim({0, 5});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    xlim({0, inf});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto x = linspace(0, 5, 1000);\n    auto y = transform(x, [](double x) { return sin(100 * x) / exp(x); });\n\n    auto ax1 = nexttile();\n    plot(ax1, x, y);\n\n    auto ax2 = nexttile();\n    plot(ax2, x, y);\n    xlim(ax2, {0, 1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    xlim(manual);\n    xlim({0, 10});\n    hold(on);\n    auto x2 = transform(x, [](double x) { return 2 * x; });\n    auto y2 = transform(y, [](double y) { return 2 * y; });\n    plot(x2, y2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    xlim(manual);\n    xlim({0, 10});\n    hold(on);\n    auto x2 = transform(x, [](double x) { return 2 * x; });\n    auto y2 = transform(y, [](double y) { return 2 * y; });\n    plot(x2, y2);\n    hold(off);\n    xlim(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto x = randn(50, 0, 1);\n    auto y = randn(50, 0, 1);\n    scatter(x, y);\n\n    auto xl = xlim();\n    std::cout &lt;&lt; \"xl[0]: \" &lt;&lt; xl[0] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"xl[1]: \" &lt;&lt; xl[1] &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/axis/y-limits/","title":"Y Limits","text":"<pre><code>ylim({ymin,ymax});\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    ylim({-2, +2});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    ylim({0, inf});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto x = linspace(0, 10, 1000);\n    auto y = transform(x, [](double x) { return sin(10 * x) * exp(.5 * x); });\n\n    auto ax1 = nexttile();\n    plot(ax1, x, y);\n\n    auto ax2 = nexttile();\n    plot(ax2, x, y);\n    ylim(ax2, {-10, 10});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    ylim(manual);\n    ylim({-1, +1});\n    hold(on);\n    auto y2 = transform(x, [](double x) { return 2 * sin(x); });\n    plot(x, y2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n\n    ylim(manual);\n    ylim({-1, +1});\n    hold(on);\n    auto y2 = transform(x, [](double x) { return 2 * sin(x); });\n    plot(x, y2);\n    hold(off);\n\n    ylim(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto x = randn(50, 0, 1);\n    auto y = randn(50, 0, 1);\n    scatter(x, y);\n\n    auto yl = ylim();\n    std::cout &lt;&lt; \"yl[0]: \" &lt;&lt; yl[0] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"yl[1]: \" &lt;&lt; yl[1] &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/axis/z-limits/","title":"Z Limits","text":"<pre><code>zlim({zmin,zmax});\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    zlim({-5, 5});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    mesh(X, Y, Z);\n    zlim({0, inf});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    surf(ax1, X, Y, Z);\n\n    auto ax2 = nexttile();\n    surf(ax2, X, Y, Z);\n    zlim(ax2, {-5, 5});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto theta = linspace(0, 2 * pi);\n    auto x = transform(theta, [](double theta) { return cos(theta); });\n    auto y = transform(theta, [](double theta) { return sin(theta); });\n    auto z = theta;\n    scatter3(x, y, z);\n\n    zlim(manual);\n    zlim({0, 2 * pi});\n    hold(on);\n    auto z2 = transform(theta, [](double theta) { return 5 * theta; });\n    scatter3(x, y, z2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto theta = linspace(0, 2 * pi);\n    auto x = transform(theta, [](double theta) { return cos(theta); });\n    auto y = transform(theta, [](double theta) { return sin(theta); });\n    auto z = theta;\n    scatter3(x, y, z);\n\n    zlim(manual);\n    zlim({0, 2 * pi});\n    hold(on);\n    auto z2 = transform(theta, [](double theta) { return 5 * theta; });\n    scatter3(x, y, z2);\n    hold(off);\n\n    zlim(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto x = randn(50, 0, 1);\n    auto y = randn(50, 0, 1);\n    auto z = randn(50, 0, 1);\n    scatter3(x, y, z);\n\n    auto zl = zlim();\n    std::cout &lt;&lt; \"zl[0]: \" &lt;&lt; zl[0] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"zl[1]: \" &lt;&lt; zl[1] &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/camera/lighting/","title":"Lighting","text":"<pre><code>surf(x, y, z)-&gt;lighting(true);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z)-&gt;lighting(true);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z)-&gt;lighting(true).primary(0.2f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z)-&gt;lighting(true).primary(0.8f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z)-&gt;lighting(true).specular(0.2f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z)-&gt;lighting(true).specular(0.8f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n\n    subplot(3, 3, 0);\n    surf(x, y, z)-&gt;lighting(true).primary(0.0).specular(0.0);\n\n    subplot(3, 3, 1);\n    surf(x, y, z)-&gt;lighting(true).primary(0.5).specular(0.0);\n\n    subplot(3, 3, 2);\n    surf(x, y, z)-&gt;lighting(true).primary(1.0).specular(0.0);\n\n    subplot(3, 3, 3);\n    surf(x, y, z)-&gt;lighting(true).primary(0.0).specular(0.5);\n\n    subplot(3, 3, 4);\n    surf(x, y, z)-&gt;lighting(true).primary(0.5).specular(0.5);\n\n    subplot(3, 3, 5);\n    surf(x, y, z)-&gt;lighting(true).primary(1.0).specular(0.5);\n\n    subplot(3, 3, 6);\n    surf(x, y, z)-&gt;lighting(true).primary(0.0).specular(1.0);\n\n    subplot(3, 3, 7);\n    surf(x, y, z)-&gt;lighting(true).primary(0.5).specular(1.0);\n\n    subplot(3, 3, 8);\n    surf(x, y, z)-&gt;lighting(true).primary(1.0).specular(1.0);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/camera/view/","title":"View","text":"<pre><code>view(az, el);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    xlabel(\"x\");\n    ylabel(\"y\");\n    zlabel(\"z\");\n    view(90, 0);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    xlabel(\"x\");\n    ylabel(\"y\");\n    zlabel(\"z\");\n    view(2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y] = meshgrid(iota(-5, .5, 5));\n    auto z = transform(\n        x, y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    surf(x, y, z);\n    xlabel(\"x\");\n    ylabel(\"y\");\n    zlabel(\"z\");\n\n    auto [az, el] = view();\n    std::cout &lt;&lt; \"az: \" &lt;&lt; az &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"el: \" &lt;&lt; el &lt;&lt; std::endl;\n\n    auto [naz, nel] = view(-5, -2, 5);\n    std::cout &lt;&lt; \"naz: \" &lt;&lt; naz &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"nel: \" &lt;&lt; nel &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto t = iota(0, pi / 20, 10 * pi);\n    auto xt1 = transform(t, [](double t) { return sin(t); });\n    auto yt1 = transform(t, [](double t) { return cos(t); });\n    tiledlayout(1, 2);\n\n    auto ax1 = nexttile();\n    plot3(ax1, xt1, yt1, t);\n    xlabel(\"x\");\n    ylabel(\"y\");\n    zlabel(\"z\");\n\n    auto ax2 = nexttile();\n    plot3(ax2, xt1, yt1, t);\n    xlabel(\"x\");\n    ylabel(\"y\");\n    zlabel(\"z\");\n    view(ax2, 90, 0);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks(20);\n    auto s = surf(x, y, z);\n    xlabel(\"x-axis\");\n    ylabel(\"y-axis\");\n    zlabel(\"z-axis\");\n\n    rotate(20, 30);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto ackley = [](double x, double y) {\n        return -20 * exp(-0.2 * sqrt(0.5 * (pow(x, 2) + pow(y, 2)))) -\n               exp(0.5 * (cos(2 * pi * x) + cos(2 * pi * y))) + exp(1) + 20;\n    };\n\n    gcf()-&gt;width(gcf()-&gt;width() * 2);\n    subplot(1, 2, 0);\n    fsurf(ackley)-&gt;lighting(true).primary(0.7f).specular(0.9f);\n    subplot(1, 2, 1);\n    fsurf(ackley);\n    rotate(20, 30);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/colormaps/color-bar/","title":"Color Bar","text":"<pre><code>colorbar();\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    contourf(x, y, z, 20);\n    gca()-&gt;cb_position({0.f, 0.f, 1.f, 0.06f});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colorbar().reverse(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    tiledlayout(2, 1);\n\n    nexttile();\n    surf(x, y, z);\n    colorbar();\n\n    nexttile();\n    mesh(x, y, z);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    contourf(x, y, z);\n    colorbar()\n        .limits({-6, 8})\n        .tick_values({-5, -2, 1, 4, 7})\n        .ticklabels({\"Cold\", \"Cool\", \"Neutral\", \"Warm\", \"Hot\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; map = {{0, 0, 0.3}, {0, 0, 0.4},\n                                            {0, 0, 0.5}, {0, 0, 0.6},\n                                            {0, 0, 0.8}, {0, 0, 1}};\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colorbar().label(\"Elevation (ft in 1000s)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colorbar(on);\n    colorbar(off);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/colormaps/colormap/","title":"Colormap","text":"<p>As a convenience, the <code>colors.h</code> header contains many functions to generate colors from strings and vice-versa.</p> <pre><code>colormap(colors);\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colormap(palette::winter());\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colormap(palette::summer());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colormap(palette::summer());\n    colormap(palette::default_map());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n\n    tiledlayout();\n    auto ax1 = nexttile();\n    surf(x, y, z);\n    colormap(ax1, palette::spring());\n\n    auto ax2 = nexttile();\n    surf(x, y, z);\n    colormap(ax2, palette::winter());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    mesh(x, y, z);\n    colormap(palette::parula(5));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; map = {{0, 0, 0.3}, {0, 0, 0.4},\n                                            {0, 0, 0.5}, {0, 0, 0.6},\n                                            {0, 0, 0.8}, {0, 0, 1}};\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    colormap(map);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    mesh(x, y, z);\n    colormap(palette::autumn(5));\n    auto cmap = colormap();\n    for (const auto &amp;color : cmap) {\n        std::cout &lt;&lt; \"r: \" &lt;&lt; color[0] &lt;&lt; \", g: \" &lt;&lt; color[1]\n                  &lt;&lt; \", b: \" &lt;&lt; color[2] &lt;&lt; std::endl;\n    }\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout();\n    auto ax1 = nexttile();\n    auto [x, y, z] = peaks();\n    contourf(x, y, z);\n    colormap(ax1, palette::hot(8));\n\n    auto ax2 = nexttile();\n    contourf(x, y, z);\n    colormap(ax2, palette::pink());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y] = meshgrid(iota(-5, .5, 5));\n    auto Z = transform(\n        X, Y, [](double X, double Y) { return pow(X, 2) + pow(Y, 2); });\n    surf(X, Y, Z);\n    colorbar();\n    caxis({20, 50});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/colormaps/rgb-plot/","title":"RGB Plot","text":"<pre><code>rgbplot(colors);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    rgbplot(palette::parula());\n    hold(on);\n    colormap(palette::parula());\n    colorbar().tick_values({});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r = iota(0, .1, .9);\n    auto g = transform(r, [](double r) { return pow(r, 1.8); });\n    auto b = transform(r, [](double r) { return pow(r, 2.1); });\n    vector_2d mymap_channels{r, g, b};\n    auto mymap = transpose(mymap_channels);\n\n    rgbplot(mymap);\n    hold(on);\n    colormap(mymap);\n    colorbar().tick_values({});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/grid-background/","title":"Grid Background","text":"<pre><code>grid(on);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    grid(on);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    grid(off);\n    box(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    grid(on);\n    gca()-&gt;minor_grid(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    auto y2 = transform(x, [](double x) { return sin(3 * x); });\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(ax1, x, y1);\n\n    auto ax2 = nexttile();\n    plot(ax2, x, y2);\n    grid(ax2, on);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/x-tick-angle/","title":"X Tick Angle","text":"<pre><code>xtickangle(ang);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10000, 21);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    stem(x, y);\n    xtickangle(45);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, rand(6, 6, 0, 1));\n\n    auto ax2 = nexttile();\n    plot(ax2, rand(6, 6, 0, 1));\n    xtickangle(ax2, 45);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10000, 21);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    stem(x, y);\n\n    std::cout &lt;&lt; \"xtickangle(): \" &lt;&lt; xtickangle() &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/x-tick-format/","title":"X Tick Format","text":"<pre><code>xtickformat(fmtstr);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 20, 100);\n    vector_1d y = {88, 67, 98, 43, 45, 65};\n    bar(x, y);\n    xtickformat(\"usd\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 20, 100);\n    vector_1d y = {88, 67, 98, 43, 45, 65};\n    bar(x, y);\n    xtickformat(\"usd\");\n    std::cout &lt;&lt; \"xtickformat(): \" &lt;&lt; xtickformat() &lt;&lt; std::endl;\n    xtickformat(\"$%.0f\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 10);\n    vector_1d y = {.17, .25, .27, .28, .3, .32, .33, .34, .345, .35};\n    plot(x, y, \"-v\");\n    xtickformat(\"%g GHz\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 1, 100);\n    vector_1d y = transform(x, randn(100, 0., 1.),\n                            [](double x, double r) { return r * cos(x); });\n    scatter(x, y);\n    xtickformat(\"%.2f\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, rand(6, 6, 0, 1));\n\n    auto ax2 = nexttile();\n    plot(ax2, rand(6, 6, 0, 1));\n\n    xtickformat(ax2, \"usd\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/x-tick-labels/","title":"X Tick Labels","text":"<pre><code>xticklabels(xstrs);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    auto ax2 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    xticks({1, 2, 3});\n    xticklabels({\"one\", \"two\", \"three\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    stem(iota(1, 10));\n    xticks({1, 4, 6, 10});\n    xticklabels({\"A\", \"B\", \"C\", \"D\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    stem(iota(1, 10));\n    xticks({1, 4, 6, 10});\n    xticklabels({\"A\", \"B\", \"C\", \"D\"});\n    xticks(automatic);\n    xticklabels(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(rand(5, 5, 0, 1));\n    xticklabels({});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/x-ticks/","title":"X Ticks","text":"<pre><code>xticks(xs);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    plot(x, y);\n    xticks({0, 5, 10});\n    xticklabels({\"x=0\", \"x=5\", \"x=10\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(-5, +5);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    plot(x, y);\n    xticks({-5, -2.5, -1, 0, 1, 2.5, 5});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 50);\n    auto y = transform(x, [](double x) { return sin(x / 2.); });\n    plot(x, y);\n    xticks(iota(0, 10, 50));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 6 * pi);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    xlim({0, 6 * pi});\n    xticks(iota(0, pi, 6 * pi));\n    xticklabels({\"0\", \"\u03c0\", \"2\u03c0\", \"3\u03c0\", \"4\u03c0\", \"5\u03c0\", \"6\u03c0\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 0.5, 3);\n    auto y = rand(7, 0, 1);\n    plot(x, y);\n    auto ticks = iota(0, 0.25, 3);\n    xticks(ticks);\n    xlabel(\"min\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    stem(iota(1, 10));\n    xticks({0, 4, 6, 10});\n    xticks(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    auto ax2 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    xticks({1, 2, 3});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    xticks({});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/y-tick-angle/","title":"Y Tick Angle","text":"<pre><code>ytickangle(ang);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 50, 20);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    stem(x, y);\n    ytickangle(90);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, rand(6, 6, 0, 1));\n\n    auto ax2 = nexttile();\n    plot(ax2, rand(6, 6, 0, 1));\n    ytickangle(ax2, 45);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 50, 20);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    stem(x, y);\n\n    std::cout &lt;&lt; \"ytickangle(): \" &lt;&lt; ytickangle() &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/y-tick-format/","title":"Y Tick Format","text":"<pre><code>ytickformat(fmtstr);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 20, 100);\n    vector_1d y = {88, 67, 98, 43, 45, 65};\n    bar(x, y);\n    ytickformat(\"usd\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 20, 100);\n    vector_1d y = {88, 67, 98, 43, 45, 65};\n    bar(x, y);\n    ytickformat(\"usd\");\n    std::cout &lt;&lt; \"ytickformat(): \" &lt;&lt; ytickformat() &lt;&lt; std::endl;\n    ytickformat(\"$%.0f\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 10);\n    vector_1d y = {17, 25, 27, 28, 33, 32, 33, 34, 33, 35};\n    plot(x, y, \"-V\");\n    ytickformat(\"%g M\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = rand(30, 0, 1);\n    auto y = rand(30, 0, 1);\n    scatter(x, y);\n    ytickformat(\"%.2f\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, rand(6, 6, 0, 1));\n\n    auto ax2 = nexttile();\n    plot(ax2, rand(6, 6, 0, 1));\n\n    ytickformat(ax2, \"usd\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/y-tick-labels/","title":"Y Tick Labels","text":"<pre><code>yticklabels(ystrs);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    auto ax2 = nexttile();\n    plot(rand(3, 3, 0, 1));\n\n    ylim(ax2, {0, 1});\n    yticks(ax2, {0, 0.25, .5, .75, 1});\n    yticklabels(ax2, {\"y=0\", \"1/4\", \"1/2\", \"3/4\", \"y=1\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    stem(iota(1, 10));\n\n    yticks({1, 4, 6, 10});\n    yticklabels({\"A\", \"B\", \"C\", \"D\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    stem(iota(1, 10));\n\n    yticks({1, 4, 6, 10});\n    yticklabels({\"A\", \"B\", \"C\", \"D\"});\n\n    yticks(automatic);\n    yticklabels(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(rand(5, 5, 0, 1));\n    yticklabels({});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/y-ticks/","title":"Y Ticks","text":"<pre><code>yticks(ys);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    plot(x, y);\n    yticks({0, 50, 100});\n    yticklabels({\"y=0\", \"y=50\", \"y=100\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(-5, +5);\n    auto y = transform(x, [](double x) { return pow(x, 2); });\n    plot(x, y);\n    yticks({0, 2, 4, 6, 8, 10, 15, 25});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return pow(x, 2.); });\n    plot(x, y);\n    yticks(iota(0, 25, 100));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 6 * pi);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    xlim({0, 6 * pi});\n    yticks(iota(-1, 1, 1));\n    yticklabels({\"min\", \"zero\", \"max\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = iota(0, 0.5, 3);\n    auto y = rand(7, 0, 1);\n    plot(x, y);\n    auto ticks = iota(0, 0.25, 1.);\n    yticks(ticks);\n    xlabel(\"min\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    stem(iota(1, 10));\n    yticks({0, 5, 10});\n    yticks(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    auto ax2 = nexttile();\n    plot(rand(3, 3, 0, 1));\n    yticks(iota(0, .2, 1));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    yticks({});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/z-tick-format/","title":"Z Tick Format","text":"<pre><code>ztickformat(fmtstr);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto z = rand(5, 5, 0, 10);\n    stem3(z);\n    ztickformat(\"usd\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto z = rand(5, 5, 0, 10);\n    stem3(z);\n    ztickformat(\"usd\");\n\n    std::cout &lt;&lt; \"ztickformat(): \" &lt;&lt; ztickformat() &lt;&lt; std::endl;\n    ztickformat(\"$%.0f\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto t = iota(0, pi / 10, 10 * pi);\n    auto st = transform(t, [](double t) { return sin(t); });\n    auto ct = transform(t, [](double t) { return cos(t); });\n    plot3(st, ct, t);\n    grid(on);\n    ztickformat(\"%g cm\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = rand(50, 0, 10);\n    auto y = rand(50, 0, 10);\n    auto z = rand(50, 0, 10);\n    scatter3(x, y, z);\n    ztickformat(\"%.2f\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(1, 2);\n    auto ax1 = nexttile();\n    stem3(ax1, rand(5, 5, 0, 4));\n    ztickformat(ax1, \"usd\");\n\n    auto ax2 = nexttile();\n    stem3(ax2, rand(5, 5, 0, 4));\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/grid/z-ticks/","title":"Z Ticks","text":"<pre><code>zticks(zs);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    zlim({-8, 8});\n    zticks({-8, 0, +8});\n    zticklabels({\"z=-8\", \"z=0\", \"z=8\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    zlim({-10, 10});\n    zticks({-10, -2.5, 0, 2.5, 10});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    zlim({-10, 10});\n    zticks(iota(-10, 2, 10));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto t = iota(0, pi / 50, 10 * pi);\n    auto st = transform(t, [](double t) { return sin(t); });\n    auto ct = transform(t, [](double t) { return cos(t); });\n    plot3(st, ct, t);\n    zlim({0, 40});\n    zticks(iota(0, 8, 40));\n    zticks(automatic);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    stem3(ax1, rand(5, 5, 0, 4));\n    zticks(ax1, {0, 1.5, 3.25});\n\n    auto ax2 = nexttile();\n    stem3(ax2, rand(5, 5, 0, 4));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    mesh(x, y, z);\n    zticks({});\n    box(off);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/labels/legend/","title":"Legend","text":"<pre><code>legend({str1,str2,str3});\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, pi);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return cos(x); });\n    plot(x, y1);\n\n    hold(on);\n    std::vector&lt;double&gt; y2 = transform(x, [](auto x) { return cos(2 * x); });\n    plot(x, y2);\n\n    legend(\"cos(x)\", \"cos(2x)\");\n\n    std::vector&lt;double&gt; y3 = transform(x, [](auto x) { return cos(3 * x); });\n    auto p = plot(x, y3);\n    p-&gt;display_name(\"cos(3x)\");\n    hold(off);\n\n    show();\n\n    legend(off);\n    show();\n\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto y1 = rand(3, 3, 0, 1);\n    auto ax1 = nexttile();\n    plot(y1);\n\n    auto y2 = rand(3, 3, 0, 1);\n    auto ax2 = nexttile();\n    plot(y2);\n\n    legend(ax1, \"Line 1\", \"Line 2\", \"Line 3\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, pi);\n    auto y1 = transform(x, [](double x) { return cos(x); });\n    auto y2 = transform(x, [](double x) { return cos(2 * x); });\n\n    auto p1 = plot(x, y1);\n    p1-&gt;display_name(\"cos(x)\");\n\n    hold(on);\n    auto p2 = plot(x, y2);\n    p2-&gt;display_name(\"cos(2x)\");\n    hold(off);\n\n    legend();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, pi);\n    auto y1 = transform(x, [](double x) { return cos(x); });\n    auto y2 = transform(x, [](double x) { return cos(2 * x); });\n    auto y3 = transform(x, [](double x) { return cos(3 * x); });\n    auto y4 = transform(x, [](double x) { return cos(4 * x); });\n\n    plot(x, y1);\n    hold(on);\n    plot(x, y2);\n    plot(x, y3);\n    plot(x, y4);\n    hold(off);\n\n    auto l = legend(\"cos(x)\", \"cos(2x)\", \"cos(3x)\", \"cos(4x)\");\n    l-&gt;location(legend::general_alignment::topleft);\n    l-&gt;num_rows(2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, pi);\n    auto y1 = transform(x, [](double x) { return cos(x); });\n    auto y2 = transform(x, [](double x) { return cos(2 * x); });\n    auto y3 = transform(x, [](double x) { return cos(3 * x); });\n\n    auto p1 = plot(x, y1);\n    hold(on);\n    plot(x, y2);\n    auto p3 = plot(x, y3);\n    hold(off);\n\n    legend({p1, p3}, {\"First\", \"Third\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, pi);\n    auto y1 = transform(x, [](double x) { return cos(x); });\n    auto y2 = transform(x, [](double x) { return cos(2 * x); });\n\n    plot(x, y1);\n    hold(on);\n    plot(x, y2);\n    hold(off);\n\n    auto lgd = legend(\"cos(x)\", \"cos(2x)\");\n    title(lgd, \"My legend title\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, pi);\n    auto y1 = transform(x, [](double x) { return cos(x); });\n    auto y2 = transform(x, [](double x) { return cos(2 * x); });\n\n    plot(x, y1);\n    hold(on);\n    plot(x, y2);\n    hold(off);\n\n    auto lgd = legend(\"cos(x)\", \"cos(2x)\");\n    lgd-&gt;location(legend::general_alignment::bottomleft);\n    lgd-&gt;box(false);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto rdm = rand(4, 4, 0, 1);\n\n    plot(rdm);\n\n    auto lgd = legend(\"Line 1\", \"Line 2\", \"Line 3\", \"Line 4\");\n    lgd-&gt;font_size(12);\n    lgd-&gt;text_color(\"blue\");\n    lgd-&gt;num_columns(2);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/labels/subplot-title/","title":"Subplot Title","text":"<pre><code>sgtitle(str);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    subplot(2, 2, 0);\n    title(\"First Subplot\");\n    subplot(2, 2, 1);\n    title(\"Second Subplot\");\n    subplot(2, 2, 2);\n    title(\"Third Subplot\");\n    subplot(2, 2, 3);\n    title(\"Fourth Subplot\");\n\n    sgtitle(\"Subplot Grid Title\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    subplot(2, 1, 0);\n    title(\"First Subplot\");\n    subplot(2, 1, 1);\n    title(\"Second Subplot\");\n\n    sgtitle(\"Subplot Grid Title\", \"red\");\n    gcf()-&gt;title_font_size_multiplier(2.0);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/labels/title/","title":"Title","text":"<pre><code>title(str);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    title(\"My title\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    double f = 70.;\n    double c = (f - 32) / 1.8;\n    title(\"Temperature is \" + num2str(c) + \" C\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    title(\"Case number # 3\", \"m\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto t = iota(0, 0.01, 0.2);\n    auto y = transform(t, [](double x) { return exp(-25 * x); });\n    plot(t, y);\n    title(\"y = {/:Italic e^{\u03bbt}}\", \"b\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    title(\"\u03b1^2 and X_1\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    title(\"First line\\\\nSecond line\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    title(\"X_1\");\n    gca()-&gt;title_enhanced(false);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x1 = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    auto x2 = transform(iota(1, 10), [](double x) { return pow(x, 3); });\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, x1);\n\n    auto ax2 = nexttile();\n    plot(ax2, x2);\n\n    title(ax1, \"Top Plot\");\n    title(ax2, \"Bottom Plot\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/labels/x-label/","title":"X Label","text":"<pre><code>xlabel(str);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    xlabel(\"Population\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    xlabel(\"Population\\\\n(in thousands)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = linspace(-2 * pi, +2 * pi);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    xlabel(\"-2\u03c0 \u2264 x \u2264 2\u03c0\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    int year = 2014;\n    xlabel(\"Population for Year \" + num2str(year));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto t = linspace(0, 1);\n    auto y = transform(t, [](double t) { return exp(t); });\n    plot(t, y);\n    xlabel(\"t_{seconds}\");\n    ylabel(\"e^t\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    xlabel(\"Population\");\n    auto ax = gca();\n    ax-&gt;x_axis().label_font_size(12);\n    ax-&gt;x_axis().label_weight(\"bold\");\n    ax-&gt;x_axis().label_color({0, 1, 0, 0});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x1 = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    auto x2 = transform(iota(1, 10), [](double x) { return pow(x, 3); });\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(x1);\n    xlabel(ax1, \"Population\");\n\n    auto ax2 = nexttile();\n    plot(x2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    xlabel(\"Population\");\n    gca()-&gt;x_axis().label_color(\"red\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/labels/y-label/","title":"Y Label","text":"<pre><code>ylabel(str);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    ylabel(\"Population\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    ylabel(\"2010 Population\\\\nin Years\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = linspace(-2 * pi, +2 * pi);\n    auto y = transform(x, [](double x) { return sin(x); });\n    plot(x, y);\n    ylabel(\"-2\u03c0 \u2264 x \u2264 2\u03c0\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    int year = 2014;\n    ylabel(\"Population for Year \" + num2str(year));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto t = linspace(0, 1);\n    auto y = transform(t, [](double t) { return exp(t); });\n    plot(t, y);\n    ylabel(\"t_{seconds}\");\n    ylabel(\"e^t\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    ylabel(\"Population\");\n    auto ax = gca();\n    ax-&gt;y_axis().label_font_size(12);\n    ax-&gt;y_axis().label_weight(\"bold\");\n    ax-&gt;y_axis().label_color({0, 1, 0, 0});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x1 = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    auto x2 = transform(iota(1, 10), [](double x) { return pow(x, 3); });\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(x1);\n    ylabel(ax1, \"Population\");\n\n    auto ax2 = nexttile();\n    plot(x2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = transform(iota(1, 10), [](double x) { return pow(x, 2); });\n    plot(x);\n    ylabel(\"Population\");\n    gca()-&gt;y_axis().label_color(\"red\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/labels/z-label/","title":"Z Label","text":"<pre><code>zlabel(str);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    zlabel(\"Height\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    auto [X, Y, Z] = peaks(30);\n    surf(ax1, X, Y, Z);\n\n    auto ax2 = nexttile();\n    auto [X2, Y2, Z2] = peaks(45);\n    surf(ax2, X2, Y2, Z2);\n    zlabel(ax2, \"Height\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    surf(X, Y, Z);\n    zlabel(\"Population Change\");\n    gca()-&gt;z_axis().label_color(\"red\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/multiplot/color-order/","title":"Color Order","text":"<pre><code>colororder(colors);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_2d newcolors = {{0.83, 0.14, 0.14},\n                           {1.00, 0.54, 0.00},\n                           {0.47, 0.25, 0.80},\n                           {0.25, 0.80, 0.54}};\n    colororder(newcolors);\n\n    auto x = linspace(0, 10);\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    auto y2 = transform(x, [](double x) { return sin(x - 0.5); });\n    auto y3 = transform(x, [](double x) { return sin(x - 1); });\n    auto y4 = transform(x, [](double x) { return sin(x - 1.5); });\n\n    plot(x, y1)-&gt;line_width(2);\n    hold(on);\n    plot(x, y2)-&gt;line_width(2);\n    plot(x, y3)-&gt;line_width(2);\n    plot(x, y4)-&gt;line_width(2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::string&gt; newcolors = {\"#FF0000\", \"#FF8800\", \"#FFFF00\",\n                                          \"#00BB00\", \"#0000FF\", \"#5500FF\",\n                                          \"#AA00FF\"};\n    colororder(newcolors);\n\n    hold(on);\n    for (size_t r = 1; r &lt;= 7; ++r) {\n        auto x = linspace(0., static_cast&lt;double&gt;(r), 500);\n        auto y =\n            transform(x, [&amp;](double x) { return sqrt(pow(r, 2) - pow(x, 2)); });\n        plot(x, y)-&gt;line_width(15);\n    }\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; newcolors = {\n        {0, 0.5, 1}, {0.5, 0, 1}, {0.7, 0.7, 0.7}};\n    colororder(newcolors);\n    bar(vector_2d{{10, 20, 30}, {25, 35, 45}, {30, 40, 52}});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; newcolors = {{0.4, 0.3, 0.9},\n                                                  {0.5, 0.65, 0.15}};\n    colororder(newcolors);\n\n    plot(vector_2d{{1, 3}, {2, 4}});\n    hold(on);\n    auto p2 = plot(vector_2d{{4, 2}, {3, 1}});\n    p2[0]-&gt;use_y2(true);\n    p2[1]-&gt;use_y2(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; leftcolors = {\n        {0, 0, 1}, {0, 0.5, 1}, {0, 0.8, 1}};\n    colororder(leftcolors);\n    plot(vector_2d{{1, 4}, {2, 5}, {3, 6}});\n    auto ax = gca();\n    ax-&gt;y_axis().color(ax-&gt;colororder()[0]);\n\n    hold(on);\n    auto p2 = plot(vector_2d{{4, 2}, {3, 1}}, \"k-\");\n    p2[0]-&gt;use_y2(true);\n    p2[1]-&gt;use_y2(true).line_style(\"--\");\n    ax-&gt;y_axis().color(\"k\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::string&gt; newcolors = {\"red\", \"magenta\", \"blue\"};\n    colororder(newcolors);\n\n    scatter(iota(1, 10), rand(10, 0, 1))-&gt;marker_face(true);\n    hold(on);\n    scatter(iota(1, 10), rand(10, 0, 1))-&gt;line_style(\"*k\");\n    scatter(iota(1, 10), rand(10, 0, 1))-&gt;marker_face(true);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout();\n    nexttile();\n    auto p1 = plot(vector_2d{{1, 4}, {2, 5}, {3, 6}});\n    p1[0]-&gt;line_width(2);\n    p1[1]-&gt;line_width(2);\n    p1[2]-&gt;line_width(2);\n\n    auto ax = nexttile();\n    auto p2 = plot(ax, vector_2d{{4, 1}, {5, 2}, {6, 3}});\n    p2[0]-&gt;line_width(2);\n    p2[1]-&gt;line_width(2);\n    p2[2]-&gt;line_width(2);\n\n    auto c = ax-&gt;colororder();\n    c[0] = {0., 0.5, 0., 1.};\n    p2[0]-&gt;color(c[0]);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/multiplot/hold/","title":"Hold","text":"<pre><code>hold(on);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(-pi, pi);\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    plot(x, y1);\n\n    hold(on);\n    auto y2 = transform(x, [](double x) { return cos(x); });\n    plot(x, y2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(-pi, pi);\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    plot(x, y1);\n\n    hold(on);\n    auto y2 = transform(x, [](double x) { return cos(x); });\n    plot(x, y2);\n    hold(off);\n\n    auto y3 = transform(x, [](double x) { return sin(2 * x); });\n    plot(x, y3);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    auto y2 = transform(x, [](double x) { return cos(x); });\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, x, y1);\n\n    auto ax2 = nexttile();\n    plot(ax2, x, y2);\n\n    hold(ax1, on);\n    auto y3 = transform(x, [](double x) { return sin(2 * x); });\n    plot(ax1, x, y3);\n    hold(ax1, off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(1, 2);\n    auto ax1 = nexttile();\n    auto ax2 = nexttile();\n\n    plot(ax1, {0, 1, 0, 1});\n    auto s1 = scatter(ax2, rand(10, 0, 1), rand(10, 0, 1));\n    s1-&gt;marker_face(true);\n\n    hold({ax1, ax2}, on);\n    plot(ax1, {.5, .2, .5, .2});\n    auto s2 = scatter(ax2, rand(10, 0, 1), rand(10, 0, 1));\n    s2-&gt;marker_face(true);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/multiplot/subplots/","title":"Subplots","text":"<pre><code>subplot(rows, cols, id);\n</code></pre> <p>Unlike other libraries, subplots uses 0-based indices.</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    subplot(2, 1, 0);\n    fplot(\"sin(x)\");\n\n    subplot(2, 1, 1);\n    fplot(\"sin(5*x)\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    subplot(2, 2, 0);\n    fplot(\"sin(x)\");\n    title(\"Subplot 1: sin(x)\");\n\n    subplot(2, 2, 1);\n    fplot(\"sin(2*x)\");\n    title(\"Subplot 2: sin(2x)\");\n\n    subplot(2, 2, 2);\n    fplot(\"sin(4*x)\");\n    title(\"Subplot 3: sin(4x)\");\n\n    subplot(2, 2, 3);\n    fplot(\"sin(8*x)\");\n    title(\"Subplot 4: sin(8x)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto ax1 = subplot(2, 2, 0);\n    fplot(\"cos(x)\");\n    title(\"Subplot 1: Cosine\");\n\n    auto ax2 = subplot(2, 2, 1);\n    fplot(\"1 - x**2/2 + x**4/24\");\n    title(\"Subplot 2: Polynomial\");\n\n    auto ax3 = subplot(2, 2, {2, 3});\n    fplot(\"cos(x)\", \"b\");\n    hold(on);\n    fplot(\"1 - x**2/2 + x**4/24\", \"g\");\n    title(\"Subplot 3 and 4: Both\");\n\n    axis({ax1, ax2, ax3}, {-4, 4, inf, inf});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n    for (size_t i = 0; i &lt; 4; ++i) {\n        subplot(2, 2, i);\n        std::string equation = \"cos(x**\" + num2str(i + 1) + \") + \" + num2str(i);\n        fplot(equation);\n        title(equation);\n    }\n    subplot(2, 2, 1, true);\n    fplot(\"sin(x)\");\n    title(\"sin(x)\");\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n    subplot({0.1f, 0.3f, 0.3f, 0.3f});\n    fplot(\"sin(x)\");\n    title(\"First Subplot\");\n\n    subplot({0.5f, 0.15f, 0.4f, 0.7f});\n    fplot(\"cos(x)\");\n    title(\"Second Subplot\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n    auto ax1 = subplot(2, 1, 0);\n    fplot(\"sin(x)\");\n    title(\"First Subplot\");\n\n    auto ax2 = subplot(2, 1, 1);\n    fplot(\"cos(x)\");\n    title(\"Second Subplot\");\n\n    ax1-&gt;font_size(15);\n    ax2-&gt;line_width(2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;axes_handle&gt; ax;\n    for (size_t i = 0; i &lt; 4; ++i) {\n        ax.emplace_back(subplot(2, 2, i));\n    }\n\n    subplot(ax[1]);\n    auto p = fplot(\"sin(x)\");\n    p-&gt;line_spec().color({0.1f, 0.5f, 0.1f});\n    p-&gt;line_spec().line_width(2);\n    title(\"Second subplot\");\n    axis({0, 50, -1, 1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot(\"sin(x)\");\n    title(\"Sine Plot\");\n\n    auto ax = gca();\n    subplot(2, 1, 1, ax);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    figure();\n    fplot(\"sin(x)\");\n    title(\"Line Plot 1\");\n    auto ax1 = gca();\n\n    figure();\n    fplot(\"2*sin(x)\");\n    title(\"Line Plot 2\");\n    auto ax2 = gca();\n\n    auto fnew = figure();\n    auto ax1_copy = ax1-&gt;copy(fnew);\n    subplot(2, 1, 0, ax1_copy);\n\n    auto ax2_copy = ax2-&gt;copy(fnew);\n    subplot(2, 1, 1, ax2_copy);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    for (size_t k = 0; k &lt; 4; ++k) {\n        auto data = rand(10, 0, 1);\n        subplot(2, 2, k);\n        stem(data);\n    }\n\n    subplot(2, 2, 1, true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    subplot({0.1f, 0.3f, 0.3f, 0.3f});\n    std::vector&lt;std::vector&lt;double&gt;&gt; y = {\n        {16, 5, 9, 4}, {2, 11, 7, 14}, {3, 10, 6, 15}, {13, 8, 12, 1}};\n    plot(y);\n    title(\"First Subplot\");\n\n    subplot({0.5f, 0.15f, 0.4f, 0.7f});\n    bar(y);\n    title(\"Second Subplot\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    figure();\n\n    auto ax1 = subplot(2, 1, 0);\n    auto theta = linspace(0, 2 * pi, 50);\n    auto rho =\n        transform(theta, [](double theta) { return sin(theta) * cos(theta); });\n    polarplot(ax1, theta, rho);\n\n    auto ax2 = subplot(2, 1, 1);\n    polarscatter(ax2, theta, rho);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto ax1 = subplot(2, 1, 0);\n    auto [x, y, z] = peaks();\n    z = transpose(z);\n    plot(ax1, z);\n    xlim(ax1, {0, 20});\n\n    auto ax2 = subplot(2, 1, 1);\n    plot(ax2, z);\n\n    ax1-&gt;font_size(15);\n    ax2-&gt;line_width(2);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"appearance/multiplot/tiled-layout/","title":"Tiled Layout","text":"<pre><code>tiledlayout(rows, cols);\nnexttile();\n</code></pre> Plot C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    fplot(ax1, \"sin(x)\");\n    title(ax1, \"Plot 1\");\n    ax1-&gt;font_size(14);\n    ax1-&gt;x_axis().color(\"red\");\n\n    auto ax2 = nexttile();\n    fplot(ax2, \"cos(x)\", \"ob\");\n    title(ax2, \"Plot 2\");\n    grid(ax2, on);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 2);\n    auto [x, y, z] = peaks(20);\n\n    nexttile();\n    surf(x, y, z);\n\n    nexttile();\n    contour(x, y, z);\n\n    nexttile();\n    imagesc(z);\n\n    nexttile();\n    plot3(x, y, z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 30);\n    auto y1 = transform(x, [](double x) { return sin(x / 2); });\n    auto y2 = transform(x, [](double x) { return sin(x / 3); });\n    auto y3 = transform(x, [](double x) { return sin(x / 4); });\n\n    tiledlayout();\n    nexttile();\n    plot(x, y1);\n\n    nexttile();\n    plot(x, y2);\n\n    nexttile();\n    plot(x, y3);\n\n    nexttile();\n    plot(x, y1);\n    hold(on);\n    plot(x, y2);\n    plot(x, y3);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 30);\n    auto y1 = transform(x, [](double x) { return sin(x); });\n    auto y2 = transform(x, [](double x) { return sin(x / 2); });\n    auto y3 = transform(x, [](double x) { return sin(x / 3); });\n    auto y4 = transform(x, [](double x) { return sin(x / 4); });\n\n    tiledlayout();\n    nexttile();\n    plot(x, y1);\n\n    nexttile();\n    plot(x, y2);\n\n    nexttile();\n    plot(x, y3);\n\n    nexttile();\n    plot(x, y4);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 2);\n    nexttile();\n    plot(rand(20, 0, 1));\n    title(\"Sample 1\");\n\n    nexttile();\n    plot(rand(20, 0, 1));\n    title(\"Sample 2\");\n\n    nexttile();\n    plot(rand(20, 0, 1));\n    title(\"Sample 3\");\n\n    nexttile();\n    plot(rand(20, 0, 1));\n    title(\"Sample 4\");\n\n    sgtitle(\"Size vs. Distance\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n\n    nexttile();\n    stem(iota(1, 13));\n\n    nexttile();\n    bar(std::vector&lt;double&gt;{10, 22, 31, 43, 52});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(1, 2);\n\n    nexttile();\n    geoplot(vector_1d{47.62, 61.20}, vector_1d{-122.33, -149.90}, \"g-*\");\n    geolimits({46, 62}, {-160, -110});\n\n    nexttile();\n    auto theta = iota(pi / 4, pi / 4, 2 * pi);\n    std::vector&lt;double&gt; rho = {19, 6, 12, 18, 16, 11, 15, 15};\n    polarscatter(theta, rho);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 2);\n    auto [x, y, z] = peaks(20);\n\n    nexttile();\n    surf(x, y, z);\n\n    nexttile();\n    contour(x, y, z);\n\n    nexttile();\n    imagesc(z);\n\n    nexttile();\n    plot3(x, y, z);\n\n    auto ax = nexttile(2);\n    colormap(ax, palette::cool());\n\n    show();\n    return 0;\n}\n</code></pre> <p>Our tiling functions are convenience shortcuts for the subplot functions. If there is no room for the next tile, we automatically rearrange the axes and increase the number of subplot rows or columns to fit the next tile. Use subplots for more control over the subplots. </p>"},{"location":"appearance/multiplot/yy-axis/","title":"YY-axis","text":"<pre><code>plot(x, y)-&gt;use_y2(true);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 10);\n    auto y1 = transform(x, [](double x) { return sin(3 * x); });\n    plot(x, y1);\n\n    hold(on);\n    auto z = transform(x, [](double x) { return sin(3 * x) * exp(0.5 * x); });\n    plot(x, z)-&gt;use_y2(true);\n    y2lim({-150, 150});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto ind = linspace(0, 51);\n    auto drivers =\n        transform(ind, [](double ind) { return pow(ind, 2) + randn(0, 50); });\n    scatter(ind, drivers);\n    title(\"Highway data\");\n    xlabel(\"States\");\n    ylabel(\"Licensed Drivers\");\n    ylim({0, inf});\n\n    hold(on);\n    auto pop = transform(\n        ind, [](double ind) { return 10000 * (pow(ind, 2) + randn(0, 100)); });\n    scatter(ind, pop)-&gt;use_y2(true);\n    y2label(\"Vehicle Miles Traveled\");\n    y2lim({0, inf});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_1d x = linspace(0, 10);\n    auto yl1 = transform(x, [](double x) { return sin(x); });\n    auto yl2 = transform(x, [](double x) { return sin(x / 2); });\n    plot(x, yl1)-&gt;color(gca()-&gt;colororder()[0]);\n    hold(on);\n    plot(x, yl2)-&gt;color(gca()-&gt;colororder()[0]).line_style(\"--\");\n\n    auto yr1 = x;\n    auto yr2 = transform(x, [](double x) { return pow(x, 2); });\n    plot(x, yr1)-&gt;use_y2(true).color(gca()-&gt;colororder()[1]);\n    plot(x, yr2)-&gt;use_y2(true).color(gca()-&gt;colororder()[1]).line_style(\"--\");\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    colororder({\"b\", \"m\"});\n\n    vector_2d y = {{1, 3}, {2, 4}};\n    auto p1 = plot(y);\n    p1[0]-&gt;color(\"b\");\n    p1[1]-&gt;color(\"b\").line_style(\"--\");\n    gca()-&gt;y_axis().color(\"b\");\n\n    hold(on);\n    vector_2d z = {{4, 2}, {3, 1}};\n    auto ps = plot(z);\n    ps[0]-&gt;use_y2(true).color(\"m\");\n    ps[1]-&gt;use_y2(true).color(\"m\").line_style(\"--\");\n    gca()-&gt;y2_axis().color(\"m\");\n\n    legend();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_2d magic = {{8, 3, 4}, {1, 5, 9}, {6, 7, 2}};\n    bar(magic);\n    auto ax = gca();\n    ax-&gt;y_axis().color(ax-&gt;colororder()[0]);\n\n    hold(on);\n    scatter(std::vector{1., 2., 3.}, std::vector{2., 5., 2.})\n        -&gt;marker_face(true)\n        .use_y2(true);\n    scatter(std::vector{1., 2., 3.}, std::vector{3., 4., 1.})\n        -&gt;marker_face(true)\n        .use_y2(true);\n    scatter(std::vector{1., 2., 3.}, std::vector{4., 2., 4.})\n        -&gt;marker_face(true)\n        .use_y2(true);\n    ax-&gt;y2_axis().color(ax-&gt;colororder()[1]);\n    hold(off);\n\n    legend();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_1d x = linspace(1, 10);\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    plot(ax1, x, transform(x, [](double x) { return sin(x); }));\n    hold(on);\n    plot(ax1, x, transform(x, [](double x) { return exp(x); }))-&gt;use_y2(true);\n\n    auto ax2 = nexttile();\n    plot(ax2, iota(1, 10));\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"coding-styles/backends/","title":"Backends","text":"<p>This library currently include a GnuPlot backend and an experimental OpenGL backend. Coming up with new backends is a continuous process. See the complete article for a description of the backend interface, a description of the current default backend (Gnuplot pipe), and what's involved in possible new backends. See the directory <code>source/matplot/backend</code> for some examples. Also, have a look at this example <code>test/backends/main.cpp</code>.</p> <p>If you're in a hurry, here is a summary of the backends we have and the backends we have been considering or are working on:</p> <ul> <li>Gnuplot<ul> <li>Pros: It seems to be working for everyone.</li> <li>Cons: Pipes are comparatively slow and unidirectional</li> <li>In practice, this is default backend you'll get right now.</li> </ul> </li> <li>OpenGL<ul> <li>Pros: Efficient for many FPS.</li> <li>Cons: Blocks the main thread on some operating systems</li> <li>The experimental OpenGL backend already works for some plot categories. <sup>see 1 </sup></li> </ul> </li> <li>Qt<ul> <li>Same as OpenGL <sup>see 1, 2 </sup></li> </ul> </li> <li>AGG<ul> <li>Pros: Great for vector graphics</li> <li>Cons: Unmaintained, 2D only, and non-interactive by itself <sup>see 1, 2, 3 </sup></li> </ul> </li> </ul>"},{"location":"coding-styles/common-utilities/","title":"Common Utilities","text":"<p>The headers <code>common.h</code> and <code>colors.h</code> include a number of utilities we use in our examples. These include naive functions to:</p> <ul> <li>generate and manipulate vectors and strings; </li> <li>handle RGBA color arrays; </li> <li>convert points to and from polar coordinates;</li> <li>read files to strings; </li> <li>write strings to files; </li> <li>calculate gradients; </li> <li>read, write, and manipulate images; </li> <li>and generate vectors with random numbers. </li> </ul> <p>Although some of these functions might be helpful, most functions only operate on <code>std::vector&lt;double&gt;</code> and they are not intended to be a library of utilities. The sole purpose of these algorithms is to simplify the examples.</p>"},{"location":"coding-styles/member-vs-free-standing-functions/","title":"Member vs. Free-standing Functions","text":"<p>Like in Matplotlib, we support two coding styles: Free-standing functions and an Object-oriented interface.</p> <p>These two examples would generate the same plot:</p> Free-standing functions <pre><code>auto ax = gca();\nplot(ax, x, y)-&gt;color(\"red\").line_width(2);\nmy_function(ax);\n</code></pre> Object-oriented interface <pre><code>auto ax = gca();\nax-&gt;plot(x, y)-&gt;color(\"red\").line_width(2);\nmy_function(ax);\n</code></pre> <ul> <li> <p>Freestanding functions: </p> <ul> <li>We call functions to create plots on the current axes</li> <li>The global current <code>axes</code> object is the current <code>axes</code> object in the current figure in the global figure registry</li> <li>For instance, one can use <code>plot(y);</code> to create a line plot on the current axes (or create a new <code>axes</code> object if needed). </li> <li>Also, one can use <code>plot(ax,y);</code> to create a line plot on the <code>axes</code> object <code>ax</code>. </li> <li>This is less verbose for small projects and quick tests.</li> <li>The library looks for existing axes to create the plot.</li> </ul> </li> <li> <p>Object-oriented interface: </p> <ul> <li>We explicitly create figures and call methods on them</li> <li>For instance, one can use <code>ax-&gt;plot(y);</code> to plot on the <code>axes</code> object <code>ax</code></li> <li>We can create the same line plot on the current axes by <code>auto ax = gca(); ax-&gt;plot(y);</code></li> <li>This is less verbose and provides better control in large projects where we need to pass these objects around</li> <li>The user manages axes handles containing plots.</li> </ul> </li> </ul> <p>All free-standing functions are templated functions that use meta-programming to call the main function on the current <code>axes</code> object. If the first parameter is not an <code>axes_handle</code>, it will get an <code>axes_handle</code> from the figure registry with <code>gca</code> (Section Axes Object) and forward all parameters to the function in this <code>axes</code> object. If the first parameter is an <code>axes_handle</code>, the template function will forward all parameters, but the first one, to this <code>axes</code> object. This use of templates for the free-standing functions keeps both coding styles maintainable by the developers.</p> <p>Note that, because the example needs the <code>axes</code> object for the function <code>my_function</code>, we also need to get a reference to the <code>axes</code> object with the free-standing functions. In that case, the free-standing functions are not less verbose than the object-oriented interface.</p> <p>To adhere to free-standing functions, we could create two versions of <code>my_function</code>: one that receives an <code>axes_handle</code>, and a second version that would get an <code>axes_handle</code> from the figure registry and call the first version. If <code>my_function</code> is going to be exposed to other users as a library, this could be a convenience to these users. However, notice that this is only moving the verbosity from the main function to <code>my_function</code>. In fact, this is how the free-standing functions in Matplot++ work.</p>"},{"location":"coding-styles/method-chaining/","title":"Method Chaining","text":"<p>To support a more compact syntax, the library allows method chaining on plot objects. For instance, we can create a simple line plot and modify its appearance by</p> Object Handle <pre><code>// Using the line handle\nauto p = plot(x,y,\"--gs\");\np-&gt;line_width(2);\np-&gt;marker_size(10);\np-&gt;marker_color(\"b\");\np-&gt;marker_face_color({.5,.5,.5});\n</code></pre> Method Chaining <pre><code>// Method chaining\nplot(x,y,\"--gs\")\n  -&gt;line_width(2)\n  .marker_size(10)\n  .marker_color(\"b\")\n  .marker_face_color({.5,.5,.5});\n</code></pre> <p>The first code snippet works because <code>plot</code> returns a <code>line_handle</code> to the object in the <code>axes</code>. We can use this line handle to modify the line plot. Whenever we modify a property, the setter function calls <code>touch</code>, which will <code>draw</code> the figure again if it is in reactive mode. The second option works because setters return a reference to <code>*this</code> rather than void. </p>"},{"location":"coding-styles/motivation-and-details/","title":"Motivation and Details","text":"<p>If you are interested in understanding how the library works, you can read the details in the complete article. It describes the relationship between its main objects, the backend interface, how to create new plot categories, its limitations, and compares this library with similar alternatives.</p>"},{"location":"coding-styles/ranges/","title":"Ranges","text":"<p>The plotting functions work on any range of elements convertible to <code>double</code>. For instance, we can create a line plot from a set of elements by</p> <pre><code>set&lt;int&gt; y = {6,3,8,2,5};\nplot(y);\n</code></pre> <p>Any object that has the functions <code>begin</code> and <code>end</code> are considered iterable ranges. Most <code>axes object</code> subclasses use <code>vector&lt;double&gt;</code> or <code>vector&lt;vector&lt;double&gt;&gt;</code> to store their data. For convenience, the <code>common.h</code> header file includes the aliases <code>vector_1d</code> and <code>vector_2d</code> to these data types.</p> <p>These conversions also work on ranges of ranges:</p> <pre><code>vector&lt;set&lt;int&gt;&gt; Y = { {6, 3, 8, 2, 5}, {6, 3, 5, 8, 2} };\nplot(Y);\n</code></pre> <p>Unfortunately, because of how templated functions work, one exception is initializer lists. Initializer lists only work for functions that are explicitly defined for them.</p>"},{"location":"coding-styles/reactive-vs-quiet-figures/","title":"Reactive vs. Quiet Figures","text":"<p>There are also two modes for figures: reactive (or interactive) mode and quiet mode. </p> Reactive mode <pre><code>// Reactive mode\nauto f = figure(false);\nauto ax = f-&gt;gca();\nauto p = ax-&gt;plot(ax, x, y);   // draws once\np-&gt;color(\"red\").line_width(2); // draws twice more\nshow();                        // pause console\n</code></pre> Quiet mode <pre><code>// Quiet mode\nauto f = figure(true);\nauto ax = f-&gt;gca();\nauto p = ax-&gt;plot(x,y);        // does not draw\np-&gt;color(\"red\").line_width(2); // does not draw\nf-&gt;show();                     // draw only once and pause console\n</code></pre> <p>Figures in reactive mode are updated whenever any of their child objects change. This happens through the <code>touch</code> function, that gets called on any child object when it changes its appearance. This creates an interactive mode in which figures are updated as soon as we adjust their properties. If we combine interactive figures with free-standing functions, we have a \"Matlab-like style\" for plots. This is a coding pattern where the figure registry works as a stream for plots. The problem with this coding style is that the user might unnecessarily create useless intermediary plots.</p> <p>Figures in quiet mode are updated by calling the functions <code>draw()</code> or <code>show()</code> (Section Reactive Figures). Unless these functions are called, nothing changes in the figure. The combination of the object-oriented coding style and quiet mode is the \"OO-Matplotlib-like style\" for plots. This is a coding style in which the user explicitly decides when the plot is shown or updated. This is beneficial to applications that cannot waste computational resources on intermediary figures that might not be valuable to the application.</p> <p>We generally use free-standing functions with reactive mode and the object-oriented interface with quiet mode. By default, new figures are in reactive mode, unless it is using an non-interactive backend. One can turn this reactive mode on and off with:</p> <ul> <li><code>ion()</code> or <code>ioff()</code> free-standing functions</li> <li><code>reactive(bool)</code> or <code>quiet(bool)</code> function on the <code>figure</code> object</li> <li><code>figure(true)</code> or <code>figure(false)</code> when explicitly creating a new figure</li> </ul> <p>For convenience, the examples in Section Examples use the reactive mode. The <code>show</code> function pauses the console until the user interacts with the plot window. If the backend is based on process pipes, because these are unidirectional, closing the window is not enough to resume. The user needs to use the console to unblock execution. A similar example is quiet mode would be</p> <p>In this example, the figure is only updated once. The user could replace the <code>show</code> function with the <code>draw</code> function, but the window would close as soon as execution completes. It is important to use <code>show()</code> with caution. These functions are meant for some particular executables so that an interactive plot does not close before the user can see it. It is probably unreasonable to call these functions inside a library because the user would have to manually interfere with the execution to continue.</p>"},{"location":"community/contributing-guidelines/","title":"Contributing Guidelines","text":"<p>If contributing with code, please leave the OpenGL backend and pedantic mode ON (<code>-DBUILD_EXPERIMENTAL_OPENGL_BACKEND=ON -DBUILD_WITH_PEDANTIC_WARNINGS=ON</code>), use cppcheck, and clang-format.</p> <p>Example: CLion</p> <p></p> <p>If contributing to the documentation, please edit <code>README.md</code> directly, as the files in <code>./docs</code> are automatically generated with mdsplit.</p>"},{"location":"community/contributors/","title":"Contributors","text":"<sub>Alan De Freitas</sub> <sub>Duncan Ogilvie</sub> <sub>Luis CC!ceres</sub> <sub>Matthew-hennefarth</sub> <sub>Actions-user</sub> <sub>Alex</sub> <sub>Rath3t</sub> <sub>Marcus Asteborg</sub> <sub>Zengit</sub> <sub>Randy Jones</sub> <sub>Sammi</sub> <sub>BjC6rn Sundin</sub> <sub>Christophe Prud'homme</sub> <sub>Dimitrij Mijoski</sub> <sub>MaBnt</sub> <sub>Morwenn</sub> <sub>Niclas Wall Wennerdal</sub> <sub>Solo Super</sub> <sub>Akash Patel</sub> <sub>Eagle-dai</sub> <sub>Myd7349</sub> <sub>Andrew Kane</sub> <p>We would also like to thank The Icculus Microgrant.</p>"},{"location":"community/get-involved/","title":"Get Involved","text":"<ul> <li>After getting started with this library, please complete this survey to let us know how we can improve your experience.</li> <li>Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community.</li> <li>If you are a programmer with good ideas, please share these ideas with us.</li> <li>Academic collaboration is more than welcome. It'd be great to see this library help people write lots and lots of academic papers.</li> </ul>"},{"location":"community/ideas-and-roadmap/","title":"Ideas and Roadmap","text":"<p>Feel free to contribute with new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its own conventions might seem intricate at first but please don't let that discourage you from sharing your ideas.</p> <p>There are many ways in which you can contribute to this library:</p> <ul> <li>Testing the library in new environments <sup>see 1, 2, 3 </sup></li> <li>Contributing with interesting examples <sup>see 1</sup></li> <li>Designing new backends <sup>see 1, 2, 3, 4</sup></li> <li>Finding problems in this documentation <sup>see 1 </sup></li> <li>Writing algorithms for new plot categories <sup>see 1 </sup></li> <li>Finding bugs in general <sup>see 1, 2, 3, 4 </sup></li> <li>Whatever idea seems interesting to you</li> </ul> <p>The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are:</p> <ul> <li>\"I don't like this optional feature so I removed/deprecated it\"</li> <li>\"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative</li> <li>\"I removed this feature so I don't have to install/update ______\" but have not provided an equivalent alternative</li> <li>\"I'm creating this high-cost promise that we'll support __ forever\" but I'm not sticking around to keep that promise</li> </ul> <p>In doubt, please open a discussion first</p>"},{"location":"exporting/saving-manually/","title":"Saving (Manually)","text":"<p>The interactive plot window contains a widget to save the current figure. Because this widget uses the same backend as the one used to produce the interactive image, the final image matches closely what the user sees in the window.</p>"},{"location":"exporting/saving-programatically/","title":"Saving (Programatically)","text":"<p>You can programmatically save the figure in a number of formats with the <code>save</code> function:</p> <pre><code>save(filename);\n</code></pre> <p>or</p> <pre><code>save(filename, fileformat);\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {29, 17, 14, 13, 12, 4, 11};\n    bar(x);\n\n    save(\"img/barchart.svg\");\n    save(\"img/barchart.eps\");\n    save(\"img/barchart.gif\");\n    save(\"img/barchart.jpg\");\n    save(\"img/barchart.html\");\n    save(\"img/barchart.txt\");\n    save(\"img/barchart.tex\");\n\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n\n    std::vector&lt;double&gt; x = {2, 4, 7, 2, 4, 5, 2, 5, 1, 4};\n    bar(x);\n\n    save(\"img/barchart_ps\", \"postscript\");\n    save(\"img/barchart_latex\", \"epslatex\");\n    /*\n     * Add to your latex document:\n     * \\begin{figure}\n     *    \\input{Barchart_latex}\n     * \\end{figure}\n     */\n\n    save(\"img/barchart_gif\", \"gif\");\n    save(\"img/barchart_jpeg\", \"jpeg\");\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n    f-&gt;font(\"Helvetica\");\n\n    std::vector&lt;double&gt; x = {2, 4, 7, 2, 4, 5, 2, 5, 1, 4};\n    bar(x);\n\n    const auto &amp;m = backend::gnuplot::extension_terminal();\n    for (const auto &amp;[extension, format] : m) {\n        save(std::string(\"formats/barchart \") + std::string(format),\n             std::string(format));\n    }\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    contourf(x, y, z);\n\n    save(\"img/contour.gif\");\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n\n    plot(rand(5, 5, 0, 1));\n    save(\"img/lineplot.eps\");\n    save(\"img/lineplot.jpg\");\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    plot(iota(1, 10));\n    textarrow(2, 8, 5, 5, \"y=x\");\n    save(\"img/annotation.eps\");\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    nexttile();\n    plot({1., 2., 3.});\n    nexttile();\n    plot({3., 2., 1.});\n    save(\"img/layout.eps\");\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = peaks();\n    surf(x, y, z);\n    save(\"img/peaks.gif\");\n    save(\"img/peaks.eps\");\n    show();\n    return 0;\n}\n</code></pre> <p>The first option (<code>save(filename)</code>) infers the appropriate file format from the filename extension. In both cases (<code>save(filename)</code> and <code>save(filename,fileformat)</code>), this function temporarily changes the backend to a non-interactive backend appropriate to draw the figure. A different backend is used for each format and, depending on the format, the final image does not necessarily match what is on the interactive plot window. The reason is that some file formats purposefully do not include the same features.</p> <p>For instance, consider the bar chart generated by</p> <pre><code>vector&lt;double&gt; x = {29, 17, 14, 13, 12, 4, 11};\nbar(x);\n</code></pre> <p>If we export the image with</p> <pre><code>save(\"barchart.svg\");\n</code></pre> <p>we get the vector graphics </p> <p>See result</p> <p></p> <p>Exporting the image with</p> <pre><code>save(\"barchart.txt\");\n</code></pre> <p>generates a representation of the image appropriate for text or markdown files, such as</p> <p>See result</p> <pre><code>       30 +-----------------------------------------------------------+\n          |    *******   +       +      +       +      +       +      |\n          |    *     *                                                |\n       25 |-+  *     *                                              +-|\n          |    *     *                                                |\n          |    *     *                                                |\n       20 |-+  *     *                                              +-|\n          |    *     *                                                |\n          |    *     ********                                         |\n       15 |-+  *     **     *                                       +-|\n          |    *     **     * *******                                 |\n          |    *     **     * *     ******** *******                  |\n          |    *     **     * *     **     * *     *        *******   |\n       10 |-+  *     **     * *     **     * *     *        *     * +-|\n          |    *     **     * *     **     * *     *        *     *   |\n          |    *     **     * *     **     * *     *        *     *   |\n        5 |-+  *     **     * *     **     * *     ******** *     * +-|\n          |    *     **     * *     **     * *     **     * *     *   |\n          |    *  +  **  +  * *  +  **  +  * *  +  **  +  * *  +  *   |\n        0 +-----------------------------------------------------------+\n                  1      2       3      4       5      6       7\n</code></pre> <p>As the last example, saving an image with</p> <pre><code>save(\"barchart.tex\");\n</code></pre> <p>would save the image in a format appropriate to embed in latex documents, such as</p> <p>See result</p> <p> </p> <p>This exports the image in a format in which the labels are replaced by latex text so that the plot fits the rest of the document.</p>"},{"location":"integration/cmake/embed-as-subdirectory/","title":"Embed as subdirectory","text":"<p>You can use Matplot++ directly in CMake projects as a subproject, without installing it. This is convenient if you are experimenting with this library for the first time or don't expect your users to have Matplot++ installed on their systems.</p> <p>Check if you have Cmake 3.14+ installed:</p> <pre><code>cmake --version\n</code></pre> <p>Clone the whole project</p> <pre><code>git clone https://github.com/alandefreitas/matplotplusplus/\n</code></pre> <p>and add the subdirectory to your CMake project:</p> <pre><code>add_subdirectory(matplotplusplus)\n</code></pre> <p>When creating your executable, link the library to the targets you want:</p> <pre><code>add_executable(my_target main.cpp)\ntarget_link_libraries(my_target PUBLIC matplot)\n</code></pre> <p>Add this header to your source files:</p> <pre><code>#include &lt;matplot/matplot.h&gt;\n</code></pre> <p>However, in larger projects, it's always recommended to look for Matplot++ with <code>find_package</code> before including it as a subdirectory to avoid ODR errors.</p>"},{"location":"integration/cmake/embed-with-automatic-download/","title":"Embed with automatic download","text":"<p><code>FetchContent</code> is a CMake command that can automatically download the Matplot++ repository. Check if you have Cmake 3.14+ installed:</p> <pre><code>cmake --version\n</code></pre> <p>Include FetchContent in your CMake build script:</p> <pre><code>include(FetchContent)\n</code></pre> <p>Declare the source for the contents:</p> <pre><code>FetchContent_Declare(matplotplusplus\n        GIT_REPOSITORY https://github.com/alandefreitas/matplotplusplus\n        GIT_TAG origin/master # or whatever tag you want\n</code></pre> <p>Let CMake download the repository and include it as a subdirectory.</p> <pre><code>FetchContent_GetProperties(matplotplusplus)\nif(NOT matplotplusplus_POPULATED)\n    FetchContent_Populate(matplotplusplus)\n    add_subdirectory(${matplotplusplus_SOURCE_DIR} ${matplotplusplus_BINARY_DIR} EXCLUDE_FROM_ALL)\nendif()\n</code></pre> <p>When creating your executable, link the library to the targets you want:</p> <pre><code>add_executable(my_target main.cpp)\ntarget_link_libraries(my_target PUBLIC matplot)\n</code></pre> <p>Then add this header to your source files:</p> <pre><code>#include &lt;matplot/matplot.h&gt;\n</code></pre> <p>However, in larger projects, it's always recommended to look for Matplot++ with <code>find_package</code> before including it as a subdirectory to avoid ODR errors.</p>"},{"location":"integration/cmake/embed-with-cpmcmake/","title":"Embed with CPM.cmake","text":"<p>CPM.cmake is a nice wrapper around the CMake <code>FetchContent</code> function.</p> <p>Check if you have Cmake 3.14+ installed:</p> <pre><code>cmake --version\n</code></pre> <p>Install CPM.cmake and then use this command to add Matplot++ to your build script:</p> <pre><code>CPMAddPackage(\n    NAME matplotplusplus\n    GITHUB_REPOSITORY alandefreitas/matplotplusplus\n    GIT_TAG origin/master # or whatever tag you want\n)\n# ...\ntarget_link_libraries(my_target PUBLIC matplot)\n</code></pre> <p>Then add this header to your source files:</p> <pre><code>#include &lt;matplot/matplot.h&gt;\n</code></pre> <p>However, in larger projects, it's always recommended to look for Matplot++ with <code>find_package</code> before including it as a subdirectory to avoid ODR errors.</p> <p>You can use:</p> <pre><code>option(CPM_USE_LOCAL_PACKAGES \"Try `find_package` before downloading dependencies\" ON)\n</code></pre> <p>in your build script to let CPM.cmake do that for you.</p>"},{"location":"integration/cmake/find-as-external-package/","title":"Find as External Package","text":"<p>If you have the library installed on your system, you can call <code>find_package()</code> from your CMake build script.</p> <pre><code>find_package(Matplot++ REQUIRED)\n</code></pre> <p>When creating your executable, link the library to the targets you want:</p> <pre><code>add_executable(my_target main.cpp)\ntarget_link_libraries(my_target PUBLIC Matplot++::matplot)\n</code></pre> <p>Then add this header to your source files:</p> <pre><code>#include &lt;matplot/matplot.h&gt;\n</code></pre> <p>You can see a complete example in <code>test/integration/CMakeLists.txt</code>.</p> <p>CMake should be able to locate the <code>Matplot++Config.cmake</code> script automatically if you installed the library under <code>/usr/local/</code> (Linux / Mac OS). Unfortunately, there is no easy default directory for <code>find_package</code> on Windows.</p> <p>Default directories</p> <p>By default, the library is likely to be in <code>/usr/local/</code> (Linux / Mac OS) or <code>C:/Program Files/</code> (Windows). The installer will try to find the directory where you usually keep your libraries but that's not always perfect.</p> <p>Finding packages on Windows</p> <p>Unfortunately, CMake does not have a single default directory for packages on Windows like <code>/usr/local/lib</code>. If CMake cannot find Matplot++ on Windows or if you installed the library outside the default directory on Linux/Mac OS, there are a few options:</p> <ul> <li>Environment Variables: The most reliable way to set this default directory is through environment variables. You can create an environment variable <code>MATPLOTPP_DIR</code> and then add <code>$ENV{MATPLOTPP_DIR}</code> to the <code>HINTS</code> section of the <code>find_package</code> command. This tends to be more convenient than requiring the path on the command line every time. Starting with version 3.12, CMake now implicitly considers the <code>&lt;PackageName&gt;_Root</code> environment variable a HINT for every <code>find_package</code> call.</li> <li>Package Registry: CMake offers the Package Registry as an alternative mechanism for finding package locations. CMake maintains a list of package information in the Windows registry under <code>HKEY_CURRENT_USER\\Software\\Kitware\\CMake\\Packages\\</code>.</li> <li>Append CMAKE_MODULE_PATH: You can append more directories to <code>CMAKE_MODULE_PATH</code> with something like <code>list(APPEND CMAKE_MODULE_PATH \"C:\\\\Program Files\\\\matplotplusplus 1.0.1\")</code>. <code>CMAKE_MODULE_PATH</code> is a list of search paths for CMake modules to be loaded by the <code>include()</code> or <code>find_package()</code> commands.</li> <li>Set the DIR variable directly: Directly set the <code>Matplot++_DIR</code> variable with something like <code>set(Matplot++_DIR \"C:\\\\Program Files\\\\matplotplusplus 1.0.1\\\\lib\\\\cmake\\\\Matplot++\")</code>. This might be good enough for small local projects but it is hard-coding the directory in your build script. When your library gets out of your local environment, you need to choose one of the other options above (better) or make this variable an option and require the user to provide the directory on the command line every time (worse).</li> </ul>"},{"location":"integration/cmake/supporting-both/","title":"Supporting Both","text":"<p>It's often useful to let your build script download Matplot++ when find_package fails. If using CPM.cmake, you can set the <code>CPM_USE_LOCAL_PACKAGES</code> option to try to <code>find_package(Matplot++)</code> before download Matplot++.</p> <p>If using FetchContent, you can use the following pattern:</p> <pre><code>find_package(Matplot++ QUIET)\nif(NOT Matplot++_FOUND)\n    # Put your FetchContent or CPM.cmake script here\nendif()\n</code></pre>"},{"location":"integration/install/binary-packages/","title":"Binary Packages","text":"<p>Get the binary package from the release section. These binaries refer to the last release version of Matplot++.</p> <p>If you need a more recent version of Matplot++, you can download the binary packages from the CI artifacts or build the library from the source files.</p>"},{"location":"integration/install/build-from-source/build-and-install/","title":"Build and install","text":"<p>Building Examples</p> <p>This will build the examples in the <code>build/examples</code> directory:</p> Ubuntu + GCC <pre><code>mkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\"\nsudo cmake --build . --parallel 2 --config Release\n</code></pre> Mac Os + Clang <pre><code>mkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\"\ncmake --build . --parallel 2 --config Release\n</code></pre> Windows + MSVC <pre><code>mkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"/O2\"\ncmake --build . --parallel 2 --config Release\n</code></pre> <p>Parallel Build</p> <p>Replace <code>--parallel 2</code> with <code>--parallel &lt;number of cores in your machine&gt;</code></p> <p>Setting C++ Compiler</p> <p>If your C++ compiler that supports C++17 is not your default compiler, make sure you provide CMake with the compiler location with the DCMAKE_C_COMPILER and DCMAKE_CXX_COMPILER options. For instance:</p> <pre><code>cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\" -DCMAKE_C_COMPILER=/usr/bin/gcc-8 -DCMAKE_CXX_COMPILER=/usr/bin/g++-8\n</code></pre> <p>Installing</p> <p>You can 1) use <code>-DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF</code> to bypass the examples and tests, and then 2) <code>cmake --install .</code> to install Matplot++ on your system:</p> Ubuntu + GCC <pre><code>mkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\" -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF \nsudo cmake --build . --parallel 2 --config Release\nsudo cmake --install .\n</code></pre> Mac Os + Clang <pre><code>mkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"-O2\" -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF \ncmake --build . --parallel 2 --config Release\ncmake --install .\n</code></pre> Windows + MSVC <pre><code>mkdir build\ncd build\ncmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\"/O2\" -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF \ncmake --build . --parallel 2 --config Release\ncmake --install .\n</code></pre> <p>Parallel Build</p> <p>Replace <code>--parallel 2</code> with <code>--parallel &lt;number of cores in your machine&gt;</code></p> <p>Create packages</p> <p>You can also create the binary packages to install Matplot++ on other systems:</p> Ubuntu + GCC <pre><code>sudo cpack .\n</code></pre> Mac Os + Clang <pre><code>cpack .\n</code></pre> Windows + MSVC <pre><code>cpack .\n</code></pre>"},{"location":"integration/install/build-from-source/dependencies/","title":"Dependencies","text":"<p>C++17</p> <p>Make sure your C++ compiler supports C++17:</p> Ubuntu + GCC <pre><code>g++ --version\n</code></pre> Mac Os + Clang <pre><code>clang --version\n</code></pre> Windows + MSVC <ul> <li>Visit the Visual Studio website</li> <li>Download Git from https://git-scm.com/download/win and install it</li> </ul> <p>The output should be something like:</p> Ubuntu + GCC <pre><code>g++-8 (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0\n</code></pre> Mac Os + Clang <pre><code>Apple clang version 11.0.0 (clang-1100.0.33.8)\n</code></pre> Windows + MSVC <ul> <li>Visit the Visual Studio website</li> <li>Download Git from https://git-scm.com/download/win and install it</li> </ul> <p>If you need to update your compiler:</p> Ubuntu + GCC <pre><code># install GCC-8\nsudo apt update\nsudo apt install gcc-8\nsudo apt install g++-8\n</code></pre> <p>To update to any other version, like GCC-9 or GCC-10:</p> <pre><code>sudo apt install build-essential\nsudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt-get update\nsudo apt install g++-10\n</code></pre> <p>Once you installed a newer version of GCC, you can link it to <code>update-alternatives</code>. For instance, if you have GCC-7 and GCC-10, you can link them with:</p> <pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 7\nsudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 7\nsudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 10\nsudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 10\n</code></pre> <p>You can now use <code>update-alternatives</code> to set your default <code>gcc</code> and <code>g++</code> to a more recent version:</p> <pre><code>update-alternatives --config g++\nupdate-alternatives --config gcc\n</code></pre> Mac Os + Clang <pre><code># download clang\ncurl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz\nmkdir clang\ntar -xvJf clang.tar.xz -C clang\n\n# copy files to /usr/local\ncd clang/clang+llvm-11.0.0-x86_64-apple-darwin\nsudo cp -R * /usr/local/\n\n# update default compiler\nexport CXX=/usr/local/bin/clang++\n</code></pre> Windows + MSVC <ul> <li>Visit the Visual Studio website</li> <li>Download Git from https://git-scm.com/download/win and install it</li> </ul> <p>CMake 3.14+</p> <p>Also check your CMake version is at least 3.14+:</p> Ubuntu + GCC <pre><code>cmake --version\n</code></pre> Mac Os + Clang <pre><code>cmake --version\n</code></pre> Windows + MSVC <pre><code>cmake --version\n</code></pre> <p>If CMake is not installed or its version is older than CMake 3.14, update it with</p> Ubuntu + GCC <pre><code>sudo apt upgrade cmake\n</code></pre> <p>Alternatively, download the most recent version from cmake.org.</p> Mac Os + Clang <pre><code>sudo brew upgrade cmake\n</code></pre> <p>Homebrew</p> <p>If this command fails because you don't have Homebrew on your computer, you can install it with</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n</code></pre> <p>or you can follow the instructions in https://brew.sh.</p> <p>Alternatively, download the most recent version from cmake.org.</p> Windows + MSVC <p>Download the most recent version from cmake.org.</p> <p>Gnuplot 5.2.6+</p> <p>Install Gnuplot 5.2.6+ (Required at runtime)</p> Ubuntu + GCC <pre><code>sudo apt update\nsudo apt install gnuplot\n</code></pre> <p>Or download the latest version from www.gnuplot.info. If you're using an installer, make sure you mark the option \"Add application directory to your PATH environment variable\".</p> Mac Os + Clang <pre><code>sudo brew install gnuplot\n</code></pre> <p>Or download the latest version from www.gnuplot.info. If you're using an installer, make sure you mark the option \"Add application directory to your PATH environment variable\".</p> Windows + MSVC <p>Download Gnuplot from www.gnuplot.info and install it.</p> <p>If you're using the Gnuplot installer, make sure you mark the option \"Add application directory to your PATH environment variable\"</p> <p>Windows Gnuplot Terminals</p> <p>If the Matplot++ examples don't display without console errors and gnuplot running, try to re-install Gnuplot with the wxt terminal.</p> <p>Optional Dependencies</p> <p>The build script will also look for these optional dependencies for manipulating images:</p> <ul> <li>JPEG</li> <li>TIFF</li> <li>ZLIB</li> <li>PNG</li> <li>LAPACK</li> <li>BLAS</li> <li>FFTW</li> <li>OpenCV</li> </ul> <p>Embedded dependencies</p> <p>There are two dependencies in <code>source/3rd_party</code>. These dependencies are bundled, so you don't have to worry about them:</p> <ul> <li>olvb/nodesoup</li> <li>dtschump/CImg</li> </ul> <p>You can define <code>WITH_SYSTEM_NODESOUP=ON</code> or <code>WITH_SYSTEM_CIMG=ON</code> in the cmake command line to use a system-provided version of these dependencies.</p> <p>OpenGL dependencies</p> <p>There's an extra target <code>matplot_opengl</code> with the experimental OpenGL backend. You need to define <code>BUILD_EXPERIMENTAL_OPENGL_BACKEND=ON</code> in the CMake command line to build that target. In that case, the build script will also look for these extra dependencies:</p> <ul> <li>OpenGL</li> <li>GLAD</li> <li>GLFW3</li> </ul> <p>If these dependencies are not found, the build script will download them. In any case, you can install these dependencies with:</p> Ubuntu + GCC <pre><code>sudo apt-get install libglfw3-dev\n</code></pre> Mac Os + Clang <p>Download GLFW3 from https://www.glfw.org</p> Windows + MSVC <p>Download GLFW3 from https://www.glfw.org</p> <p>You can also see all dependencies in <code>source/3rd_party/CMakeLists.txt</code>.</p>"},{"location":"integration/package-managers/arch-linux/","title":"Arch Linux","text":"<p>Matplot++ is available in the Arch User Repository (AUR) as <code>matplotplusplus</code>.</p> <p>Note you can manually install the package by following the instructions on the Arch Wiki or use an AUR helper like <code>yay</code> (recommended for ease of install).</p> <pre><code>yay -S matplotplusplus\n</code></pre> <p>To discuss any issues related to this package refer to the comments section on the AUR page of <code>matplotplusplus</code> here.</p>"},{"location":"integration/package-managers/homebrew/","title":"Homebrew","text":"<p>Mac users can install Matplot++ with Homebrew:</p> <pre><code>brew install matplotplusplus\n</code></pre> <p>This formula is a contribution to Homebrew by Andrew Kane.</p>"},{"location":"integration/package-managers/vcpkg/","title":"Vcpkg","text":"<p>Vcpkg users can install Matplot++ with the matplotplusplus port:</p> <pre><code>vcpkg install matplotplusplus\n</code></pre> <p>This formula is a contribution to vcpkg by @myd7349.</p>"},{"location":"plot-types/contour-plots/contour/","title":"Contour","text":"<pre><code>contour(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_1d x = linspace(-2 * pi, 2 * pi);\n    vector_1d y = linspace(0, 4 * pi);\n    auto [X, Y] = meshgrid(x, y);\n    vector_2d Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    contour(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contour(X, Y, Z, 20);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contour(X, Y, Z, std::vector&lt;double&gt;{1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contour(X, Y, Z, \"--\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    vector_1d x = iota(-3, 0.2, 3);\n    vector_1d y = iota(-3, 0.2, 3);\n    auto [X, Y] = meshgrid(x, y);\n    vector_2d Z = transform(X, Y, [](double x, double y) {\n        return x * exp(-pow(x, 2.) - pow(y, 2.));\n    });\n    contour(X, Y, Z)-&gt;contour_text(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contour(X, Y, Z)-&gt;line_width(3);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    auto c = contour(X, Y, Z);\n    c-&gt;contour_text(true);\n    c-&gt;font_size(15);\n    c-&gt;font_color(\"blue\");\n    c-&gt;font_weight(\"bold\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    for (size_t i = 0; i &lt; Z.size(); ++i) {\n        Z[i][25] = NaN;\n    }\n    contour(X, Y, Z)-&gt;contour_text(true);\n\n    show();\n    return 0;\n}\n</code></pre> <p>All these subcategories depend on the <code>contours</code> type. They also depend on lazy evaluation for generating the contour lines. When the function <code>draw</code> is called in the <code>contours</code> class, it preprocesses all contour lines for a three-dimensional function.</p> <p>Although it is relatively simple to show a heatmap with the values for the -axis, calculating contour lines relative to the -axis is more complex than it might seem at first. We provide the function <code>contourc</code> for calculating contour lines. This function uses an adaptation of the algorithm adopted by Matplotlib.</p> <p>The algorithm creates a quad grid defined by the  and  values. It uses this grid to infer a contour line passing through positions with the same  value. The algorithm sweeps through the grid twice to generate these lines. The first sweep looks for lines that start on the boundaries. The second sweep looks for interior closed loops.</p> <p>Filled contours are closed polygons for pairs of contour levels. Some polygons for filled contours might be holes inside other polygons. The algorithm needs to keep track of these relationships so that we can render the polygons in their accurate order. To avoid an extra step that identifies this relationship between the polygons, the sweeping algorithm already identifies which polygons are holes for each level.</p> <p>Once we find the quads with the contour line, the line is generated by interpolating the  values around that quad.</p>"},{"location":"plot-types/contour-plots/filled-contour/","title":"Filled Contour","text":"<pre><code>contourf(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contourf(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-2 * pi, 2 * pi);\n    std::vector&lt;double&gt; y = linspace(0, 4 * pi);\n    auto [X, Y] = meshgrid(x, y);\n    vector_2d Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    contourf(X, Y, Z, 10);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contourf(X, Y, Z, {2, 3})-&gt;contour_text(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contourf(X, Y, Z, {2});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contourf(X, Y, Z, \"--\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [X, Y, Z] = peaks();\n    contourf(X, Y, Z)-&gt;line_width(3);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/contour-plots/function-contour/","title":"Function Contour","text":"<pre><code>fcontour(f);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = [](double x, double y) { return sin(x) + cos(y); };\n    fcontour(f);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    fcontour([](double x, double y) { return erf(x) + cos(y); },\n             {-5, 0, -5, +5}, iota(-2, 0.5, 2));\n    hold(on);\n    fcontour([](double x, double y) { return sin(x) + cos(y); }, {0, 5, -5, +5},\n             iota(-2, 0.5, 2));\n    hold(off);\n    axis({-5, +5, -5, +5});\n    grid(on);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = [](double x, double y) { return pow(x, 2) - pow(y, 2); };\n    fcontour(f, \"--\")-&gt;line_width(2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    fcontour([](double x, double y) { return sin(x) + cos(y); });\n    hold(on);\n    fcontour([](double x, double y) { return x - y; });\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = [](double x, double y) {\n        return exp(-pow(x / 3, 2) - pow(y / 3, 2)) +\n               exp(-pow(x + 2, 2) - pow(y + 2, 2));\n    };\n    fcontour(f)-&gt;line_width(1).line_style(\"--\").levels({1, 0.9, 0.8, 0.2, 0.1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = [](double x, double y) {\n        return erf(pow(y + 2, 3)) -\n               exp(-0.65 * (pow(x - 2, 2) + pow(y - 2, 2)));\n    };\n    fcontour(f)-&gt;filled(true).colormap_line_when_filled(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = [](double x, double y) {\n        return erf(pow(y + 2, 3)) -\n               exp(-0.65 * (pow(x - 2, 2) + pow(y - 2, 2)));\n    };\n    fcontour(f, 25)-&gt;filled(true).colormap_line_when_filled(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    fcontour([](double x, double y) {\n        return sin(x) + cos(y);\n    })-&gt;levels({-1, 0, +1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto rastrigin = [](double x, double y) {\n        return 10 * 2 + pow(x, 2) - 10 * cos(2 * pi * x) + pow(y, 2) -\n               10 * cos(2 * pi * y);\n    };\n    fcontour(rastrigin)-&gt;filled(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto ackley = [](double x, double y) {\n        return -20 * exp(-0.2 * sqrt(0.5 * (pow(x, 2) + pow(y, 2)))) -\n               exp(0.5 * (cos(2 * pi * x) + cos(2 * pi * y))) + exp(1) + 20;\n    };\n    fcontour(ackley)-&gt;n_levels(50).filled(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto rosenbrock = [](double x, double y) {\n        return 100 * pow(y - pow(x, 2.), 2.) + pow(1. - x, 2.);\n    };\n    fcontour(rosenbrock)-&gt;n_levels(10).filled(true);\n\n    show();\n    return 0;\n}\n</code></pre> <p>By default, the function <code>fcontour</code> will generate 9 contour lines from a lambda function. The functions <code>contour</code> and <code>contourf</code>, on the other hand, plot contour lines and filled contour lines from a grid of data points for , , and .</p>"},{"location":"plot-types/data-distribution/binned-scatter-plots/","title":"Binned Scatter Plots","text":"<pre><code>binscatter(x,y);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure();\n    f-&gt;width(f-&gt;width() * 2);\n\n    auto x_reduced = randn(1000, 0, 1);\n    auto y_reduced =\n        transform(x_reduced, [](double x) { return 2 * x + randn(0, 1); });\n    auto ax1 = subplot(1, 2, 0);\n    scatter(ax1, x_reduced, y_reduced);\n    title(ax1, \"Scatter plot (n=1000)\");\n\n    auto x = randn(1000000, 0., 1.);\n    auto y = transform(x, [](double x) { return 2 * x + randn(0, 1); });\n    auto ax2 = subplot(1, 2, 1);\n    binscatter(ax2, x, y);\n    axis(tight);\n    title(ax2, \"Binned Scatter plot (n=1000000)\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n\n    f-&gt;width(f-&gt;width() * 2);\n    f-&gt;height(f-&gt;height() * 2);\n    f-&gt;x_position(200);\n    f-&gt;y_position(100);\n\n    auto x = randn(1000000, 0., 1.);\n    auto y = transform(x, [](double x) { return 2 * x + randn(0, 1); });\n    std::vector&lt;double&gt; x_line(x.begin(), x.begin() + 1000);\n    std::vector&lt;double&gt; y_line(y.begin(), y.begin() + 1000);\n\n    subplot(2, 3, 0);\n    scatter(x_line, y_line);\n    title(\"Scatter\");\n\n    subplot(2, 3, 1);\n    binscatter(x, y, bin_scatter_style::point_size);\n    title(\"Bin Scatter: Point size\");\n\n    subplot(2, 3, 2);\n    binscatter(x, y, bin_scatter_style::point_alpha);\n    title(\"Bin Scatter: Point alpha\");\n\n    subplot(2, 3, 3);\n    binscatter(x, y, bin_scatter_style::point_colormap);\n    title(\"Bin Scatter: Colormap\");\n\n    subplot(2, 3, 4);\n    binscatter(x, y, bin_scatter_style::heatmap);\n    axis(tight);\n    title(\"Bin Scatter: Heatmap\");\n\n    subplot(2, 3, 5);\n    binscatter(x, y, bin_scatter_style::jitter);\n    title(\"Bin Scatter: Jitter\");\n\n    f-&gt;show();\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n    f-&gt;width(f-&gt;width() * 2);\n    f-&gt;height(f-&gt;height() * 2);\n    f-&gt;x_position(200);\n    f-&gt;y_position(100);\n\n    auto x = randn(1000000, 0., 1.);\n    auto y = transform(x, [](double x) { return 2 * x + randn(0, 1); });\n\n    bin_scatter_style b = bin_scatter_style::automatic;\n\n    subplot(2, 3, 0);\n    binscatter(x, y, histogram::binning_algorithm::automatic, b);\n    axis(tight);\n    title(\"Automatic\");\n\n    subplot(2, 3, 1);\n    binscatter(x, y, histogram::binning_algorithm::integers, b);\n    axis(tight);\n    title(\"Integers\");\n\n    subplot(2, 3, 2);\n    binscatter(x, y, histogram::binning_algorithm::scott, b);\n    axis(tight);\n    title(\"Scott's rule\");\n\n    subplot(2, 3, 3);\n    binscatter(x, y, histogram::binning_algorithm::fd, b);\n    axis(tight);\n    title(\"Freedman-Diaconis rule\");\n\n    subplot(2, 3, 4);\n    binscatter(x, y, histogram::binning_algorithm::sqrt, b);\n    axis(tight);\n    title(\"Square root rule\");\n\n    subplot(2, 3, 5);\n    binscatter(x, y, histogram::binning_algorithm::sturges, b);\n    axis(tight);\n    title(\"Sturges' rule\");\n\n    f-&gt;show();\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n    f-&gt;width(f-&gt;width() * 2);\n    f-&gt;height(f-&gt;height() * 2);\n    f-&gt;x_position(200);\n    f-&gt;y_position(100);\n\n    auto x = randn(1000000, 0., 1.);\n    auto y = transform(x, [](double x) { return 2 * x + randn(0, 1); });\n\n    bin_scatter_style b = bin_scatter_style::heatmap;\n    histogram::binning_algorithm a = histogram::binning_algorithm::automatic;\n\n    subplot(2, 3, 0);\n    binscatter(x, y, a, b, histogram::normalization::count);\n    axis(tight);\n    title(\"Normalization: Count\");\n\n    subplot(2, 3, 1);\n    binscatter(x, y, a, b, histogram::normalization::probability);\n    axis(tight);\n    title(\"Normalization: Probability\");\n\n    subplot(2, 3, 2);\n    binscatter(x, y, a, b, histogram::normalization::cummulative_count);\n    axis(tight);\n    title(\"Normalization: Cummulative count\");\n\n    subplot(2, 3, 3);\n    binscatter(x, y, a, b, histogram::normalization::count_density);\n    axis(tight);\n    title(\"Normalization: Count density\");\n\n    subplot(2, 3, 4);\n    binscatter(x, y, a, b, histogram::normalization::pdf);\n    axis(tight);\n    title(\"Normalization: PDF\");\n\n    subplot(2, 3, 5);\n    binscatter(x, y, a, b, histogram::normalization::cdf);\n    axis(tight);\n    title(\"Normalization: CDF\");\n\n    f-&gt;show();\n\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = figure(true);\n    f-&gt;width(f-&gt;width() * 2);\n    f-&gt;height(f-&gt;height() * 2);\n    f-&gt;x_position(200);\n    f-&gt;y_position(100);\n    f-&gt;quiet_mode(true);\n\n    auto x = randn(10000, 0., 1.);\n    auto y = randn(10000, 0., 1.);\n\n    subplot(2, 3, 0);\n    scatter(x, y);\n    title(\"Scatter plot\");\n\n    subplot(2, 3, 1);\n    binscatter(x, y, 30, 10, bin_scatter_style::point_size);\n    title(\"Binned scatter plot: Point size\");\n\n    subplot(2, 3, 2);\n    binscatter(x, y, 30, 10, bin_scatter_style::point_alpha);\n    title(\"Binned scatter plot: Point alpha\");\n\n    subplot(2, 3, 3);\n    binscatter(x, y, 30, 10, bin_scatter_style::jitter);\n    title(\"Binned scatter plot: Jitter\");\n\n    subplot(2, 3, 4);\n    binscatter(x, y, 30, 10, bin_scatter_style::point_colormap);\n    title(\"Binned scatter plot: Colormap\");\n\n    subplot(2, 3, 5);\n    binscatter(x, y, 30, 10, bin_scatter_style::heatmap);\n    title(\"Binned scatter plot: Heatmap\");\n    axis(tight);\n\n    f-&gt;draw();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = randn(100000, 0., 1.);\n    auto y = randn(100000, 0., 1.);\n\n    binscatter(x, y, bin_scatter_style::point_colormap);\n    colormap(gca(), palette::parula());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = randn(100000, 0., 1.);\n    auto y = randn(100000, 0., 1.);\n\n    binscatter(x, y, 20, 30, bin_scatter_style::heatmap);\n    axis(tight);\n\n    show();\n    return 0;\n}\n</code></pre> <p>Binned scatter plots use variations of the histogram algorithms of the previous section as an extra step to place all the data into two-dimensional bins that can be represented with varying colors or sizes. This is useful when there are so many data points that a scatter plot would be impractical for visualizing the data.</p>"},{"location":"plot-types/data-distribution/boxplot/","title":"Boxplot","text":"<pre><code>boxplot(data);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; mpg = {\n        18,   15,   18,   16, 17, 15,   14, 14,   14, 15, 15,   14,\n        15,   14,   24,   22, 18, 21,   27, 26,   25, 24, 25,   26,\n        21,   10,   10,   11, 9,  28,   25, 25,   26, 27, 17.5, 16,\n        15.5, 14.5, 22,   22, 24, 22.5, 29, 24.5, 29, 33, 20,   18,\n        18.5, 17.5, 29.5, 32, 28, 26.5, 20, 13,   19, 19, 16.5, 16.5,\n        13,   13,   13,   28, 27, 34,   31, 29,   27, 24, 23,   36,\n        37,   31,   38,   36, 36, 36,   34, 38,   32, 38, 25,   38,\n        26,   22,   32,   36, 27, 27,   44, 32,   28, 31};\n\n    boxplot(mpg);\n    xlabel(\"All Vehicles\");\n    ylabel(\"Miles per Gallon (MPG)\");\n    title(\"Miles per Gallon for All Vehicles\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; mpg = {\n        18,   15,   18,   16, 17, 15,   14, 14,   14, 15, 15,   14,\n        15,   14,   24,   22, 18, 21,   27, 26,   25, 24, 25,   26,\n        21,   10,   10,   11, 9,  28,   25, 25,   26, 27, 17.5, 16,\n        15.5, 14.5, 22,   22, 24, 22.5, 29, 24.5, 29, 33, 20,   18,\n        18.5, 17.5, 29.5, 32, 28, 26.5, 20, 13,   19, 19, 16.5, 16.5,\n        13,   13,   13,   28, 27, 34,   31, 29,   27, 24, 23,   36,\n        37,   31,   38,   36, 36, 36,   34, 38,   32, 38, 25,   38,\n        26,   22,   32,   36, 27, 27,   44, 32,   28, 31};\n\n    std::vector&lt;std::string&gt; origin = {\n        \"USA\",     \"USA\",     \"USA\",     \"USA\",   \"USA\",   \"USA\",     \"USA\",\n        \"USA\",     \"USA\",     \"USA\",     \"USA\",   \"USA\",   \"USA\",     \"USA\",\n        \"Japan\",   \"USA\",     \"USA\",     \"USA\",   \"Japan\", \"Germany\", \"France\",\n        \"Germany\", \"Sweden\",  \"Germany\", \"USA\",   \"USA\",   \"USA\",     \"USA\",\n        \"USA\",     \"Italy\",   \"Germany\", \"USA\",   \"USA\",   \"France\",  \"USA\",\n        \"USA\",     \"USA\",     \"USA\",     \"USA\",   \"USA\",   \"USA\",     \"USA\",\n        \"USA\",     \"USA\",     \"Germany\", \"Japan\", \"USA\",   \"USA\",     \"USA\",\n        \"USA\",     \"Germany\", \"Japan\",   \"Japan\", \"USA\",   \"Sweden\",  \"USA\",\n        \"France\",  \"Japan\",   \"Germany\", \"USA\",   \"USA\",   \"USA\",     \"USA\",\n        \"USA\",     \"USA\",     \"USA\",     \"USA\",   \"USA\",   \"USA\",     \"USA\",\n        \"USA\",     \"Germany\", \"Japan\",   \"Japan\", \"USA\",   \"USA\",     \"Japan\",\n        \"Japan\",   \"Japan\",   \"Japan\",   \"Japan\", \"Japan\", \"USA\",     \"USA\",\n        \"USA\",     \"USA\",     \"Japan\",   \"USA\",   \"USA\",   \"USA\",     \"Germany\",\n        \"USA\",     \"USA\",     \"USA\"};\n\n    boxplot(mpg, origin);\n    xlabel(\"All Vehicles\");\n    ylabel(\"Miles per Gallon (MPG)\");\n    title(\"Miles per Gallon for All Vehicles\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; x(25);\n    for (auto &amp;xi : x) {\n        xi = randn(100, 0, 1);\n    }\n\n    subplot(2, 1, 0);\n    boxplot(x);\n\n    subplot(2, 1, 1);\n    boxplot(x)-&gt;box_style(box_chart::box_style_option::outline);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/data-distribution/heatmap/","title":"Heatmap","text":"<pre><code>heatmap(data);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {45, 60, 32}, {43, 54, 76}, {32, 94, 68}, {23, 95, 58}};\n    heatmap(data);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {24, 10}, {10, 5}, {24, 16}, {8, 3}};\n    heatmap(data);\n    title(\"Count of SelfAssessedHealthStatus vs. Smoker\");\n    auto ax = gca();\n    ax-&gt;x_axis().ticklabels({\"false\", \"true\"});\n    ax-&gt;y_axis().ticklabels({\"Excellent\", \"Fair\", \"Good\", \"Poor\"});\n    xlabel(ax, \"Smoker\");\n    ylabel(ax, \"SelfAssessedHealthStatus\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {38.46, 39}, {39.7, 36.2}, {38.13, 38.88}, {33.88, 43}};\n    heatmap(data);\n    title(\"Mean of Age\");\n    auto ax = gca();\n    ax-&gt;x_axis().ticklabels({\"false\", \"true\"});\n    ax-&gt;y_axis().ticklabels({\"Excellent\", \"Fair\", \"Good\", \"Poor\"});\n    xlabel(ax, \"Smoker\");\n    ylabel(ax, \"SelfAssessedHealthStatus\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {45, 60, 32}, {43, 54, 76}, {32, 94, 68}, {23, 95, 58}};\n    heatmap(data);\n    title(\"T-Shirt Orders\");\n    auto ax = gca();\n    ax-&gt;x_axis().ticklabels({\"Small\", \"Medium\", \"Large\"});\n    ax-&gt;y_axis().ticklabels({\"Green\", \"Red\", \"Blue\", \"Gray\"});\n    xlabel(ax, \"Sizes\");\n    ylabel(ax, \"Colors\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {12, 135, 20, 0, 127}, {0, 1, 0, 0, 1},  {19, 31, 81, 8, 49},\n        {9, 18, 42, 2, 85},    {0, 5, 3, 0, 17}, {31, 143, 135, 6, 23},\n        {32, 102, 54, 6, 7},   {5, 11, 4, 0, 4}, {16, 41, 13, 3, 22},\n        {18, 70, 37, 1, 19}};\n    heatmap(data);\n    title(\"Count of Cause vs. Region\");\n    auto ax = gca();\n    ax-&gt;x_axis().ticklabels(\n        {\"MidWest\", \"NorthEast\", \"SouthEast\", \"SouthWest\", \"West\"});\n    ax-&gt;y_axis().ticklabels(\n        {\"Attack\", \"Earthquake\", \"Energy emergency\", \"Equipment fault\", \"Fire\",\n         \"Severe Storm\", \"Thunder Storm\", \"Unknown\", \"Wind\", \"Winter Storm\"});\n    xlabel(ax, \"Region\");\n    ylabel(ax, \"Cause\");\n    float w = ax-&gt;width();\n    ax-&gt;width(w * 0.85f);\n    ax-&gt;x_origin(ax-&gt;x_origin() + w * 0.1f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {12, 135, 20, 0, 127}, {0, 1, 0, 0, 1},  {19, 31, 81, 8, 49},\n        {9, 18, 42, 2, 85},    {0, 5, 3, 0, 17}, {31, 143, 135, 6, 23},\n        {32, 102, 54, 6, 7},   {5, 11, 4, 0, 4}, {16, 41, 13, 3, 22},\n        {18, 70, 37, 1, 19}};\n\n    heatmap(data)-&gt;normalization(matrix::color_normalization::columns);\n\n    title(\"Count of Cause vs. Region\");\n    auto ax = gca();\n    ax-&gt;x_axis().ticklabels(\n        {\"MidWest\", \"NorthEast\", \"SouthEast\", \"SouthWest\", \"West\"});\n    ax-&gt;y_axis().ticklabels(\n        {\"Attack\", \"Earthquake\", \"Energy emergency\", \"Equipment fault\", \"Fire\",\n         \"Severe Storm\", \"Thunder Storm\", \"Unknown\", \"Wind\", \"Winter Storm\"});\n    xlabel(ax, \"Region\");\n    ylabel(ax, \"Cause\");\n    float w = ax-&gt;width();\n    ax-&gt;width(w * 0.85f);\n    ax-&gt;x_origin(ax-&gt;x_origin() + w * 0.1f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; data = {\n        {12, 135, 20, 0, 127}, {0, 1, 0, 0, 1},  {19, 31, 81, 8, 49},\n        {9, 18, 42, 2, 85},    {0, 5, 3, 0, 17}, {31, 143, 135, 6, 23},\n        {32, 102, 54, 6, 7},   {5, 11, 4, 0, 4}, {16, 41, 13, 3, 22},\n        {18, 70, 37, 1, 19}};\n\n    heatmap(data)-&gt;normalization(matrix::color_normalization::rows);\n\n    title(\"Count of Cause vs. Region\");\n    auto ax = gca();\n    ax-&gt;x_axis().ticklabels(\n        {\"MidWest\", \"NorthEast\", \"SouthEast\", \"SouthWest\", \"West\"});\n    ax-&gt;y_axis().ticklabels(\n        {\"Attack\", \"Earthquake\", \"Energy emergency\", \"Equipment fault\", \"Fire\",\n         \"Severe Storm\", \"Thunder Storm\", \"Unknown\", \"Wind\", \"Winter Storm\"});\n    xlabel(ax, \"Region\");\n    ylabel(ax, \"Cause\");\n    float w = ax-&gt;width();\n    ax-&gt;width(w * 0.85f);\n    ax-&gt;x_origin(ax-&gt;x_origin() + w * 0.1f);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/data-distribution/histogram/","title":"Histogram","text":"<p>The <code>histogram</code> object creates the histogram edges and bins when the <code>draw</code> function is called for the first time with lazy evaluation. Lazy evaluation avoids calculating edges unnecessarily in case the user changes the object parameters before calling <code>draw</code>. This object includes several algorithms for automatically delimiting the edges and bins for the histograms.</p> <pre><code>hist(data);\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(10000, 0, 1);\n\n    auto h = hist(x);\n    std::cout &lt;&lt; \"Histogram with \" &lt;&lt; h-&gt;num_bins() &lt;&lt; \" bins\" &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(10000, 0, 1);\n\n    subplot(2, 3, 0);\n    hist(x, histogram::binning_algorithm::automatic);\n    title(\"Automatic binning\");\n\n    subplot(2, 3, 1);\n    hist(x, histogram::binning_algorithm::scott);\n    title(\"Scott's rule\");\n\n    subplot(2, 3, 2);\n    hist(x, histogram::binning_algorithm::fd);\n    title(\"Freedman-Diaconis rule\");\n\n    subplot(2, 3, 3);\n    hist(x, histogram::binning_algorithm::integers);\n    title(\"Integers rule\");\n\n    subplot(2, 3, 4);\n    hist(x, histogram::binning_algorithm::sturges);\n    title(\"Sturges' rule\");\n\n    subplot(2, 3, 5);\n    hist(x, histogram::binning_algorithm::sqrt);\n    title(\"Square root rule\");\n\n    save(\"histogram_2.svg\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(10000, 0, 1);\n\n    subplot(2, 3, 0);\n    auto a = histogram::binning_algorithm::automatic;\n    hist(x, a, histogram::normalization::count);\n    title(\"Count (c_i)\");\n\n    subplot(2, 3, 1);\n    hist(x, a, histogram::normalization::probability);\n    title(\"Probability (c_i/N)\");\n\n    subplot(2, 3, 2);\n    hist(x, a, histogram::normalization::cummulative_count);\n    title(\"Cummulative count (\u2211_{j=1}^i c_j)\");\n\n    subplot(2, 3, 3);\n    hist(x, a, histogram::normalization::count_density);\n    title(\"Count density (c_i/w_i)\");\n\n    subplot(2, 3, 4);\n    hist(x, a, histogram::normalization::pdf);\n    title(\"PDF (c_i/(N w_i))\");\n\n    subplot(2, 3, 5);\n    hist(x, a, histogram::normalization::cdf);\n    title(\"CDF (\u2211_{j=1}^i c_j/N)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(1000, 0, 1);\n\n    size_t num_bins = 25;\n    auto h = hist(x, num_bins);\n\n    auto v_it = h-&gt;values().begin();\n    auto e_it = h-&gt;bin_edges().begin();\n    while (v_it != h-&gt;values().end()) {\n        std::cout &lt;&lt; \"[\" &lt;&lt; *e_it &lt;&lt; \";\" &lt;&lt; *std::next(e_it)\n                  &lt;&lt; \"] - count: \" &lt;&lt; *v_it &lt;&lt; std::endl;\n        ++v_it;\n        ++e_it;\n    }\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(1000, 0, 1);\n\n    auto h = hist(x);\n    title(num2str(h-&gt;num_bins()) + \" bins\");\n\n    for (size_t i = 0; i &lt; 5; ++i) {\n        std::this_thread::sleep_for(std::chrono::seconds(3));\n        title(num2str(h-&gt;num_bins()) + \" bins\");\n    }\n\n    h-&gt;num_bins(50);\n    title(num2str(h-&gt;num_bins()) + \" bins\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(10000, 0, 1);\n\n    std::vector&lt;double&gt; edges = {-10.0000, -2.0000, -1.7500, -1.5000, -1.2500,\n                                 -1.0000,  -0.7500, -0.5000, -0.2500, 0,\n                                 0.2500,   0.5000,  0.7500,  1.0000,  1.2500,\n                                 1.5000,   1.7500,  2.0000,  10.0000};\n\n    hist(x, edges)-&gt;normalization(histogram::normalization::count_density);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::string&gt; categories = {\n        \"no\", \"no\",  \"yes\",       \"yes\",       \"yes\", \"no\",  \"no\",\n        \"no\", \"no\",  \"undecided\", \"undecided\", \"yes\", \"no\",  \"no\",\n        \"no\", \"yes\", \"no\",        \"yes\",       \"no\",  \"yes\", \"no\",\n        \"no\", \"no\",  \"yes\",       \"yes\",       \"yes\", \"yes\"};\n    hist(categories)-&gt;bar_width(0.5);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(10000, 0, 1);\n\n    auto h = hist(x, histogram::normalization::probability);\n    std::cout &lt;&lt; \"Sum of bar heights: \"\n              &lt;&lt; std::accumulate(h-&gt;values().begin(), h-&gt;values().end(), 0.0)\n              &lt;&lt; std::endl;\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(2000, 0, 1);\n    std::vector&lt;double&gt; y = randn(5000, 1, 1);\n\n    auto h1 = hist(x);\n    hold(on);\n    auto h2 = hist(y);\n    h1-&gt;normalization(histogram::normalization::probability);\n    h1-&gt;bin_width(0.25);\n    h2-&gt;normalization(histogram::normalization::probability);\n    h2-&gt;bin_width(0.25);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(1000, 0, 1);\n\n    auto h = hist(x);\n    h-&gt;num_bins(15);\n    h-&gt;bin_edges(iota(-3, 3));\n    h-&gt;face_color({0., 0., 0.5, 0.5});\n    h-&gt;edge_color(\"r\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(5000, 5, 2);\n\n    auto h = hist(x);\n    h-&gt;normalization(histogram::normalization::pdf);\n    hold(on);\n\n    double mu = 5;\n    double sigma = 2;\n    auto f = [&amp;](double y) {\n        return exp(-pow((y - mu), 2.) / (2. * pow(sigma, 2.))) /\n               (sigma * sqrt(2. * pi));\n    };\n    fplot(f, std::array&lt;double, 2&gt;{-5, 15})-&gt;line_width(1.5);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = randn(1000, 0, 1);\n\n    auto h = hist(x);\n    title(num2str(h-&gt;num_bins()) + \" bins\");\n\n    for (size_t i = 0; i &lt; 5; ++i) {\n        std::this_thread::sleep_for(std::chrono::seconds(3));\n        title(num2str(h-&gt;num_bins()) + \" bins\");\n    }\n\n    h-&gt;num_bins(5);\n    title(num2str(h-&gt;num_bins()) + \" bins\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nconstexpr size_t DEFAULT_BOOTSTRAP_REPLICATES = 1000000;\n\nstd::vector&lt;double&gt;\nbootstrap(std::function&lt;double()&gt; statistic,\n          size_t replicates = DEFAULT_BOOTSTRAP_REPLICATES) {\n    std::vector&lt;double&gt; data(replicates);\n    std::generate(data.begin(), data.end(), statistic);\n    return data;\n}\n\nstd::vector&lt;double&gt;\nbootstrap(std::function&lt;double(std::vector&lt;double&gt;)&gt; statistic,\n          std::function&lt;double()&gt; data_source, size_t sample_size,\n          size_t replicates = DEFAULT_BOOTSTRAP_REPLICATES) {\n    std::vector&lt;double&gt; data(replicates);\n    return bootstrap(\n        [&amp;]() {\n            std::vector&lt;double&gt; data(sample_size);\n            std::generate(data.begin(), data.end(), data_source);\n            return statistic(data);\n        },\n        replicates);\n}\n\ntemplate &lt;typename NUMBER&gt; double mean(const std::vector&lt;NUMBER&gt; &amp;v) {\n    double sum = 0.0;\n    for (const auto &amp;item : v) {\n        sum += static_cast&lt;double&gt;(item);\n    }\n    return sum / static_cast&lt;double&gt;(v.size());\n}\n\nint main() {\n    // Example bootstraping from many distributions.\n    // Distributions:\n    // https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/\n    using namespace matplot;\n\n    auto f = figure(true);\n    f-&gt;width(f-&gt;width() * 3);\n    f-&gt;height(f-&gt;height() * 2);\n    f-&gt;x_position(10);\n    f-&gt;y_position(10);\n\n    enum histogram::normalization norm = histogram::normalization::probability;\n    enum histogram::binning_algorithm alg =\n        histogram::binning_algorithm::automatic;\n    const size_t n_bins = 200;\n    const float hist_alpha = 0.7f;\n    std::default_random_engine r;\n    std::mt19937 generator(r());\n\n    std::cout &lt;&lt; \"Averages - Normal\" &lt;&lt; std::endl;\n    subplot(2, 3, 0);\n    title(\"Average - Normal / Gaussian - mean(x)= {\u2211 x_i}/{n} - x_i = N(0,1)\");\n    xlim({-4, 4});\n    legend();\n    std::normal_distribution&lt;double&gt; d(0, 1);\n    std::function&lt;double()&gt; normal_data_source = [&amp;]() { return d(generator); };\n    hist(bootstrap(mean&lt;double&gt;, normal_data_source, 1), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"1 sample\");\n    f-&gt;draw();\n    hold(on);\n    hist(bootstrap(mean&lt;double&gt;, normal_data_source, 2), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"2 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, normal_data_source, 5), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"5 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, normal_data_source, 10), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"10 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, normal_data_source, 30), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"30 samples\");\n    f-&gt;draw();\n    xlabel(\"Value\");\n    ylabel(\"Frequency\");\n\n    std::cout &lt;&lt; \"Averages - Uniform\" &lt;&lt; std::endl;\n    subplot(2, 3, 1);\n    title(\"Average - Uniform - mean(x)= {\u2211 x_i}/{n} - x_i = U(-1;+1)\");\n    xlim({-1, 1});\n    legend();\n    std::uniform_real_distribution&lt;double&gt; u(-1.0, 1.0);\n    std::function&lt;double()&gt; uniform_data_source = [&amp;]() {\n        return u(generator);\n    };\n    hist(bootstrap(mean&lt;double&gt;, uniform_data_source, 1), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"1 sample\");\n    f-&gt;draw();\n    hold(on);\n    hist(bootstrap(mean&lt;double&gt;, uniform_data_source, 2), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"2 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, uniform_data_source, 5), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"5 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, uniform_data_source, 10), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"10 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, uniform_data_source, 30), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"30 samples\");\n    f-&gt;draw();\n    xlabel(\"Value\");\n    ylabel(\"Frequency\");\n\n    std::cout &lt;&lt; \"Sum of squares - Chi-squared distribution\" &lt;&lt; std::endl;\n    subplot(2, 3, 2);\n    title(\"Sum of Squares - Chi-Squared - \u2211 (x_i - mean(x))^2\");\n    xlim({0, 5});\n    legend();\n    double m = 0;\n    auto chi2_data_source = [&amp;]() {\n        return pow(normal_data_source() - m, 2.0);\n    };\n    hist(bootstrap(mean&lt;double&gt;, chi2_data_source, 1), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"1 sample\");\n    f-&gt;draw();\n    hold(on);\n    hist(bootstrap(mean&lt;double&gt;, chi2_data_source, 2), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"2 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, chi2_data_source, 5), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"5 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, chi2_data_source, 10), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"10 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, chi2_data_source, 30), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"30 samples\");\n    f-&gt;draw();\n    // xlim({0,50});\n    xlabel(\"Value\");\n    ylabel(\"Frequency\");\n\n    std::cout &lt;&lt; \"Square root of sum of squares (Chi distribution)\"\n              &lt;&lt; std::endl;\n    subplot(2, 3, 3);\n    title(\"Square Root of Sum of Squares - Chi - \u221a{\u2211 (x_i - mean(x))^2}\");\n    xlim({0, 4});\n    legend();\n    auto chi_data_source = [&amp;]() { return sqrt(chi2_data_source()); };\n    hist(bootstrap(mean&lt;double&gt;, chi_data_source, 1), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"1 sample\");\n    f-&gt;draw();\n    hold(on);\n    hist(bootstrap(mean&lt;double&gt;, chi_data_source, 2), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"2 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, chi_data_source, 5), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"5 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, chi_data_source, 10), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"10 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, chi_data_source, 30), n_bins)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"30 samples\");\n    f-&gt;draw();\n    xlabel(\"Value\");\n    ylabel(\"Frequency\");\n\n    std::cout &lt;&lt; \"Ratio of scaled sums of squares / variance (F distribution)\"\n              &lt;&lt; std::endl;\n    subplot(2, 3, 4);\n    title(\"Variance ratio - F - \u03c3_1 / \u03c3_2\");\n    legend();\n    m = 0.0;\n    auto ratio_ss = [&amp;]() { return chi2_data_source() / chi2_data_source(); };\n    xlim({0, 5});\n    std::vector&lt;double&gt; edges = linspace(0, 10, n_bins);\n    hist(bootstrap(mean&lt;double&gt;, ratio_ss, 1), edges)\n        -&gt;bin_limits_min(0)\n        .bin_limits_max(5)\n        .normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"1 sample\");\n    f-&gt;draw();\n    hold(on);\n    hist(bootstrap(mean&lt;double&gt;, ratio_ss, 2), edges)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"2 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, ratio_ss, 5), edges)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"5 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, ratio_ss, 10), edges)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"10 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, ratio_ss, 30), edges)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"30 samples\");\n    f-&gt;draw();\n    xlabel(\"Value\");\n    ylabel(\"Frequency\");\n\n    std::cout &lt;&lt; \"Averages - Bernoulli\" &lt;&lt; std::endl;\n    subplot(2, 3, 5);\n    title(\"Average - Bernoulli - mean(x)= {\u2211 x_i}/{n} - x_i = B(1/6)\");\n    xlim({0, 1});\n    legend();\n    std::bernoulli_distribution b(1. / 6.);\n    std::function&lt;double()&gt; bernoulli_data_source = [&amp;]() {\n        return static_cast&lt;double&gt;(b(generator));\n    };\n    hist(bootstrap(mean&lt;double&gt;, bernoulli_data_source, 1), 4)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"1 sample\");\n    f-&gt;draw();\n    hold(on);\n    hist(bootstrap(mean&lt;double&gt;, bernoulli_data_source, 5), 6)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"5 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, bernoulli_data_source, 30), 10)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"30 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, bernoulli_data_source, 300, 100000), 50)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"300 samples\");\n    f-&gt;draw();\n    hist(bootstrap(mean&lt;double&gt;, bernoulli_data_source, 3000, 10000), 50)\n        -&gt;normalization(norm)\n        .algorithm(alg)\n        .edge_alpha(1.0)\n        .face_alpha(hist_alpha)\n        .display_name(\"3000 samples\");\n    f-&gt;draw();\n    xlabel(\"Value\");\n    ylabel(\"Frequency\");\n\n    //    save(\"distributions.png\");\n    //    save(\"distributions.pdf\");\n    //    save(\"distributions.eps\");\n    //    save(\"distributions.gif\");\n    //    save(\"distributions.jpg\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/data-distribution/parallel-coordinates/","title":"Parallel Coordinates","text":"<pre><code>parallelplot(X);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(3);\n    X[0] = concat(rand(50, 78, 100), rand(50, 65, 91));\n    X[1] = concat(std::vector&lt;double&gt;(50, 1), std::vector&lt;double&gt;(50, 0));\n    X[2] = concat(rand(50, 122, 140), rand(50, 105, 131));\n\n    auto p = parallelplot(X);\n\n    gca()-&gt;x_axis().tick_values({1, 2, 3});\n    gca()-&gt;x_axis().ticklabels({\"f_1\", \"f_2\", \"f_3\"});\n\n    p-&gt;axis()[1].tick_values({0, 1});\n    p-&gt;axis()[1].ticklabels({\"false\", \"true\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(4);\n    X[0] = concat(rand(50, 78, 200), rand(50, 65, 91));\n    X[1] = concat(std::vector&lt;double&gt;(50, 1), std::vector&lt;double&gt;(50, 0));\n    X[2] = concat(rand(50, 122, 140), rand(50, 105, 131));\n    X[3] =\n        concat(concat(std::vector&lt;double&gt;(25, 3), std::vector&lt;double&gt;(50, 1)),\n               std::vector&lt;double&gt;(25, 2));\n\n    auto p = parallelplot(X, X[3]);\n\n    gca()-&gt;x_axis().tick_values({1, 2, 3, 4});\n    gca()-&gt;x_axis().ticklabels({\"f_1\", \"f_2\", \"f_3\", \"f_4\"});\n\n    p-&gt;axis()[1].tick_values({0, 1});\n    p-&gt;axis()[1].ticklabels({\"false\", \"true\"});\n\n    p-&gt;axis()[3].tick_values({1, 2, 3});\n    p-&gt;axis()[3].ticklabels({\"low\", \"medium\", \"high\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(4);\n    X[0] = randn(100, 50, 200);\n    X[1] = transform(X[0], [](double x) { return x + rand(-30, +30); });\n    X[2] = transform(X[0], [](double x) { return x &gt; 50 ? +1. : -1.; });\n    std::generate(X[3].begin(), X[3].end(),\n                  []() { return cos(rand(-30, +30)); });\n\n    auto colors = X[2];\n    parallelplot(X, colors);\n\n    show();\n    return 0;\n}\n</code></pre> <p>The function <code>parallelplot</code> creates a plot with Parallel Coordinates. In this type of plot, a <code>parallel lines</code> object stores an arbitrary set of <code>axis</code> objects to represent multi-dimensional data. </p>"},{"location":"plot-types/data-distribution/pie-chart/","title":"Pie Chart","text":"<pre><code>pie(x);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {1, 3, 0.5, 2.5, 2};\n    pie(x);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {1, 3, 0.5, 2.5, 2};\n    std::vector&lt;double&gt; explode = {0, 1, 0, 1, 0};\n    pie(x, explode);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(1, 3);\n    std::vector&lt;std::string&gt; labels = {\"Taxes\", \"Expenses\", \"Profit\"};\n    pie(x, labels);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {0.19, 0.22, 0.41};\n    pie(x);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y2010 = {50, 0, 100, 95};\n    std::vector&lt;double&gt; y2011 = {65, 22, 97, 120};\n    std::vector&lt;std::string&gt; labels = {\"Investments\", \"Cash\", \"Operations\",\n                                       \"Sales\"};\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    pie(ax1, y2010);\n    title(\"2010\");\n\n    auto ax2 = nexttile();\n    pie(ax2, y2011);\n    title(\"2011\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {17, 33, 33, 17};\n    std::vector&lt;double&gt; explode = {0, 1, 1, 0};\n    std::vector&lt;std::string&gt; labels = {\"East (17%)\", \"North (33%)\",\n                                       \"South (33%)\", \"West (17%)\"};\n\n    pie(x, explode, labels);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/data-distribution/plot-matrix/","title":"Plot Matrix","text":"<pre><code>plotmatrix(X);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X = {randn(50, 0, 1), randn(50, 0, 1),\n                                          randn(50, 0, 1)};\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {iota(1, 50), iota(51, 100),\n                                          iota(101, 150)};\n    plotmatrix(X, Y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X = {randn(200, 0, 1), randn(200, 0, 1),\n                                          randn(200, 0, 1)};\n    plotmatrix(X);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X = {randn(200, 0, 1), randn(200, 0, 1),\n                                          randn(200, 0, 1)};\n    plotmatrix(X, \"*r\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; X = {randn(100, 0, 1), randn(100, 0, 1),\n                                          randn(100, 0, 1)};\n\n    auto [S, H, axs] = plotmatrix(X);\n    S[2][0]-&gt;color(\"g\");\n    S[2][0]-&gt;marker(\"*\");\n    H[2]-&gt;edge_color(\"k\");\n    H[2]-&gt;face_color(\"g\");\n    axs[0][1]-&gt;title(\"A Comparison of Data Sets\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>The Plot Matrix subcategory is a combination of histograms and scatter plots. It creates a matrix of <code>axes</code> objects on the <code>figure</code> and creates a scatter plot for each pair of data sets.</p>"},{"location":"plot-types/data-distribution/scatter-plot-3d/","title":"Scatter Plot 3D","text":"<pre><code>scatter(x,y,z);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data();\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = generate_data();\n    scatter3(x, y, z);\n\n    show();\n    return 0;\n}\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data() {\n    using namespace matplot;\n    int n = 16;\n    auto r = iota(static_cast&lt;double&gt;(-n), 2., static_cast&lt;double&gt;(n));\n    auto theta = transform(r, [n](double x) { return x / n * pi; });\n    auto phi = transform(r, [n](double x) { return x / n * pi / 2.; });\n    auto sinphi = transform(phi, [](double x) { return sin(x); });\n    auto cosphi = transform(phi, [](double x) { return cos(x); });\n    cosphi.front() = 0;\n    cosphi.back() = 0;\n    auto sintheta = transform(theta, [](double x) { return sin(x); });\n    sintheta.front() = 0;\n    sintheta.back() = 0;\n    auto costheta = transform(theta, [](double x) { return cos(x); });\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Z(17, std::vector&lt;double&gt;(17, 0.));\n    for (int i = 0; i &lt; n + 1; ++i) {\n        for (int j = 0; j &lt; n + 1; ++j) {\n            X[i][j] = cosphi[i] * costheta[j];\n            Y[i][j] = cosphi[i] * sintheta[j];\n            Z[i][j] = sinphi[i];\n        }\n    }\n    auto X1d = reshape(X);\n    auto Y1d = reshape(Y);\n    auto Z1d = reshape(Z);\n    std::vector&lt;double&gt; x =\n        concat(concat(transform(X1d, [](double x) { return x * 0.5; }),\n                      transform(X1d, [](double x) { return x * 0.75; })),\n               X1d);\n    std::vector&lt;double&gt; y =\n        concat(concat(transform(Y1d, [](double y) { return y * 0.5; }),\n                      transform(Y1d, [](double y) { return y * 0.75; })),\n               Y1d);\n    std::vector&lt;double&gt; z =\n        concat(concat(transform(Z1d, [](double z) { return z * 0.5; }),\n                      transform(Z1d, [](double z) { return z * 0.75; })),\n               Z1d);\n\n    return std::make_tuple(x, y, z);\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data();\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = generate_data();\n    std::vector&lt;double&gt; sizes(x.size() / 3, 16);\n    std::fill_n(std::back_inserter(sizes), x.size() / 3, 8);\n    std::fill_n(std::back_inserter(sizes), x.size() / 3, 2);\n\n    scatter3(x, y, z, sizes);\n    view(40, 35);\n\n    show();\n    return 0;\n}\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data() {\n    using namespace matplot;\n    int n = 16;\n    auto r = iota(-n, 2., n);\n    auto theta = transform(r, [n](double x) { return x / n * pi; });\n    auto phi = transform(r, [n](double x) { return x / n * pi / 2.; });\n    auto sinphi = transform(phi, [](double x) { return sin(x); });\n    auto cosphi = transform(phi, [](double x) { return cos(x); });\n    cosphi.front() = 0;\n    cosphi.back() = 0;\n    auto sintheta = transform(theta, [](double x) { return sin(x); });\n    sintheta.front() = 0;\n    sintheta.back() = 0;\n    auto costheta = transform(theta, [](double x) { return cos(x); });\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Z(17, std::vector&lt;double&gt;(17, 0.));\n    for (int i = 0; i &lt; n + 1; ++i) {\n        for (int j = 0; j &lt; n + 1; ++j) {\n            X[i][j] = cosphi[i] * costheta[j];\n            Y[i][j] = cosphi[i] * sintheta[j];\n            Z[i][j] = sinphi[i];\n        }\n    }\n    auto X1d = reshape(X);\n    auto Y1d = reshape(Y);\n    auto Z1d = reshape(Z);\n    std::vector&lt;double&gt; x =\n        concat(concat(transform(X1d, [](double x) { return x * 0.5; }),\n                      transform(X1d, [](double x) { return x * 0.75; })),\n               X1d);\n    std::vector&lt;double&gt; y =\n        concat(concat(transform(Y1d, [](double y) { return y * 0.5; }),\n                      transform(Y1d, [](double y) { return y * 0.75; })),\n               Y1d);\n    std::vector&lt;double&gt; z =\n        concat(concat(transform(Z1d, [](double z) { return z * 0.5; }),\n                      transform(Z1d, [](double z) { return z * 0.75; })),\n               Z1d);\n\n    return std::make_tuple(x, y, z);\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data();\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = generate_data();\n\n    std::vector&lt;double&gt; sizes(x.size() / 3, 16);\n    std::fill_n(std::back_inserter(sizes), x.size() / 3, 8);\n    std::fill_n(std::back_inserter(sizes), x.size() / 3, 2);\n\n    std::vector&lt;double&gt; colors(x.size() / 3, 1);\n    std::fill_n(std::back_inserter(colors), x.size() / 3, 2);\n    std::fill_n(std::back_inserter(colors), x.size() / 3, 3);\n\n    scatter3(x, y, z, sizes, colors);\n    view(40, 35);\n\n    show();\n    return 0;\n}\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data() {\n    using namespace matplot;\n    int n = 16;\n    auto r = iota(-n, 2., n);\n    auto theta = transform(r, [n](double x) { return x / n * pi; });\n    auto phi = transform(r, [n](double x) { return x / n * pi / 2.; });\n    auto sinphi = transform(phi, [](double x) { return sin(x); });\n    auto cosphi = transform(phi, [](double x) { return cos(x); });\n    cosphi.front() = 0;\n    cosphi.back() = 0;\n    auto sintheta = transform(theta, [](double x) { return sin(x); });\n    sintheta.front() = 0;\n    sintheta.back() = 0;\n    auto costheta = transform(theta, [](double x) { return cos(x); });\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Z(17, std::vector&lt;double&gt;(17, 0.));\n    for (int i = 0; i &lt; n + 1; ++i) {\n        for (int j = 0; j &lt; n + 1; ++j) {\n            X[i][j] = cosphi[i] * costheta[j];\n            Y[i][j] = cosphi[i] * sintheta[j];\n            Z[i][j] = sinphi[i];\n        }\n    }\n    auto X1d = reshape(X);\n    auto Y1d = reshape(Y);\n    auto Z1d = reshape(Z);\n    std::vector&lt;double&gt; x =\n        concat(concat(transform(X1d, [](double x) { return x * 0.5; }),\n                      transform(X1d, [](double x) { return x * 0.75; })),\n               X1d);\n    std::vector&lt;double&gt; y =\n        concat(concat(transform(Y1d, [](double y) { return y * 0.5; }),\n                      transform(Y1d, [](double y) { return y * 0.75; })),\n               Y1d);\n    std::vector&lt;double&gt; z =\n        concat(concat(transform(Z1d, [](double z) { return z * 0.5; }),\n                      transform(Z1d, [](double z) { return z * 0.75; })),\n               Z1d);\n\n    return std::make_tuple(x, y, z);\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto z = linspace(0, 4 * pi, 250);\n    auto x = transform(z, [](double z) { return 2 * cos(z) + rand(0, 1); });\n    auto y = transform(z, [](double z) { return 2 * sin(z) + rand(0, 1); });\n\n    scatter3(x, y, z, \"filled\");\n    view(-30, 10);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto z = linspace(0, 4 * pi, 250);\n    auto x = transform(z, [](double z) { return 2 * cos(z) + rand(0, 1); });\n    auto y = transform(z, [](double z) { return 2 * sin(z) + rand(0, 1); });\n\n    scatter3(x, y, z, \"*\");\n    view(-30, 10);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n#include &lt;tuple&gt;\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data();\n\nint main() {\n    using namespace matplot;\n\n    auto [x, y, z] = generate_data();\n\n    std::vector&lt;double&gt; sizes(x.size() / 3, 16);\n    std::fill_n(std::back_inserter(sizes), x.size() / 3, 8);\n    std::fill_n(std::back_inserter(sizes), x.size() / 3, 2);\n\n    std::vector&lt;double&gt; colors(x.size() / 3, 1);\n    std::fill_n(std::back_inserter(colors), x.size() / 3, 2);\n    std::fill_n(std::back_inserter(colors), x.size() / 3, 3);\n\n    scatter3(x, y, z, sizes, colors)-&gt;marker_face_color({0, .5, .5});\n\n    show();\n    return 0;\n}\n\nstd::tuple&lt;std::vector&lt;double&gt;, std::vector&lt;double&gt;, std::vector&lt;double&gt;&gt;\ngenerate_data() {\n    using namespace matplot;\n    int n = 16;\n    auto r = iota(-n, 2., n);\n    auto theta = transform(r, [n](double x) { return x / n * pi; });\n    auto phi = transform(r, [n](double x) { return x / n * pi / 2.; });\n    auto sinphi = transform(phi, [](double x) { return sin(x); });\n    auto cosphi = transform(phi, [](double x) { return cos(x); });\n    cosphi.front() = 0;\n    cosphi.back() = 0;\n    auto sintheta = transform(theta, [](double x) { return sin(x); });\n    sintheta.front() = 0;\n    sintheta.back() = 0;\n    auto costheta = transform(theta, [](double x) { return cos(x); });\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(17, std::vector&lt;double&gt;(17, 0.));\n    std::vector&lt;std::vector&lt;double&gt;&gt; Z(17, std::vector&lt;double&gt;(17, 0.));\n    for (int i = 0; i &lt; n + 1; ++i) {\n        for (int j = 0; j &lt; n + 1; ++j) {\n            X[i][j] = cosphi[i] * costheta[j];\n            Y[i][j] = cosphi[i] * sintheta[j];\n            Z[i][j] = sinphi[i];\n        }\n    }\n    auto X1d = reshape(X);\n    auto Y1d = reshape(Y);\n    auto Z1d = reshape(Z);\n    std::vector&lt;double&gt; x =\n        concat(concat(transform(X1d, [](double x) { return x * 0.5; }),\n                      transform(X1d, [](double x) { return x * 0.75; })),\n               X1d);\n    std::vector&lt;double&gt; y =\n        concat(concat(transform(Y1d, [](double y) { return y * 0.5; }),\n                      transform(Y1d, [](double y) { return y * 0.75; })),\n               Y1d);\n    std::vector&lt;double&gt; z =\n        concat(concat(transform(Z1d, [](double z) { return z * 0.5; }),\n                      transform(Z1d, [](double z) { return z * 0.75; })),\n               Z1d);\n\n    return std::make_tuple(x, y, z);\n}\n</code></pre>"},{"location":"plot-types/data-distribution/scatter-plot/","title":"Scatter Plot","text":"<pre><code>scatter(x,y);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 3 * pi, 200);\n    auto y = transform(x, [&amp;](double x) { return cos(x) + rand(0, 1); });\n\n    scatter(x, y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 3 * pi, 200);\n    auto y = transform(x, [&amp;](double x) { return cos(x) + rand(0, 1); });\n    auto c = linspace(1, 10, x.size());\n\n    scatter(x, y, c);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 3 * pi, 200);\n    auto y = transform(x, [&amp;](double x) { return cos(x) + rand(0, 1); });\n    auto c = linspace(1, 10, x.size());\n\n    scatter(x, y, std::vector&lt;double&gt;{}, c);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 3 * pi, 200);\n    auto y = transform(x, [&amp;](double x) { return cos(x) + rand(0, 1); });\n    auto c = linspace(1, 10, x.size());\n\n    auto l = scatter(x, y, 6, c);\n    l-&gt;marker_face(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto theta = linspace(0, 2 * pi, 150);\n    auto x =\n        transform(theta, [&amp;](double t) { return sin(t) + 0.75 * rand(0, 1); });\n    auto y =\n        transform(theta, [&amp;](double t) { return cos(t) + 0.75 * rand(0, 1); });\n    double sz = 23;\n\n    auto l = scatter(x, y, sz);\n    l-&gt;marker_style(line_spec::marker_style::diamond);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto theta = linspace(0, 2 * pi, 300);\n    auto x =\n        transform(theta, [&amp;](double t) { return sin(t) + 0.75 * rand(0, 1); });\n    auto y =\n        transform(theta, [&amp;](double t) { return cos(t) + 0.75 * rand(0, 1); });\n    double sz = 6;\n\n    auto l = scatter(x, y, sz);\n    l-&gt;marker_color({0.f, .5f, .5f});\n    l-&gt;marker_face_color({0.f, .7f, .7f});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto x = linspace(0, 3 * pi, 200);\n    auto y = transform(x, [&amp;](double x) { return cos(x) + rand(0, 1); });\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    scatter(ax1, x, y);\n\n    auto ax2 = nexttile();\n    auto l = scatter(ax2, x, y);\n    l-&gt;marker_face(true);\n    l-&gt;marker_style(line_spec::marker_style::diamond);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto theta = linspace(0, 1, 500);\n    auto x = transform(\n        theta, [&amp;](double theta) { return exp(theta) * sin(100 * theta); });\n    auto y = transform(\n        theta, [&amp;](double theta) { return exp(theta) * cos(100 * theta); });\n\n    auto s = scatter(x, y);\n    s-&gt;marker_color(\"b\");\n    s-&gt;marker_face_color({0, .5, .5});\n\n    show();\n    return 0;\n}\n</code></pre> <p>Scatter plots also depend on the <code>line</code> object. As the line object can represent lines with markers, the <code>scatter</code> function simply creates markers without the lines.</p>"},{"location":"plot-types/data-distribution/word-cloud/","title":"Word Cloud","text":"<pre><code>wordcloud(text, black_list);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::string text = fileread(\"shakespeare_sonnets.txt\");\n    std::transform(text.begin(), text.end(), text.begin(), [](char c) {\n        return static_cast&lt;char&gt;(std::tolower(static_cast&lt;int&gt;(c)));\n    });\n\n    std::vector&lt;std::string&gt; black_list =\n        tokenize(fileread(\"en_blacklist.txt\"));\n\n    wordcloud(text, black_list);\n    title(\"Shakespeare's sonnets\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::string text = fileread(\"shakespeare_sonnets.txt\");\n    std::transform(text.begin(), text.end(), text.begin(),\n                   [](char c) { return static_cast&lt;char&gt;(std::tolower(static_cast&lt;int&gt;(c))); });\n\n    std::vector&lt;std::string&gt; black_list =\n        tokenize(fileread(\"en_blacklist.txt\"));\n\n    std::vector&lt;std::string&gt; text_tokens = tokenize(text);\n    auto it = std::remove_if(text_tokens.begin(), text_tokens.end(),\n                             [](const std::string &amp;s) { return s.size() &lt; 5; });\n    text_tokens.erase(it, text_tokens.end());\n\n    auto [tokens, count] = wordcount(text_tokens, black_list);\n\n    wordcloud(tokens, count);\n    title(\"Shakespeare's sonnets - Big words\");\n\n    matplot::show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::string text = fileread(\"shakespeare_sonnets.txt\");\n    std::transform(text.begin(), text.end(), text.begin(), [](char c) {\n        return static_cast&lt;char&gt;(std::tolower(static_cast&lt;int&gt;(c)));\n    });\n\n    std::vector&lt;std::string&gt; black_list =\n        tokenize(fileread(\"en_blacklist.txt\"));\n\n    auto [tokens, count] = wordcount(text, black_list);\n\n    std::vector&lt;double&gt; custom_colors = rand(tokens.size(), 0., 100.);\n\n    wordcloud(tokens, count, custom_colors);\n    title(\"Shakespeare's sonnets - Random colors\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::string text = fileread(\"shakespeare_sonnets.txt\");\n    std::transform(text.begin(), text.end(), text.begin(), [](char c) {\n        return static_cast&lt;char&gt;(std::tolower(static_cast&lt;int&gt;(c)));\n    });\n\n    std::vector&lt;std::string&gt; black_list =\n        tokenize(fileread(\"en_blacklist.txt\"));\n\n    auto [tokens, count] = wordcount(text, black_list);\n\n    std::vector&lt;double&gt; custom_colors = rand(tokens.size(), 0., 100.);\n\n    wordcloud(tokens, count, custom_colors);\n    title(\"Shakespeare's sonnets - Random colors\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>Word clouds are generated from text or pairs of words and their frequency. After attributing a size proportional to each word frequency, the algorithm to position the labels iterates words from the largest to the smallest. For each word, it spins the word in polar coordinates converted to Cartesian coordinates until it does not overlap with any other word.</p> <p>By default, the colors and the sizes depend on the word frequencies. We can customize the colors by passing a third parameter to the <code>wordcloud</code> function.</p>"},{"location":"plot-types/discrete-data/bar-plot/","title":"Bar Plot","text":"<pre><code>bar(y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {75,  91,  105, 123.5, 131,  150,\n                             179, 203, 226, 249,   281.5};\n    bar(y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(1900, 10, 2000);\n    std::vector&lt;double&gt; y = {75,  91,  105, 123.5, 131,  150,\n                             179, 203, 226, 249,   281.5};\n    bar(x, y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {75,  91,  105, 123.5, 131,  150,\n                             179, 203, 226, 249,   281.5};\n    bar(y, 0.4);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {2, 2, 2, 2}, {2, 5, 8, 11}, {3, 6, 9, 12}};\n    bar(Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {2, 2, 2, 2}, {2, 5, 8, 11}, {3, 6, 9, 12}};\n    barstacked(Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {1980, 1990, 2000};\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {15, 10, -10}, {20, -17, 5}, {-5, 21, 15}};\n    barstacked(x, Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {10, 21, 33, 52};\n    bar(y);\n    gca()-&gt;x_axis().ticklabels({\"Small\", \"Medium\", \"Large\", \"Extra Large\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {1, 2, 3};\n    std::vector&lt;std::vector&lt;double&gt;&gt; y = {{2, 3, 6}, {11, 23, 26}};\n    auto b = bar(x, y);\n\n    std::vector&lt;double&gt; label_x;\n    std::vector&lt;double&gt; label_y;\n    std::vector&lt;std::string&gt; labels;\n    for (size_t i = 0; i &lt; y.size(); ++i) {\n        for (size_t j = 0; j &lt; x.size(); ++j) {\n            label_x.emplace_back(b-&gt;x_end_point(i, j));\n            label_y.emplace_back(y[i][j] + 1);\n            labels.emplace_back(num2str(y[i][j]));\n        }\n    }\n\n    hold(on);\n    text(label_x, label_y, labels);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; y = {{1, 4}, {2, 5}, {3, 6}};\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    bar(ax1, y);\n\n    auto ax2 = nexttile();\n    barstacked(ax2, y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {75,  91,  105, 123.5, 131,  150,\n                             179, 203, 226, 249,   281.5};\n    bar(y)-&gt;face_color(\"r\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {75,  91,  105, 123.5, 131,  150,\n                             179, 203, 226, 249,   281.5};\n\n    bar(y)-&gt;face_color({0.f, .5f, .5f}).edge_color({0.f, .9f, .9f}).line_width(1.5f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x1 = concat({1}, iota(3, 10));\n    bar(x1, rand(9, 0, 1));\n    hold(on);\n    bar(std::vector&lt;double&gt;{2}, rand(1, 0, 1));\n    gca()-&gt;x_axis().tick_values(iota(1, 10));\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; y = {\n        {10, 30, 50}, {15, 35, 55}, {20, 40, 62}};\n    auto b = bar(y);\n    b-&gt;face_colors()[2] = {0.f, .2f, .6f, .5f};\n    gcf()-&gt;draw();\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/discrete-data/pareto-chart/","title":"Pareto Chart","text":"<pre><code>pareto(y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {90, 75, 30, 60, 5, 40, 40, 5};\n    pareto(y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; codelines = {200, 120, 555, 608, 1024, 101, 57, 687};\n    std::vector&lt;std::string&gt; coders = {\"Fred\",  \"Ginger\", \"Norman\", \"Max\",\n                                       \"Julia\", \"Wally\",  \"Heidi\",  \"Pat\"};\n\n    pareto(codelines, coders);\n    title(\"Lines of Code by Programmer\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; votes = {35, 50, 30, 5, 80};\n    std::vector&lt;std::string&gt; pies = {\"Chocolate\", \"Apple\", \"Pecan\", \"Cherry\",\n                                     \"Pumpkin\"};\n\n    pareto(votes, pies, 1.0);\n    ylabel(\"Votes\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {10, 23, 7, 16, 3};\n    pareto(y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>Pareto Charts are a type of chart that uses both  axes. The  axis is used to represent bars with the data values in descending order. The  axis is used to represent the cumulative distribution function of the data in the  axis. By default, a Pareto Chart includes up to 10 items or as many items as needed to represent 95% of the cumulative distribution.</p> <p>If you need Pareto fronts rather than Pareto charts, we refer to Scatter Plots for two-dimensional fronts, Plot matrices for three-dimensional fronts, or Parallel Coordinate Plots for many-objective fronts. These plot subcategories are described in Section Data Distribution. If you also need a tool to calculate these fronts efficiently, we refer to the Pareto Front Library.</p>"},{"location":"plot-types/discrete-data/stem-plot-3d/","title":"Stem Plot 3D","text":"<pre><code>stem3(z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(-pi / 2, pi / 2, 40);\n    auto z = transform(x, [](auto x) { return cos(x); });\n    stem3(z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x(40, 1.);\n    std::vector&lt;double&gt; y = linspace(-pi / 2, pi / 2, 40);\n    auto z = transform(y, [](auto x) { return cos(x); });\n    stem3(x, y, z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(-pi / 2, pi / 2, 40);\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Z(2);\n    Z[0] = transform(x, [](auto x) { return sin(x); });\n    Z[1] = transform(x, [](auto x) { return cos(x); });\n\n    stem3(Z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(-5, +5, 60);\n    std::vector&lt;double&gt; y = transform(x, [](double x) { return cos(x); });\n    std::vector&lt;double&gt; z = transform(x, [](double x) { return pow(x, 2); });\n\n    stem3(x, y, z);\n    view(-8, 30);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; grid_ticks = iota(0, .1, 1);\n    std::vector&lt;double&gt; x;\n    std::vector&lt;double&gt; y;\n    std::vector&lt;double&gt; z;\n    for (const auto &amp;x_i : grid_ticks) {\n        for (const auto &amp;y_i : grid_ticks) {\n            x.emplace_back(x_i);\n            y.emplace_back(y_i);\n            z.emplace_back(exp(x_i + y_i));\n        }\n    }\n\n    stem3(x, y, z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(-pi, pi, 40);\n    std::vector&lt;double&gt; z = transform(x, [](double x) { return cos(x); });\n\n    stem3(z, \"filled\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(-pi, pi, 40);\n    std::vector&lt;double&gt; z = transform(x, [](double x) { return cos(x); });\n\n    stem3(z, \"--*m\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; x = transform(theta, [](double t) { return cos(t); });\n    std::vector&lt;double&gt; y = transform(theta, [](double t) { return sin(t); });\n    std::vector&lt;double&gt; z = theta;\n\n    stem3(x, y, z, \":*m\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-pi, pi, 40);\n    std::vector&lt;double&gt; z = transform(x, [](double x) { return cos(x); });\n\n    stem3(z)-&gt;marker(\"s\").marker_color(\"m\").marker_face_color(\"g\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-2, +2, 50);\n    std::vector&lt;double&gt; y = transform(x, [](double x) { return pow(x, 3); });\n    std::vector&lt;double&gt; z = transform(x, [](double x) { return exp(x); });\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    stem(ax1, x, z);\n\n    auto ax2 = nexttile();\n    stem3(ax2, x, y, z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, +2);\n    std::vector&lt;double&gt; y = transform(x, [](double x) { return pow(x, 3); });\n    std::vector&lt;double&gt; z =\n        transform(x, y, [](double x, double y) { return exp(x) * cos(y); });\n\n    stem3(x, y, z, \"filled\")-&gt;color(\"m\").marker_face_color(\"y\");\n    view(-10, 35);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/discrete-data/stem-plot/","title":"Stem Plot","text":"<pre><code>stem(Y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi, 50);\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(2);\n    Y[0] = transform(x, [](auto x) { return cos(x); });\n    Y[1] = transform(x, [](auto x) { return 0.5 * sin(x); });\n\n    stem(Y, \"-o\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi, 50);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return cos(x); });\n\n    stem(x, y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi, 50);\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(2);\n    Y[0] = transform(x, [](auto x) { return cos(x); });\n    Y[1] = transform(x, [](auto x) { return 0.5 * sin(x); });\n\n    stem(x, Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x1 = linspace(0, 2 * pi, 50);\n    std::vector&lt;double&gt; y1 = transform(x1, [](auto x) { return cos(x); });\n\n    std::vector&lt;double&gt; x2 = linspace(pi, 3 * pi, 50);\n    std::vector&lt;double&gt; y2 = transform(x2, [](auto x) { return 0.5 * sin(x); });\n\n    stem(x1, y1);\n    hold(on);\n    stem(x2, y2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 10, 20);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return exp(0.25 * x); });\n\n    stem(x, y, \"filled\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi, 50);\n    std::vector&lt;double&gt; y =\n        transform(x, [](auto x) { return exp(x) * sin(x); });\n\n    stem(x, y, \":dr\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi, 25);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return cos(2 * x); });\n\n    auto s = stem(x, y)-&gt;line_style(\"-.\").marker_face_color(\"red\").marker_color(\n        \"green\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = iota(0, 25);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return exp(0.1 * x); });\n    std::vector&lt;double&gt; y2 =\n        transform(x, [](auto x) { return -exp(0.05 * x); });\n\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    stem(ax1, x, y1);\n\n    auto ax2 = nexttile();\n    stem(ax2, x, y2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi, 50);\n    std::vector&lt;double&gt; y =\n        transform(x, [](auto x) { return exp(0.3 * x) * sin(3 * x); });\n\n    stem(x, y);\n    gca()-&gt;x_axis().zero_axis(false);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/geography/geobubble/","title":"Geobubble","text":"<pre><code>geobubble(lat,lon,sizes);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; tsunami_lon = {\n        128.3,    -156,     157.95,  143.85,   -155,     -82.4,    159.5,\n        156.5,    147.4,    178.2,   141.7,    -86.883,  -32.283,  -72,\n        23,       -175.629, 137,     -99,      -79.5,    104,      -136.52,\n        148.54,   148.8,    159.8,   156,      -111.215, -72.75,   143.4,\n        143.7,    -74.5,    -80.7,   147.9,    168.5,    160.5,    142.8,\n        22.05,    149.54,   150.1,   -176.6,   -147.5,   139.2,    178.55,\n        22.4,     167.2,    167.6,   160.8,    -78.8,    -70.6,    166.5,\n        164.8,    166.8,    97.3,    -79.8,    24.9,     132.5,    143.2,\n        143.1,    119.8,    -92.6,   118.9,    147.9,    163.6,    121.7,\n        -78.8,    145.5,    -71.2,   153.9,    153.2,    141.2,    146.6,\n        147,      -103,     156.6,   145.8,    155.9,    155.6,    -77.79,\n        -128.633, -17.649,  147.734, 155.054,  125.993,  -155.024, 124.023,\n        118.464,  -78.52,   142.03,  -96.591,  -101.276, 136.04,   7.25,\n        -79.358,  -122.18,  142.361, 127.924,  139.102,  139.099,  72.11,\n        -71.871,  114.185,  152.828, -102.533, -101.647, -174.776, 147.689,\n        14.97,    121.013,  -83.073, -124.316, -87.34,   121.896,  139.197,\n        144.801,  127.733,  112.835, 112.892,  133.366,  152.214,  147.321,\n        127.98,   -135.3,   121.067, 143.419,  125.127,  -70.294,  -104.205,\n        130.175,  130.148,  149.3,   119.931,  22.083,   159.318,  136.952,\n        -79.587,  131.468,  166.676, 162.035,  162.035,  -62.18,   141.926,\n        124.891,  -62.18,   29.864,  168.214,  120.15,   123.573,  -120.65,\n        152.169,  -73.641,  167.856, 124.249,  142.945,  134.297,  3.634,\n        -62.18,   143.91,   95.982,  97.108,   127.214,  -62.18,   107.411,\n        153.266};\n\n    std::vector&lt;double&gt; tsunami_lat = {\n        -3.8,   19.5,   -9.02,   42.15,   19.1,    43.1,    52.75,  50,\n        -2.4,   -18.3,  34,      41.7,    67.8,    -30,     39.5,   51.292,\n        -1.5,   16.5,   1.2,     -4.5,    58.34,   44.53,   44.2,   53.4,\n        -7.5,   44.712, -15.75,  39.8,    39.4,    -39.5,   -6.8,   43.2,\n        -18.5,  -9.9,   38,      38.42,   44.81,   44.1,    -24.8,  61.1,\n        38.65,  51.29,  38.4,    -15.8,   -15.9,   -10.3,   -10.7,  -25.5,\n        -11.8,  -11.3,  -11.8,   5.5,     -10.6,   39.4,    32.3,   40.8,\n        39.4,   0.2,    15.6,    -3.1,    43.6,    57.7,    15.8,   -9.2,\n        -4.9,   -32.5,  -5.5,    -4.9,    46.5,    -6.5,    -6.7,   18.48,\n        50.5,   43.2,   -7.5,    -7.4,    -12.27,  54.083,  35.997, 43.024,\n        -6.59,  12.54,  19.334,  6.262,   -11.085, -10.233, 38.19,  16.01,\n        17.813, -1.679, 43.7,    1.598,   46.2,    42.158,  -4.056, 40.462,\n        41.346, -6.852, -33.135, -9.245,  -4.439,  18.19,   17.802, 51.52,\n        -6.088, 38.41,  18.606,  9.685,   40.368,  11.742,  -8.48,  42.851,\n        12.982, 1.015,  -10.477, -10.362, -10.777, -4.238,  43.773, -1.258,\n        59.5,   13.525, 40.525,  -8.378,  -23.34,  19.055,  27.929, 28.094,\n        44.663, 0.729,  38.367,  54.45,   -0.891,  -9.593,  31.885, -12.584,\n        54.841, 54.841, 16.72,   -2.961,  -2.071,  16.722,  40.748, -16.423,\n        5.1,    -1.105, 34.5,    -3.98,   -16.265, -17.6,   6.033,  -3.302,\n        -1.757, 36.964, 16.722,  41.815,  3.295,   2.085,   -3.595, 16.722,\n        -9.254, 46.592};\n\n    std::vector&lt;double&gt; tsunami_height = {\n        2.8,   3.6, 6,    6.5,   1,   1.52, 18,  1.5, 1.4,    3,   3,    3,\n        18.28, 1,   1.2,  15.24, 1.8, 2.5,  1,   1,   524.26, 5,   1,    2,\n        2.4,   1,   5.7,  1,     1.5, 25,   9,   1,   1.5,    1,   1,    3,\n        4.5,   15,  1,    67,    5.8, 10.7, 3,   7,   2,      1.4, 3,    1,\n        2,     1.5, 2,    2,     2,   1.2,  2.4, 6,   3,      10,  2,    4,\n        5,     15,  2,    1.8,   3,   1.2,  3,   3,   2,      1.8, 1.5,  1.16,\n        1.5,   4.5, 1.5,  4.5,   1.8, 8.2,  2.1, 5.5, 2,      4,   14.3, 4.48,\n        15,    1.2, 1,    1.5,   1.3, 2,    10,  6,   250,    1.3, 3,    14.5,\n        1,     1.5, 3,    2,     1.3, 3,    2.5, 1.4, 1.5,    5.5, 1.03, 3,\n        1.8,   10,  26.2, 31.7,  2.1, 2,    13,  3.7, 3,      1.2, 11,   3,\n        7.62,  7.3, 1.1,  4,     3,   5.1,  2.6, 1.5, 1.1,    3.4, 2,    30,\n        7.7,   5.1, 1.1,  3,     1.5, 8,    3,   15,  2.75,   2,   2.52, 6,\n        20,    6,   7,    1,     7,   3,    3,   4,   5,      2,   4,    4,\n        50,    3,   3.5,  1,     10,  1.8};\n\n    auto log_tsunami_height =\n        transform(tsunami_height, [](double x) { return log(x + 2); });\n\n    geobubble(tsunami_lat, tsunami_lon, log_tsunami_height);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; tsunami_lon = {\n        128.3,    -156,     157.95,  143.85,   -155,     -82.4,    159.5,\n        156.5,    147.4,    178.2,   141.7,    -86.883,  -32.283,  -72,\n        23,       -175.629, 137,     -99,      -79.5,    104,      -136.52,\n        148.54,   148.8,    159.8,   156,      -111.215, -72.75,   143.4,\n        143.7,    -74.5,    -80.7,   147.9,    168.5,    160.5,    142.8,\n        22.05,    149.54,   150.1,   -176.6,   -147.5,   139.2,    178.55,\n        22.4,     167.2,    167.6,   160.8,    -78.8,    -70.6,    166.5,\n        164.8,    166.8,    97.3,    -79.8,    24.9,     132.5,    143.2,\n        143.1,    119.8,    -92.6,   118.9,    147.9,    163.6,    121.7,\n        -78.8,    145.5,    -71.2,   153.9,    153.2,    141.2,    146.6,\n        147,      -103,     156.6,   145.8,    155.9,    155.6,    -77.79,\n        -128.633, -17.649,  147.734, 155.054,  125.993,  -155.024, 124.023,\n        118.464,  -78.52,   142.03,  -96.591,  -101.276, 136.04,   7.25,\n        -79.358,  -122.18,  142.361, 127.924,  139.102,  139.099,  72.11,\n        -71.871,  114.185,  152.828, -102.533, -101.647, -174.776, 147.689,\n        14.97,    121.013,  -83.073, -124.316, -87.34,   121.896,  139.197,\n        144.801,  127.733,  112.835, 112.892,  133.366,  152.214,  147.321,\n        127.98,   -135.3,   121.067, 143.419,  125.127,  -70.294,  -104.205,\n        130.175,  130.148,  149.3,   119.931,  22.083,   159.318,  136.952,\n        -79.587,  131.468,  166.676, 162.035,  162.035,  -62.18,   141.926,\n        124.891,  -62.18,   29.864,  168.214,  120.15,   123.573,  -120.65,\n        152.169,  -73.641,  167.856, 124.249,  142.945,  134.297,  3.634,\n        -62.18,   143.91,   95.982,  97.108,   127.214,  -62.18,   107.411,\n        153.266};\n\n    std::vector&lt;double&gt; tsunami_lat = {\n        -3.8,   19.5,   -9.02,   42.15,   19.1,    43.1,    52.75,  50,\n        -2.4,   -18.3,  34,      41.7,    67.8,    -30,     39.5,   51.292,\n        -1.5,   16.5,   1.2,     -4.5,    58.34,   44.53,   44.2,   53.4,\n        -7.5,   44.712, -15.75,  39.8,    39.4,    -39.5,   -6.8,   43.2,\n        -18.5,  -9.9,   38,      38.42,   44.81,   44.1,    -24.8,  61.1,\n        38.65,  51.29,  38.4,    -15.8,   -15.9,   -10.3,   -10.7,  -25.5,\n        -11.8,  -11.3,  -11.8,   5.5,     -10.6,   39.4,    32.3,   40.8,\n        39.4,   0.2,    15.6,    -3.1,    43.6,    57.7,    15.8,   -9.2,\n        -4.9,   -32.5,  -5.5,    -4.9,    46.5,    -6.5,    -6.7,   18.48,\n        50.5,   43.2,   -7.5,    -7.4,    -12.27,  54.083,  35.997, 43.024,\n        -6.59,  12.54,  19.334,  6.262,   -11.085, -10.233, 38.19,  16.01,\n        17.813, -1.679, 43.7,    1.598,   46.2,    42.158,  -4.056, 40.462,\n        41.346, -6.852, -33.135, -9.245,  -4.439,  18.19,   17.802, 51.52,\n        -6.088, 38.41,  18.606,  9.685,   40.368,  11.742,  -8.48,  42.851,\n        12.982, 1.015,  -10.477, -10.362, -10.777, -4.238,  43.773, -1.258,\n        59.5,   13.525, 40.525,  -8.378,  -23.34,  19.055,  27.929, 28.094,\n        44.663, 0.729,  38.367,  54.45,   -0.891,  -9.593,  31.885, -12.584,\n        54.841, 54.841, 16.72,   -2.961,  -2.071,  16.722,  40.748, -16.423,\n        5.1,    -1.105, 34.5,    -3.98,   -16.265, -17.6,   6.033,  -3.302,\n        -1.757, 36.964, 16.722,  41.815,  3.295,   2.085,   -3.595, 16.722,\n        -9.254, 46.592};\n\n    std::vector&lt;double&gt; tsunami_height = {\n        2.8,   3.6, 6,    6.5,   1,   1.52, 18,  1.5, 1.4,    3,   3,    3,\n        18.28, 1,   1.2,  15.24, 1.8, 2.5,  1,   1,   524.26, 5,   1,    2,\n        2.4,   1,   5.7,  1,     1.5, 25,   9,   1,   1.5,    1,   1,    3,\n        4.5,   15,  1,    67,    5.8, 10.7, 3,   7,   2,      1.4, 3,    1,\n        2,     1.5, 2,    2,     2,   1.2,  2.4, 6,   3,      10,  2,    4,\n        5,     15,  2,    1.8,   3,   1.2,  3,   3,   2,      1.8, 1.5,  1.16,\n        1.5,   4.5, 1.5,  4.5,   1.8, 8.2,  2.1, 5.5, 2,      4,   14.3, 4.48,\n        15,    1.2, 1,    1.5,   1.3, 2,    10,  6,   250,    1.3, 3,    14.5,\n        1,     1.5, 3,    2,     1.3, 3,    2.5, 1.4, 1.5,    5.5, 1.03, 3,\n        1.8,   10,  26.2, 31.7,  2.1, 2,    13,  3.7, 3,      1.2, 11,   3,\n        7.62,  7.3, 1.1,  4,     3,   5.1,  2.6, 1.5, 1.1,    3.4, 2,    30,\n        7.7,   5.1, 1.1,  3,     1.5, 8,    3,   15,  2.75,   2,   2.52, 6,\n        20,    6,   7,    1,     7,   3,    3,   4,   5,      2,   4,    4,\n        50,    3,   3.5,  1,     10,  1.8};\n    auto log_tsunami_height =\n        transform(tsunami_height, [](double x) { return log(x + 2); });\n\n    std::vector&lt;double&gt; tsunami_cause = {\n        1, 1, 6, 1, 1, 4, 1, 1,   6, 2, 1, 4, 5, 1, 1, 1, 1, 1, 1, 1, 2,\n        1, 1, 1, 5, 2, 1, 1, 1,   1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 2, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, NaN, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 2, 3,   1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 2, 1,\n        1, 1, 1, 1, 1, 1, 3, 1,   6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        3, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 6, 1, 1, 3, 1, 1, 2, 1, 1,\n        1, 2, 1, 1, 3, 6, 1, 1,   1, 1, 1, 3, 7, 2, 1, 6, 1, 1, 4, 1, 3,\n        1, 1, 1, 1, 1, 1, 1, 6,   1, 1, 1, 1, 6, 1, 1};\n\n    geobubble(tsunami_lat, tsunami_lon, log_tsunami_height, tsunami_cause);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/geography/geodensity-plot/","title":"Geodensity Plot","text":"<pre><code>geodensityplot(lat, lon);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; lon =\n        transform(linspace(-170, 170, 3000),\n                  [](double x) { return x + 10. * rand(0, 1); });\n    std::vector&lt;double&gt; lat = transform(\n        lon, [](double x) { return 50. * cosd(3 * x) + 10 * rand(0, 1); });\n    std::vector&lt;double&gt; weights =\n        transform(lon, [](double lon) { return 101. + 100 * (sind(2 * lon)); });\n\n    geodensityplot(lat, lon);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/geography/geoplot/","title":"Geoplot","text":"<pre><code>geoplot(lat,lon);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    double lat_seattle = 47.62;\n    double lon_seattle = -122.33;\n    double lat_anchorage = 61.20;\n    double lon_anchorage = -149.9;\n    geoplot(std::vector{lat_seattle, lat_anchorage},\n            std::vector{lon_seattle, lon_anchorage}, \"g-*\");\n    geolimits({45, 62}, {-155, -120});\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    double lat_seattle = 47.62;\n    double lon_seattle = -122.33;\n    double lat_anchorage = 61.20;\n    double lon_anchorage = -149.9;\n    geoplot(std::vector{lat_seattle, lat_anchorage},\n            std::vector{lon_seattle, lon_anchorage}, \"g-*\");\n    geolimits({45, 62}, {-155, -120});\n\n    text(lon_anchorage, lat_anchorage, \"Anchorage\");\n    text(lon_seattle, lat_seattle, \"Seattle\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto [lon, lat, names] = world_cities(6, 8);\n    auto [lon_star, lat_star] = greedy_tsp(lon, lat);\n    geoplot(lat_star, lon_star)\n        -&gt;marker(\"o\")\n        .marker_colors(iota(1., static_cast&lt;double&gt;(names.size())));\n    text(lon, lat, names);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    double lat_seattle = 47.62;\n    double lon_seattle = -122.33;\n    double lat_anchorage = 61.20;\n    double lon_anchorage = -149.9;\n    double lat_pt_barrow = 71.38;\n    double lon_pt_barrow = -156.47;\n\n    geoplot(std::vector{lat_seattle, lat_anchorage},\n            std::vector{lon_seattle, lon_anchorage}, \"y-\");\n    hold(on);\n    geoplot(std::vector{lat_seattle, lat_pt_barrow},\n            std::vector{lon_seattle, lon_pt_barrow}, \"b:\");\n\n    geolimits(44, 75, -170, -100);\n\n    text(lon_anchorage, lat_anchorage, \"Anchorage\");\n    text(lon_seattle, lat_seattle, \"Seattle\");\n    text(lon_pt_barrow, lat_pt_barrow, \"Point Barrow\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    double lat_seattle = 47.62;\n    double lon_seattle = -122.33;\n    double lat_anchorage = 61.20;\n    double lon_anchorage = -149.9;\n\n    auto g = geoplot(std::vector{lat_seattle, lat_anchorage},\n                     std::vector{lon_seattle, lon_anchorage});\n    g-&gt;line_width(2.);\n    hold(on);\n\n    geolimits({44, 75}, {-170, -100});\n\n    text(lon_anchorage, lat_anchorage, \"Anchorage\");\n    text(lon_seattle, lat_seattle, \"Seattle\");\n\n    color_array terrain = {0.f, 0.71f, 0.65f, 0.59f};\n    geoplot()-&gt;color(terrain);\n\n    color_array blue_water = {0.f, 0.4f, 0.61f, 0.76f};\n    gca()-&gt;color(blue_water);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nusing namespace matplot;\nusing namespace std;\n\nclass eurotrip_solver {\n  public:\n    eurotrip_solver(const vector&lt;double&gt; &amp;lat, const vector&lt;double&gt; &amp;lon,\n                    const vector&lt;string&gt; &amp;names, axes_handle ax);\n    void run(size_t iterations = 100);\n\n  private:\n    void setup_starting_point(size_t iteration);\n    double tour_distance(const vector&lt;size_t&gt; &amp;tour);\n    void iteration();\n    static vector&lt;vector&lt;size_t&gt;&gt;\n    get_neighbors(const std::vector&lt;size_t&gt; &amp;tour);\n    bool update_if_better(const vector&lt;size_t&gt; &amp;neighbor);\n    void draw_if_improvement();\n    void draw();\n\n  private:\n    vector&lt;double&gt; lat_;\n    vector&lt;double&gt; lon_;\n    vector&lt;string&gt; names_;\n    axes_handle ax_;\n\n    // Current tour\n    double curr_dist_{0.0};\n    vector&lt;size_t&gt; curr_tour_;\n\n    // Best tour\n    double min_dist_{0.0};\n    vector&lt;size_t&gt; best_tour_;\n};\n\neurotrip_solver::eurotrip_solver(const vector&lt;double&gt; &amp;lat,\n                                 const vector&lt;double&gt; &amp;lon,\n                                 const vector&lt;string&gt; &amp;names, axes_handle ax)\n    : lat_(lat), lon_(lon), names_(names), ax_(ax) {}\n\nvoid eurotrip_solver::run(size_t iterations) {\n    for (size_t i = 0; i &lt; iterations; ++i) {\n        setup_starting_point(i);\n        iteration();\n    }\n    ax_-&gt;draw();\n    ax_-&gt;parent()-&gt;save(\"eurotrip.svg\");\n}\n\nvoid eurotrip_solver::setup_starting_point(size_t iteration) {\n    std::cout &lt;&lt; \"Starting point \" &lt;&lt; iteration &lt;&lt; std::endl;\n    if (iteration &lt; names_.size()) {\n        auto [lon_ignore, lat_ignore, tour] =\n            greedy_tsp_with_idx(lon_, lat_, iteration);\n        curr_tour_ = tour;\n        curr_dist_ = tour_distance(curr_tour_);\n    } else {\n        static std::mt19937 g((std::random_device())());\n        std::iota(curr_tour_.begin(), curr_tour_.end(), 0);\n        std::shuffle(curr_tour_.begin(), curr_tour_.end(), g);\n        curr_dist_ = tour_distance(curr_tour_);\n    }\n    if (iteration == 0 || curr_dist_ &lt; min_dist_) {\n        best_tour_ = curr_tour_;\n        min_dist_ = curr_dist_;\n    }\n}\n\nvector&lt;vector&lt;size_t&gt;&gt;\neurotrip_solver::get_neighbors(const std::vector&lt;size_t&gt; &amp;tour) {\n    vector&lt;vector&lt;size_t&gt;&gt; neighbors;\n    constexpr size_t n_movements = 2;\n    for (size_t i = 0; i &lt; tour.size() - 1; ++i) {\n        for (size_t j = i + 1; j &lt; tour.size(); ++j) {\n            for (size_t movement = 0; movement &lt; n_movements; ++movement) {\n                vector&lt;size_t&gt; neighbor = tour;\n                if (movement == 0) {\n                    std::swap(neighbor[i], neighbor[j]);\n                } else {\n                    std::reverse(neighbor.begin() + i,\n                                 neighbor.begin() + j + 1);\n                }\n                neighbors.emplace_back(neighbor);\n            }\n        }\n    }\n    return neighbors;\n}\n\nvoid eurotrip_solver::iteration() {\n    bool improvement = true;\n    while (improvement) {\n        improvement = false;\n        for (const auto &amp;neighbor : get_neighbors(curr_tour_)) {\n            improvement = update_if_better(neighbor);\n            draw_if_improvement();\n            if (improvement) {\n                break;\n            }\n        }\n    }\n}\n\ndouble eurotrip_solver::tour_distance(const vector&lt;size_t&gt; &amp;tour) {\n    double sum = 0.;\n    for (size_t i = 0; i &lt; tour.size() - 1; ++i) {\n        sum += distance(lon_[tour[i]], lat_[tour[i]], lon_[tour[i + 1]],\n                        lat_[tour[i + 1]]);\n    }\n    sum += distance(lon_[tour[tour.size() - 1]], lat_[tour[tour.size() - 1]],\n                    lon_[tour[0]], lat_[tour[0]]);\n    return sum;\n}\n\nvoid eurotrip_solver::draw() {\n    ax_-&gt;clear();\n\n    ax_-&gt;geolimits(min(lat_) - 5, max(lat_) + 5, min(lon_) - 2, max(lon_) + 10);\n\n    vector&lt;double&gt; sorted_lat;\n    vector&lt;double&gt; sorted_lon;\n    for (const size_t &amp;idx : best_tour_) {\n        sorted_lat.emplace_back(lat_[idx]);\n        sorted_lon.emplace_back(lon_[idx]);\n    }\n    sorted_lat.emplace_back(lat_[best_tour_[0]]);\n    sorted_lon.emplace_back(lon_[best_tour_[0]]);\n    ax_-&gt;geoplot(sorted_lat, sorted_lon);\n\n    ax_-&gt;hold(true);\n    ax_-&gt;geoscatter(lat_, lon_);\n\n    auto [lon_c, lat_c, names_c] =\n        clear_overlapping_labels(lon_, lat_, names_, 1, 1);\n    ax_-&gt;text(lon_c, lat_c, names_c);\n\n    ax_-&gt;title(\"Tour distance \" + num2str(min_dist_));\n\n    ax_-&gt;draw();\n}\n\nbool eurotrip_solver::update_if_better(const vector&lt;size_t&gt; &amp;neighbor) {\n    double d = tour_distance(neighbor);\n    if (d &lt; curr_dist_) {\n        curr_tour_ = neighbor;\n        curr_dist_ = d;\n        if (d &lt; min_dist_) {\n            best_tour_ = curr_tour_;\n            min_dist_ = d;\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid eurotrip_solver::draw_if_improvement() {\n    static auto last_draw =\n        chrono::high_resolution_clock::now() - chrono::seconds(1);\n    static auto min_dist_when_last_draw = min_dist_;\n    const auto current_time = chrono::high_resolution_clock::now();\n    const bool its_been_a_while = current_time - last_draw &gt; chrono::seconds(1);\n    const bool things_are_better = min_dist_ &lt; min_dist_when_last_draw;\n    if (its_been_a_while &amp;&amp; things_are_better) {\n        last_draw = current_time;\n        min_dist_when_last_draw = min_dist_;\n        draw();\n    }\n}\n\nint main() {\n    vector&lt;string&gt; names = {\"Tirana\",    \"Andorra la Vella\",\n                            \"Vienna\",    \"Minsk\",\n                            \"Brussels\",  \"Sarajevo\",\n                            \"Sofia\",     \"Zagreb\",\n                            \"Prague\",    \"Copenhagen\",\n                            \"Tallinn\",   \"Helsinki\",\n                            \"Paris\",     \"Berlin\",\n                            \"Athens\",    \"Budapest\",\n                            \"Reykjavik\", \"Dublin\",\n                            \"Rome\",      \"Pristina\",\n                            \"Riga\",      \"Vaduz\",\n                            \"Vilnius\",   \"Luxembourg\",\n                            \"Valletta\",  \"Chisinau\",\n                            \"Monaco\",    \"Podgorica\",\n                            \"Amsterdam\", \"Skopje\",\n                            \"Oslo\",      \"Warsaw\",\n                            \"Lisbon\",    \"Bucharest\",\n                            \"Moscow\",    \"San Marino\",\n                            \"Belgrade\",  \"Bratislava\",\n                            \"Ljubljana\", \"Madrid\",\n                            \"Stockholm\", \"Bern\",\n                            \"Kiev\",      \"London\"};\n\n    vector&lt;double&gt; lat = {\n        +41.3317, +42.5075, +48.2092, +53.9678, +50.8371, +43.8608, +42.7105,\n        +45.8150, +50.0878, +55.6763, +59.4389, +60.1699, +48.8567, +52.5235,\n        +37.9792, +47.4984, +64.1353, +53.3441, +41.8955, +42.6740, +56.9465,\n        +47.1411, +54.6896, +49.6100, +35.9042, +47.0167, +43.7325, +42.4602,\n        +52.3738, +42.0024, +59.9138, +52.2297, +38.7072, +44.4479, +55.7558,\n        +43.9424, +44.8048, +48.2116, +46.0514, +40.4167, +59.3328, +46.9480,\n        +50.4422, +51.5002};\n\n    vector&lt;double&gt; lon = {\n        +19.8172, +1.5218,  +16.3728, +27.5766, +4.3676,  +18.4214, +23.3238,\n        +15.9785, +14.4205, +12.5681, +24.7545, +24.9384, +2.3510,  +13.4115,\n        +23.7166, +19.0408, -21.8952, -6.2675,  +12.4823, +21.1788, +24.1049,\n        +9.5215,  +25.2799, +6.1296,  +14.5189, +28.8497, +7.4189,  +19.2595,\n        +4.8910,  +21.4361, +10.7387, +21.0122, -9.1355,  +26.0979, +37.6176,\n        +12.4578, +20.4781, +17.1547, +14.5060, -3.7033,  +18.0645, +7.4481,\n        +30.5367, -0.1262};\n\n    std::cout &lt;&lt; names.size() &lt;&lt; \" cities\" &lt;&lt; std::endl;\n\n    figure_handle f = figure(true);\n    eurotrip_solver s(lat, lon, names, f-&gt;current_axes());\n    s.run();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nusing namespace matplot;\nusing namespace std;\n\nclass americas_trip_solver {\n  public:\n    americas_trip_solver(const vector&lt;double&gt; &amp;lat, const vector&lt;double&gt; &amp;lon,\n                         const vector&lt;string&gt; &amp;names, axes_handle ax);\n    void run(size_t iterations = 100);\n\n  private:\n    void setup_axes();\n    void setup_starting_point(size_t iteration);\n    double tour_distance(const vector&lt;size_t&gt; &amp;tour);\n    void iteration();\n    static vector&lt;vector&lt;size_t&gt;&gt;\n    get_neighbors(const std::vector&lt;size_t&gt; &amp;tour);\n    bool update_if_better(const vector&lt;size_t&gt; &amp;neighbor);\n    void draw_if_improvement();\n    void draw();\n\n  private:\n    vector&lt;double&gt; lat_;\n    vector&lt;double&gt; lon_;\n    vector&lt;string&gt; names_;\n    axes_handle ax_;\n    line_handle lh_;\n\n    // Current tour\n    double curr_dist_{0.0};\n    vector&lt;size_t&gt; curr_tour_;\n\n    // Best tour\n    double min_dist_{0.0};\n    vector&lt;size_t&gt; best_tour_;\n};\n\namericas_trip_solver::americas_trip_solver(const vector&lt;double&gt; &amp;lat,\n                                           const vector&lt;double&gt; &amp;lon,\n                                           const vector&lt;string&gt; &amp;names,\n                                           axes_handle ax)\n    : lat_(lat), lon_(lon), names_(names), ax_(ax) {\n    setup_axes();\n}\n\nvoid americas_trip_solver::run(size_t iterations) {\n    for (size_t i = 0; i &lt; iterations; ++i) {\n        setup_starting_point(i);\n        iteration();\n    }\n    ax_-&gt;draw();\n    ax_-&gt;parent()-&gt;save(\"americastrip.svg\");\n}\n\nvoid americas_trip_solver::setup_starting_point(size_t iteration) {\n    std::cout &lt;&lt; \"Starting point \" &lt;&lt; iteration &lt;&lt; std::endl;\n    if (iteration &lt; names_.size()) {\n        auto [lon_ignore, lat_ignore, tour] =\n            greedy_tsp_with_idx(lon_, lat_, iteration);\n        curr_tour_ = tour;\n        curr_dist_ = tour_distance(curr_tour_);\n    } else {\n        static std::mt19937 g((std::random_device())());\n        std::iota(curr_tour_.begin(), curr_tour_.end(), 0);\n        std::shuffle(curr_tour_.begin(), curr_tour_.end(), g);\n        curr_dist_ = tour_distance(curr_tour_);\n    }\n    if (iteration == 0 || curr_dist_ &lt; min_dist_) {\n        best_tour_ = curr_tour_;\n        min_dist_ = curr_dist_;\n    }\n}\n\nvector&lt;vector&lt;size_t&gt;&gt;\namericas_trip_solver::get_neighbors(const std::vector&lt;size_t&gt; &amp;tour) {\n    vector&lt;vector&lt;size_t&gt;&gt; neighbors;\n    constexpr size_t n_movements = 2;\n    for (size_t i = 0; i &lt; tour.size() - 1; ++i) {\n        for (size_t j = i + 1; j &lt; tour.size(); ++j) {\n            for (size_t movement = 0; movement &lt; n_movements; ++movement) {\n                vector&lt;size_t&gt; neighbor = tour;\n                if (movement == 0) {\n                    std::swap(neighbor[i], neighbor[j]);\n                } else {\n                    std::reverse(neighbor.begin() + i,\n                                 neighbor.begin() + j + 1);\n                }\n                neighbors.emplace_back(neighbor);\n            }\n        }\n    }\n    return neighbors;\n}\n\nvoid americas_trip_solver::iteration() {\n    bool improvement = true;\n    while (improvement) {\n        improvement = false;\n        for (const auto &amp;neighbor : get_neighbors(curr_tour_)) {\n            improvement = update_if_better(neighbor);\n            draw_if_improvement();\n            if (improvement) {\n                break;\n            }\n        }\n    }\n}\n\ndouble americas_trip_solver::tour_distance(const vector&lt;size_t&gt; &amp;tour) {\n    double sum = 0.;\n    for (size_t i = 0; i &lt; tour.size() - 1; ++i) {\n        sum += distance(lon_[tour[i]], lat_[tour[i]], lon_[tour[i + 1]],\n                        lat_[tour[i + 1]]);\n    }\n    sum += distance(lon_[tour[tour.size() - 1]], lat_[tour[tour.size() - 1]],\n                    lon_[tour[0]], lat_[tour[0]]);\n    return sum;\n}\n\nvoid americas_trip_solver::draw() {\n    vector&lt;double&gt; sorted_lat;\n    vector&lt;double&gt; sorted_lon;\n    for (const size_t &amp;idx : best_tour_) {\n        sorted_lat.emplace_back(lat_[idx]);\n        sorted_lon.emplace_back(lon_[idx]);\n    }\n    sorted_lat.emplace_back(lat_[best_tour_[0]]);\n    sorted_lon.emplace_back(lon_[best_tour_[0]]);\n    lh_-&gt;x_data(sorted_lon);\n    lh_-&gt;y_data(sorted_lat);\n    ax_-&gt;title(\"Tour distance \" + num2str(min_dist_));\n    ax_-&gt;draw();\n}\n\nbool americas_trip_solver::update_if_better(const vector&lt;size_t&gt; &amp;neighbor) {\n    double d = tour_distance(neighbor);\n    if (d &lt; curr_dist_) {\n        curr_tour_ = neighbor;\n        curr_dist_ = d;\n        if (d &lt; min_dist_) {\n            best_tour_ = curr_tour_;\n            min_dist_ = d;\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid americas_trip_solver::draw_if_improvement() {\n    static auto last_draw =\n        chrono::high_resolution_clock::now() - chrono::seconds(1);\n    static auto min_dist_when_last_draw = min_dist_;\n    const auto current_time = chrono::high_resolution_clock::now();\n    const bool its_been_a_while = current_time - last_draw &gt; chrono::seconds(1);\n    const bool things_are_better = min_dist_ &lt; min_dist_when_last_draw;\n    if (its_been_a_while &amp;&amp; things_are_better) {\n        last_draw = current_time;\n        min_dist_when_last_draw = min_dist_;\n        draw();\n    }\n}\n\nvoid americas_trip_solver::setup_axes() {\n    ax_-&gt;clear();\n    ax_-&gt;geolimits(min(lat_) - 5, max(lat_) + 5, min(lon_) - 30,\n                   max(lon_) + 50);\n    lh_ = ax_-&gt;geoplot(lat_, lon_);\n    ax_-&gt;hold(true);\n    ax_-&gt;geoscatter(lat_, lon_);\n    auto [lon_c, lat_c, names_c] =\n        clear_overlapping_labels(lon_, lat_, names_, 2, 2);\n    ax_-&gt;text(lon_c, lat_c, names_c);\n    ax_-&gt;draw();\n}\n\nint main() {\n    vector&lt;string&gt; names = {\n        \"Marigot\",        \"The Valley\",     \"Saint John's\",    \"Buenos Aires\",\n        \"Oranjestad\",     \"Nassau\",         \"Bridgetown\",      \"Belmopan\",\n        \"Hamilton\",       \"La Paz\",         \"Brasilia\",        \"Road Town\",\n        \"Ottawa\",         \"George Town\",    \"Santiago\",        \"Bogota\",\n        \"San Jose\",       \"Havana\",         \"Willemstad\",      \"Roseau\",\n        \"Santo Domingo\",  \"Quito\",          \"San Salvador\",    \"Stanley\",\n        \"Nuuk\",           \"Saint George's\", \"Guatemala City\",  \"Georgetown\",\n        \"Port-au-Prince\", \"Tegucigalpa\",    \"Kingston\",        \"Mexico City\",\n        \"Plymouth\",       \"Managua\",        \"Panama City\",     \"Asuncion\",\n        \"Lima\",           \"San Juan\",       \"Gustavia\",        \"Basseterre\",\n        \"Castries\",       \"Saint-Pierre\",   \"Kingstown\",       \"Philipsburg\",\n        \"Paramaribo\",     \"Port of Spain\",  \"Grand Turk\",      \"Washington\",\n        \"Montevideo\",     \"Caracas\",        \"Charlotte Amalie\"};\n\n    vector&lt;double&gt; lat = {\n        18.0731,  18.2166, 17.1166, -34.5833, 12.5166, 25.0833, 13.1,\n        17.25,    32.2833, -16.5,   -15.7833, 18.4166, 45.4166, 19.3,\n        -33.45,   4.6,     9.9333,  23.1166,  12.1,    15.3,    18.4666,\n        -0.2166,  13.7,    -51.7,   64.1833,  12.05,   14.6166, 6.8,\n        18.5333,  14.1,    18,      19.4333,  16.7,    12.1333, 8.9666,\n        -25.2666, -12.05,  18.4666, 17.8833,  17.3,    14,      46.7666,\n        13.1333,  18.0166, 5.8333,  10.65,    21.4666, 38.8833, -34.85,\n        10.4833,  18.35};\n\n    vector&lt;double&gt; lon = {\n        -63.0822, -63.0500, -61.8500, -58.6666, -70.0333, -77.3500, -59.6166,\n        -88.7666, -64.7833, -68.1500, -47.9166, -64.6166, -75.7000, -81.3833,\n        -70.6666, -74.0833, -84.0833, -82.3500, -68.9166, -61.4000, -69.9000,\n        -78.5000, -89.2000, -57.8500, -51.7500, -61.7500, -90.5166, -58.1500,\n        -72.3333, -87.2166, -76.8000, -99.1333, -62.2166, -86.2500, -79.5333,\n        -57.6666, -77.0500, -66.1166, -62.8500, -62.7166, -61.0000, -56.1833,\n        -61.2166, -63.0333, -55.1666, -61.5166, -71.1333, -77.0000, -56.1666,\n        -66.8666, -64.9333};\n\n    figure_handle f = figure(true);\n    americas_trip_solver s(lat, lon, names, f-&gt;current_axes());\n    s.run();\n\n    show();\n    return 0;\n}\n</code></pre> <p>For the first geography plot, Matplot++ calls <code>geoplot()</code>, which creates a filled polygon with the world map. This first plot receives the tag <code>\"map\"</code> so that subsequent geography plots recognize there is no need to recreate this world map.</p> <p>The data for the world map comes from Natural Earth. They provide data at 1:10m, 1:50m, and 1:110m scales. The <code>geoplot</code> function will initially use the data at the 1:110m scales. The <code>geolimits</code> function can be used to update the axis limits for geography plots. The difference between the usual functions for adjusting axis limits (<code>xlim</code> and <code>ylim</code>) and <code>geolimits</code> is that the latter will also update the map resolution according to the new limits for the  and  axis.</p> <p>The <code>geolimits</code> function will query the <code>figure</code> size and, depending on the new limits for the axes, update the map to the 1:10m, or 1:50m scales if needed. Because it would be very inefficient to render the whole world map at a 1:10m or 1:50m scale only to display a region of this map, the <code>geolimits</code> function also crops the data pertinent to the new region being displayed.</p> <p>Note that this does not only involve removing data points outside the new limits but it also needs to create new data points on the correct borders to create new polygons coherent with the map entry points in the region. For this reason, the algorithm needs to track all submaps represented as closed polygons in the original world map. If submaps are completely inside or outside the new ranges, we can respectively include or dismiss the data points. However, if the submap is only partially inside the new limits, to generate the correct borders for the polygons, we need to track all points outside the limits to classify the directions of these points outside the limits. We do that by only including points that change quadrants around the new limits so that the map entry points create polygons that look like they would if the complete world map were still being rendered outside these new limits.</p> <p>If the you are not interested in geographic plots, the build script includes an option to remove the high-resolution maps at 1:10m and 1:50m scales from the library. In this case, the library will always use the map at a 1:110m scale no matter the axis limits.</p> <p>The function <code>world_cities</code> returns a list of major world cities. Its parameters define the minimum distances between cities in the  and  axes. The <code>greedy_tsp</code> function is a naive greedy algorithm to find a route between these cities as a Traveling Salesman Problem (TSP). We use the <code>geoplot</code> function to draw this route. Note that we use method chaining to define some further plot properties. Finally, the <code>text</code> function includes the city names in the map.</p>"},{"location":"plot-types/geography/geoscatter-plot/","title":"Geoscatter Plot","text":"<pre><code>geoscatter(lat,lon);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; lon = iota(-170, 10, 170);\n    std::vector&lt;double&gt; lat =\n        transform(lon, [](double x) { return 50. * cosd(3 * x); });\n    std::vector&lt;double&gt; A = transform(\n        lon, [](double lon) { return (101. + 100 * (sind(2 * lon))) / 7; });\n    std::vector&lt;double&gt; C =\n        transform(lon, [](double lon) { return cosd(4 * lon); });\n\n    geoscatter(lat, lon, A, C)\n        -&gt;marker_style(line_spec::marker_style::upward_pointing_triangle);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; lon = iota(-170, 10, 170);\n    std::vector&lt;double&gt; lat =\n        transform(lon, [](double lon) { return 50. * cosd(3 * lon); });\n    std::vector&lt;double&gt; A = transform(\n        lon, [](double lon) { return (101. + 100 * (sind(2 * lon))) / 7; });\n    std::vector&lt;double&gt; C =\n        transform(lon, [](double lon) { return cosd(4 * lon); });\n\n    geoscatter(lat, lon, A, C)\n        -&gt;marker_style(line_spec::marker_style::upward_pointing_triangle);\n\n    color_array terrain = {0.f, 0.71f, 0.65f, 0.59f};\n    geoplot()-&gt;color(terrain);\n\n    color_array blue_water = {0.f, 0.4f, 0.61f, 0.76f};\n    gca()-&gt;color(blue_water);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/graphs/directed-graph/","title":"Directed Graph","text":"<pre><code>digraph(edges);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges();\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; edges = {\n        {0, 1},   {0, 2},   {0, 3},   {0, 4},   {1, 5},  {1, 6},  {1, 7},\n        {1, 8},   {1, 9},   {1, 10},  {1, 11},  {1, 12}, {1, 13}, {1, 14},\n        {14, 15}, {14, 16}, {14, 17}, {14, 18}, {14, 19}};\n    digraph(edges);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; edges = {\n        {0, 1}, {0, 2}, {0, 3}, {1, 4}, {1, 5}, {2, 4},\n        {2, 6}, {3, 5}, {3, 6}, {4, 7}, {5, 7}, {6, 7}};\n    auto g = digraph(edges);\n    g-&gt;edge_labels(\n        {\"x\", \"y\", \"z\", \"y\", \"z\", \"x\", \"z\", \"x\", \"y\", \"z\", \"y\", \"x\"});\n    g-&gt;node_labels(\n        {\"{0}\", \"{x}\", \"{y}\", \"{z}\", \"{x,y}\", \"{x,z}\", \"{y,z}\", \"{x,y,z}\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; edges = {\n        {0, 1}, {0, 2}, {0, 9},  {1, 3},  {1, 11}, {2, 3},\n        {2, 4}, {3, 5}, {4, 5},  {4, 6},  {5, 8},  {6, 7},\n        {6, 9}, {7, 8}, {7, 10}, {8, 11}, {9, 10}, {10, 11}};\n    auto g = digraph(edges);\n    g-&gt;marker(\"s\");\n    g-&gt;node_color(\"red\");\n    g-&gt;marker_size(7);\n    g-&gt;line_style(\"--\");\n\n    g-&gt;x_data({2, 4, 1.5, 3.5, 1, 3, 1, 2.1, 3, 2, 3.1, 4});\n    g-&gt;y_data({3, 3, 3.5, 3.5, 4, 4, 2, 2, 2, 1, 1, 1});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/graphs/undirected-graph/","title":"Undirected Graph","text":"<pre><code>graph(edges);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges();\n\nint main() {\n    using namespace matplot;\n    auto edges = get_edges();\n    graph(edges);\n\n    show();\n    return 0;\n}\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges() {\n    return {\n        {0, 0},   {1, 0},   {5, 0},   {0, 1},   {1, 1},   {2, 1},   {6, 1},\n        {1, 2},   {2, 2},   {3, 2},   {7, 2},   {2, 3},   {3, 3},   {4, 3},\n        {8, 3},   {3, 4},   {4, 4},   {9, 4},   {0, 5},   {5, 5},   {6, 5},\n        {10, 5},  {1, 6},   {5, 6},   {6, 6},   {7, 6},   {11, 6},  {2, 7},\n        {6, 7},   {7, 7},   {8, 7},   {12, 7},  {3, 8},   {7, 8},   {8, 8},\n        {9, 8},   {13, 8},  {4, 9},   {8, 9},   {9, 9},   {14, 9},  {5, 10},\n        {10, 10}, {11, 10}, {15, 10}, {6, 11},  {10, 11}, {11, 11}, {12, 11},\n        {16, 11}, {7, 12},  {11, 12}, {12, 12}, {13, 12}, {17, 12}, {8, 13},\n        {12, 13}, {13, 13}, {14, 13}, {18, 13}, {9, 14},  {13, 14}, {14, 14},\n        {19, 14}, {10, 15}, {15, 15}, {16, 15}, {20, 15}, {11, 16}, {15, 16},\n        {16, 16}, {17, 16}, {21, 16}, {12, 17}, {16, 17}, {17, 17}, {18, 17},\n        {22, 17}, {13, 18}, {17, 18}, {18, 18}, {19, 18}, {23, 18}, {14, 19},\n        {18, 19}, {19, 19}, {24, 19}, {15, 20}, {20, 20}, {21, 20}, {25, 20},\n        {16, 21}, {20, 21}, {21, 21}, {22, 21}, {26, 21}, {17, 22}, {21, 22},\n        {22, 22}, {23, 22}, {27, 22}, {18, 23}, {22, 23}, {23, 23}, {24, 23},\n        {28, 23}, {19, 24}, {23, 24}, {24, 24}, {29, 24}, {20, 25}, {25, 25},\n        {26, 25}, {35, 25}, {21, 26}, {25, 26}, {26, 26}, {27, 26}, {36, 26},\n        {22, 27}, {26, 27}, {27, 27}, {28, 27}, {37, 27}, {23, 28}, {27, 28},\n        {28, 28}, {29, 28}, {38, 28}, {24, 29}, {28, 29}, {29, 29}, {30, 29},\n        {39, 29}, {29, 30}, {30, 30}, {31, 30}, {40, 30}, {30, 31}, {31, 31},\n        {32, 31}, {41, 31}, {31, 32}, {32, 32}, {33, 32}, {42, 32}, {32, 33},\n        {33, 33}, {34, 33}, {43, 33}, {33, 34}, {34, 34}, {44, 34}, {25, 35},\n        {35, 35}, {36, 35}, {45, 35}, {26, 36}, {35, 36}, {36, 36}, {37, 36},\n        {46, 36}, {27, 37}, {36, 37}, {37, 37}, {38, 37}, {47, 37}, {28, 38},\n        {37, 38}, {38, 38}, {39, 38}, {48, 38}, {29, 39}, {38, 39}, {39, 39},\n        {40, 39}, {49, 39}, {30, 40}, {39, 40}, {40, 40}, {41, 40}, {50, 40},\n        {31, 41}, {40, 41}, {41, 41}, {42, 41}, {51, 41}, {32, 42}, {41, 42},\n        {42, 42}, {43, 42}, {52, 42}, {33, 43}, {42, 43}, {43, 43}, {44, 43},\n        {53, 43}, {34, 44}, {43, 44}, {44, 44}, {54, 44}, {35, 45}, {45, 45},\n        {46, 45}, {55, 45}, {36, 46}, {45, 46}, {46, 46}, {47, 46}, {56, 46},\n        {37, 47}, {46, 47}, {47, 47}, {48, 47}, {57, 47}, {38, 48}, {47, 48},\n        {48, 48}, {49, 48}, {58, 48}, {39, 49}, {48, 49}, {49, 49}, {50, 49},\n        {59, 49}, {40, 50}, {49, 50}, {50, 50}, {51, 50}, {60, 50}, {41, 51},\n        {50, 51}, {51, 51}, {52, 51}, {61, 51}, {42, 52}, {51, 52}, {52, 52},\n        {53, 52}, {62, 52}, {43, 53}, {52, 53}, {53, 53}, {54, 53}, {63, 53},\n        {44, 54}, {53, 54}, {54, 54}, {64, 54}, {45, 55}, {55, 55}, {56, 55},\n        {65, 55}, {46, 56}, {55, 56}, {56, 56}, {57, 56}, {66, 56}, {47, 57},\n        {56, 57}, {57, 57}, {58, 57}, {67, 57}, {48, 58}, {57, 58}, {58, 58},\n        {59, 58}, {68, 58}, {49, 59}, {58, 59}, {59, 59}, {60, 59}, {69, 59},\n        {50, 60}, {59, 60}, {60, 60}, {61, 60}, {70, 60}, {51, 61}, {60, 61},\n        {61, 61}, {62, 61}, {71, 61}, {52, 62}, {61, 62}, {62, 62}, {63, 62},\n        {72, 62}, {53, 63}, {62, 63}, {63, 63}, {64, 63}, {73, 63}, {54, 64},\n        {63, 64}, {64, 64}, {74, 64}, {55, 65}, {65, 65}, {66, 65}, {56, 66},\n        {65, 66}, {66, 66}, {67, 66}, {57, 67}, {66, 67}, {67, 67}, {68, 67},\n        {58, 68}, {67, 68}, {68, 68}, {69, 68}, {59, 69}, {68, 69}, {69, 69},\n        {70, 69}, {60, 70}, {69, 70}, {70, 70}, {71, 70}, {61, 71}, {70, 71},\n        {71, 71}, {72, 71}, {62, 72}, {71, 72}, {72, 72}, {73, 72}, {63, 73},\n        {72, 73}, {73, 73}, {74, 73}, {64, 74}, {73, 74}, {74, 74}};\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges();\n\nint main() {\n    using namespace matplot;\n    auto edges = get_edges();\n    graph(edges, \"-.dr\")-&gt;show_labels(false);\n\n    show();\n    return 0;\n}\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges() {\n    return {\n        {0, 1},   {0, 4},   {0, 5},   {1, 2},   {1, 10},  {2, 3},   {2, 15},\n        {3, 4},   {3, 20},  {4, 25},  {5, 6},   {5, 9},   {6, 7},   {6, 29},\n        {7, 8},   {7, 41},  {8, 9},   {8, 37},  {9, 11},  {10, 11}, {10, 14},\n        {11, 12}, {12, 13}, {12, 36}, {13, 14}, {13, 32}, {14, 16}, {15, 16},\n        {15, 19}, {16, 17}, {17, 18}, {17, 31}, {18, 19}, {18, 52}, {19, 21},\n        {20, 21}, {20, 24}, {21, 22}, {22, 23}, {22, 51}, {23, 24}, {23, 47},\n        {24, 26}, {25, 26}, {25, 29}, {26, 27}, {27, 28}, {27, 46}, {28, 29},\n        {28, 42}, {30, 31}, {30, 34}, {30, 53}, {31, 32}, {32, 33}, {33, 34},\n        {33, 35}, {34, 55}, {35, 36}, {35, 39}, {36, 37}, {37, 38}, {38, 39},\n        {38, 40}, {39, 56}, {40, 41}, {40, 44}, {41, 42}, {42, 43}, {43, 44},\n        {43, 45}, {44, 57}, {45, 46}, {45, 49}, {46, 47}, {47, 48}, {48, 49},\n        {48, 50}, {49, 58}, {50, 51}, {50, 54}, {51, 52}, {52, 53}, {53, 54},\n        {54, 59}, {55, 56}, {55, 59}, {56, 57}, {57, 58}, {58, 59}};\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; edges = {\n        {0, 1}, {0, 2},  {0, 3}, {0, 4}, {0, 6},  {0, 9}, {1, 5},\n        {1, 6}, {2, 5},  {2, 9}, {3, 7}, {3, 9},  {4, 6}, {4, 7},\n        {5, 8}, {5, 10}, {6, 8}, {7, 8}, {7, 10}, {9, 10}};\n    std::vector&lt;double&gt; weights = {1, 1, 1, 1, 3, 3, 2,  4,  1,  6,\n                                   2, 8, 8, 9, 3, 2, 10, 12, 15, 16};\n    auto g = graph(edges);\n\n    g-&gt;x_data({0, 0.5, -0.5, -0.5, 0.5, 0, 1.5, 0, 2, -1.5, -2});\n    g-&gt;y_data({0, 0.5, 0.5, -0.5, -0.5, 2, 0, -2, 0, 0, 0});\n    g-&gt;z_data({5, 3, 3, 3, 3, 0, 1, 0, 0, 1, 0});\n\n    g-&gt;edge_labels(weights);\n    view(2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; edges = {\n        {0, 1}, {0, 2}, {0, 3}, {0, 4}, {1, 2}, {1, 5},\n        {2, 5}, {3, 4}, {3, 6}, {4, 6}, {5, 6}};\n    std::vector&lt;double&gt; weights = {50, 10, 20, 80, 90, 90, 30, 20, 100, 40, 60};\n    auto g = graph(edges);\n    g-&gt;edge_labels(weights);\n\n    double m_weight = max(weights);\n    std::vector&lt;double&gt; line_widths =\n        transform(weights, [&amp;](double w) { return 5. * w / m_weight; });\n    g-&gt;line_widths(line_widths);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges();\n\nint main() {\n    using namespace matplot;\n    auto edges = get_edges();\n    auto g = graph(edges);\n    g-&gt;layout_algorithm(network::layout::force);\n\n    for (int i = 0; i &lt; 300; ++i) {\n        g-&gt;layout_iterations(i);\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    show();\n    return 0;\n}\n\nstd::vector&lt;std::pair&lt;size_t, size_t&gt;&gt; get_edges() {\n    return {\n        {0, 0},   {1, 0},   {5, 0},   {0, 1},   {1, 1},   {2, 1},   {6, 1},\n        {1, 2},   {2, 2},   {3, 2},   {7, 2},   {2, 3},   {3, 3},   {4, 3},\n        {8, 3},   {3, 4},   {4, 4},   {9, 4},   {0, 5},   {5, 5},   {6, 5},\n        {10, 5},  {1, 6},   {5, 6},   {6, 6},   {7, 6},   {11, 6},  {2, 7},\n        {6, 7},   {7, 7},   {8, 7},   {12, 7},  {3, 8},   {7, 8},   {8, 8},\n        {9, 8},   {13, 8},  {4, 9},   {8, 9},   {9, 9},   {14, 9},  {5, 10},\n        {10, 10}, {11, 10}, {15, 10}, {6, 11},  {10, 11}, {11, 11}, {12, 11},\n        {16, 11}, {7, 12},  {11, 12}, {12, 12}, {13, 12}, {17, 12}, {8, 13},\n        {12, 13}, {13, 13}, {14, 13}, {18, 13}, {9, 14},  {13, 14}, {14, 14},\n        {19, 14}, {10, 15}, {15, 15}, {16, 15}, {20, 15}, {11, 16}, {15, 16},\n        {16, 16}, {17, 16}, {21, 16}, {12, 17}, {16, 17}, {17, 17}, {18, 17},\n        {22, 17}, {13, 18}, {17, 18}, {18, 18}, {19, 18}, {23, 18}, {14, 19},\n        {18, 19}, {19, 19}, {24, 19}, {15, 20}, {20, 20}, {21, 20}, {25, 20},\n        {16, 21}, {20, 21}, {21, 21}, {22, 21}, {26, 21}, {17, 22}, {21, 22},\n        {22, 22}, {23, 22}, {27, 22}, {18, 23}, {22, 23}, {23, 23}, {24, 23},\n        {28, 23}, {19, 24}, {23, 24}, {24, 24}, {29, 24}, {20, 25}, {25, 25},\n        {26, 25}, {35, 25}, {21, 26}, {25, 26}, {26, 26}, {27, 26}, {36, 26},\n        {22, 27}, {26, 27}, {27, 27}, {28, 27}, {37, 27}, {23, 28}, {27, 28},\n        {28, 28}, {29, 28}, {38, 28}, {24, 29}, {28, 29}, {29, 29}, {30, 29},\n        {39, 29}, {29, 30}, {30, 30}, {31, 30}, {40, 30}, {30, 31}, {31, 31},\n        {32, 31}, {41, 31}, {31, 32}, {32, 32}, {33, 32}, {42, 32}, {32, 33},\n        {33, 33}, {34, 33}, {43, 33}, {33, 34}, {34, 34}, {44, 34}, {25, 35},\n        {35, 35}, {36, 35}, {45, 35}, {26, 36}, {35, 36}, {36, 36}, {37, 36},\n        {46, 36}, {27, 37}, {36, 37}, {37, 37}, {38, 37}, {47, 37}, {28, 38},\n        {37, 38}, {38, 38}, {39, 38}, {48, 38}, {29, 39}, {38, 39}, {39, 39},\n        {40, 39}, {49, 39}, {30, 40}, {39, 40}, {40, 40}, {41, 40}, {50, 40},\n        {31, 41}, {40, 41}, {41, 41}, {42, 41}, {51, 41}, {32, 42}, {41, 42},\n        {42, 42}, {43, 42}, {52, 42}, {33, 43}, {42, 43}, {43, 43}, {44, 43},\n        {53, 43}, {34, 44}, {43, 44}, {44, 44}, {54, 44}, {35, 45}, {45, 45},\n        {46, 45}, {55, 45}, {36, 46}, {45, 46}, {46, 46}, {47, 46}, {56, 46},\n        {37, 47}, {46, 47}, {47, 47}, {48, 47}, {57, 47}, {38, 48}, {47, 48},\n        {48, 48}, {49, 48}, {58, 48}, {39, 49}, {48, 49}, {49, 49}, {50, 49},\n        {59, 49}, {40, 50}, {49, 50}, {50, 50}, {51, 50}, {60, 50}, {41, 51},\n        {50, 51}, {51, 51}, {52, 51}, {61, 51}, {42, 52}, {51, 52}, {52, 52},\n        {53, 52}, {62, 52}, {43, 53}, {52, 53}, {53, 53}, {54, 53}, {63, 53},\n        {44, 54}, {53, 54}, {54, 54}, {64, 54}, {45, 55}, {55, 55}, {56, 55},\n        {65, 55}, {46, 56}, {55, 56}, {56, 56}, {57, 56}, {66, 56}, {47, 57},\n        {56, 57}, {57, 57}, {58, 57}, {67, 57}, {48, 58}, {57, 58}, {58, 58},\n        {59, 58}, {68, 58}, {49, 59}, {58, 59}, {59, 59}, {60, 59}, {69, 59},\n        {50, 60}, {59, 60}, {60, 60}, {61, 60}, {70, 60}, {51, 61}, {60, 61},\n        {61, 61}, {62, 61}, {71, 61}, {52, 62}, {61, 62}, {62, 62}, {63, 62},\n        {72, 62}, {53, 63}, {62, 63}, {63, 63}, {64, 63}, {73, 63}, {54, 64},\n        {63, 64}, {64, 64}, {74, 64}, {55, 65}, {65, 65}, {66, 65}, {56, 66},\n        {65, 66}, {66, 66}, {67, 66}, {57, 67}, {66, 67}, {67, 67}, {68, 67},\n        {58, 68}, {67, 68}, {68, 68}, {69, 68}, {59, 69}, {68, 69}, {69, 69},\n        {70, 69}, {60, 70}, {69, 70}, {70, 70}, {71, 70}, {61, 71}, {70, 71},\n        {71, 71}, {72, 71}, {62, 72}, {71, 72}, {72, 72}, {73, 72}, {63, 73},\n        {72, 73}, {73, 73}, {74, 73}, {64, 74}, {73, 74}, {74, 74}};\n}\n</code></pre> <p>All these subcategories depend on the <code>network</code> class. Graphs are abstract structures that represent objects and relationships between these objects. The objects are represented as vertices and the relationships are depicted as edges.</p> <p>In an abstract graph, the vertices have no specific position in space. Mathematically, a graph does not depend on its layout. However, the graph layout has a large impact on its understandability. The <code>network</code> class can calculate appropriate positions for graph vertices with several algorithms: Kamada Kawai algorithm, Fruchterman-Reingold algorithm, circle layout, random layout, and automatic layout.</p> <p>The implementation of the Kamada Kawai and Fruchterman-Reingold algorithms depend on the NodeSoup library. The automatic layout uses the Kamada Kawai algorithm for small graphs and the Fruchterman-Reingold algorithm for larger graphs.</p>"},{"location":"plot-types/images/image-matrix/","title":"Image Matrix","text":"<pre><code>image(C);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    image(C);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    image(C, true);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    image(5, 8, 3, 6, C);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::tuple&lt;vector_2d, vector_2d, vector_2d&gt; C;\n    auto &amp;[r, g, b] = C;\n    r = transform(vector_2d{{.1, .2, .3}, {.4, .5, .6}, {.7, .8, .9}},\n                  [](double x) { return x * 255; });\n    g = zeros(3, 3);\n    b = zeros(3, 3);\n\n    image(C);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    plot(iota(1, 3));\n    hold(on);\n    vector_2d C = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    auto im = image(C);\n    im-&gt;alpha(0.5);\n    gca()-&gt;y_axis().reverse(false);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/images/image-show/","title":"Image Show","text":"<pre><code>imshow(image);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto image = imread(\"lena_gray.tiff\");\n    imshow(image);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto image = imread(\"lena_color.tiff\");\n    imshow(image);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto image = imread(\"lena_gray.tiff\");\n\n    auto &amp;gray = image[0];\n    auto [h, w] = size(gray);\n    double mean_intensity = 0;\n    for (const auto &amp;row : gray) {\n        for (const auto &amp;pixel : row) {\n            mean_intensity += pixel;\n        }\n    }\n    mean_intensity /= (h * w);\n\n    for (auto &amp;row : gray) {\n        for (auto &amp;pixel : row) {\n            pixel = pixel &gt; mean_intensity ? 255 : 0;\n        }\n    }\n\n    imshow(gray);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    imshow(\"lena_color.tiff\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto image = imread(\"lena_gray.tiff\");\n    imshow(image[0]);\n    colormap(palette::greens());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto image = imread(\"lena_gray.tiff\");\n    imshow(image[0]);\n    colormap(palette::default_map());\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    image_channels_t image = imread(\"lena_color.tiff\");\n    image = imvignette(image);\n    imshow(image);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    image_channels_t image = imread(\"lena_gray.tiff\");\n    image = imvignette(image);\n    imshow(image);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    image_channels_t image = imread(\"lena_color.tiff\");\n    image = imresize(image, 0.1, image_interpolation::bilinear);\n    imshow(image);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    image_channels_t image = imread(\"lena_color.tiff\");\n    image = imvignette(image);\n\n    auto image_to_show = imresize(image, 0.5);\n    imshow(image_to_show);\n\n    auto image_to_save = imresize(image, 2., image_interpolation::bicubic);\n    imwrite(image_to_save, \"lena_bicubic.tiff\");\n\n    imwrite(imresize(image, 2., image_interpolation::bilinear),\n            \"lena_bilinear.tiff\");\n\n    imwrite(imresize(image, 2., image_interpolation::grid), \"lena_grid.tiff\");\n\n    imwrite(imresize(image, 2., image_interpolation::lanczos),\n            \"lena_lanczos.tiff\");\n\n    imwrite(imresize(image, 2., image_interpolation::moving_average),\n            \"lena_moving_average.tiff\");\n\n    imwrite(imresize(image, 2., image_interpolation::nearest),\n            \"lena_nearest.tiff\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    image_channels_t image = imread(\"lena_gray.tiff\");\n\n    imshow(image[0]);\n    colormap(palette::blues());\n\n    imwrite(image[0], palette::blues(), \"lena_blues.tiff\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>These subcategories depend on the <code>matrix</code> class. The <code>matrix</code> class can have up to four matrices. If it has only one matrix, it is represented with a colormap. If it has three matrices, they represent the red, green, and blue channels. If it has four matrices, the fourth matrix represents an alpha channel to control the transparency of each pixel.</p> <p>We use the CImg library to load and save images. CImg can handle many common image formats as long as it has access to the appropriate libraries. The Matplot++ build script will look at compile-time for the following optional libraries: JPEG, TIFF, ZLIB, PNG, LAPACK, BLAS, OpenCV, X11, fftw3, OpenEXR, and Magick++. The build script will attempt to link all libraries from this list to Matplot++.</p> <p>Matplot++ includes a few convenience functions to manipulate matrices with images: <code>imread</code>, <code>rgb2gray</code>, <code>gray2rgb</code>, <code>imresize</code>, and <code>imwrite</code>. All these functions work with lists of matrices. </p>"},{"location":"plot-types/images/scaled-image/","title":"Scaled Image","text":"<pre><code>imagesc(C);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    imagesc(C);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    imagesc(5, 8, 3, 6, C);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    imagesc(5, 8, 3, 6, C);\n    gca()-&gt;color_box_range(4, 18);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;std::vector&lt;double&gt;&gt; C = {\n        {0, 2, 4, 6}, {8, 10, 12, 14}, {16, 18, 20, 22}};\n    auto im = imagesc(5, 8, 3, 6, C);\n    gca()-&gt;color_box_range(4, 18);\n    im-&gt;alpha(0.5);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/area/","title":"Area","text":"<pre><code>area(Y);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {1, 3, 1, 2}, {5, 2, 5, 6}, {3, 7, 3, 1}};\n\n    auto f = gcf();\n    f-&gt;width(f-&gt;width() * 2);\n\n    subplot(1, 2, 0);\n    area(Y);\n    title(\"Stacked\");\n\n    subplot(1, 2, 1);\n    area(Y, false);\n    title(\"Not stacked\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {1, 3, 1, 2}, {5, 2, 5, 6}, {3, 7, 3, 1}};\n\n    auto f = gcf();\n    f-&gt;width(f-&gt;width() * 2);\n\n    subplot(1, 2, 0);\n    area(Y, -4.);\n    title(\"Stacked\");\n\n    subplot(1, 2, 1);\n    area(Y, -4, false);\n    title(\"Not stacked\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {1, 3, 1, 2}, {5, 2, 5, 6}, {3, 7, 3, 1}};\n\n    auto f = gcf();\n    f-&gt;width(f-&gt;width() * 2);\n\n    subplot(1, 2, 0);\n    auto h1 = area(Y, -4.);\n    h1[0]-&gt;line_style(\":\");\n    h1[1]-&gt;line_style(\":\");\n    h1[2]-&gt;line_style(\":\");\n    h1[0]-&gt;face_color({0, 0, 0.25, 0.25});\n    h1[1]-&gt;face_color({0, 0, 0.5, 0.5});\n    h1[2]-&gt;face_color({0, 0, 0.75, 0.75});\n    title(\"Stacked\");\n\n    subplot(1, 2, 1);\n    auto h2 = area(Y, -4, false);\n    h2[0]-&gt;line_style(\":\");\n    h2[1]-&gt;line_style(\":\");\n    h2[2]-&gt;line_style(\":\");\n    h2[0]-&gt;face_color({0.2f, 0.f, 0.25f, 0.25f});\n    h2[1]-&gt;face_color({0.2f, 0.f, 0.5f, 0.5f});\n    h2[2]-&gt;face_color({0.2f, 0.f, 0.75f, 0.75f});\n    title(\"Not stacked\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {1, 3, 4, 0}, {2, 5, 4, 7}, {6, 4, 5, 3}};\n\n    auto f = gcf();\n    f-&gt;width(f-&gt;width() * 2);\n\n    subplot(1, 2, 0);\n    area(Y, -4.);\n    title(\"Stacked\");\n\n    subplot(1, 2, 1);\n    area(Y, -4, false);\n    title(\"Not stacked\");\n\n    save(\"area_4.svg\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/error-bars/","title":"Error Bars","text":"<pre><code>errorbar(x,y,err);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; err(y.size(), 10.);\n    errorbar(x, y, err);\n    axis({0, 100, 0, 110});\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; err(y.size(), 10.);\n    errorbar(x, y, err)-&gt;filled_curve(true);\n\n    axis({0, 100, 0, 110});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; err = {5, 8, 2, 9, 3, 3, 8, 3, 9, 3};\n    errorbar(x, y, err);\n    axis({0, 100, 0, 110});\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; err = {1, 3, 5, 3, 5, 3, 6, 4, 3, 3};\n    errorbar(x, y, err, error_bar::type::horizontal);\n    axis({0, 100, 0, 110});\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; err = {4, 3, 5, 3, 5, 3, 6, 4, 3, 3};\n    errorbar(x, y, err, error_bar::type::both);\n    axis({0, 100, 0, 110});\n    axis(equal);\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; err = {4, 3, 5, 3, 5, 3, 6, 4, 3, 3};\n    errorbar(x, y, err, error_bar::type::both, \"o\");\n    axis({0, 100, 0, 100});\n    axis(equal);\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 10, 100);\n    std::vector&lt;double&gt; y = {20, 30, 45, 40, 60, 65, 80, 75, 95, 90};\n    std::vector&lt;double&gt; yneg = {1, 3, 5, 3, 5, 3, 6, 4, 3, 3};\n    std::vector&lt;double&gt; ypos = {2, 5, 3, 5, 2, 5, 2, 2, 5, 5};\n    std::vector&lt;double&gt; xneg = {1, 3, 5, 3, 5, 3, 6, 4, 3, 3};\n    std::vector&lt;double&gt; xpos = {2, 5, 3, 5, 2, 5, 2, 2, 5, 5};\n\n    errorbar(x, y, yneg, ypos, xneg, xpos, \"o\");\n    axis({0, 100, 0, 100});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 10, 15);\n    std::vector&lt;double&gt; y = transform(x, [](double x) { return sin(x / 2); });\n    std::vector&lt;double&gt; err(y.size(), 0.3);\n\n    auto e = errorbar(x, y, err, \"-s\")\n                 -&gt;marker_size(10)\n                 .marker_color(\"red\")\n                 .marker_face_color(\"red\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 2, 15);\n    std::vector&lt;double&gt; y = transform(x, [](double x) { return exp(x); });\n    std::vector&lt;double&gt; err(y.size(), 0.3);\n\n    auto e = errorbar(x, y, err)-&gt;cap_size(18);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 10, 10);\n    std::vector&lt;double&gt; y = transform(x, [](double x) { return sin(x / 2.); });\n    std::vector&lt;double&gt; err(y.size(), 0.3);\n\n    auto e =\n        errorbar(x, y, err)-&gt;cap_size(15).marker(\"*\").marker_size(10).color(\n            \"red\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>The <code>error bar</code> object includes extra lines to represent error around data points. Log plots are utility functions that adjust the x or y axes to a logarithmic scale. </p>"},{"location":"plot-types/line-plots/function-plot-3d/","title":"Function Plot 3D","text":"<pre><code>fplot(fxy);\n</code></pre> Plot C++ <p>```cpp</p>"},{"location":"plot-types/line-plots/function-plot-3d/#include","title":"include","text":""},{"location":"plot-types/line-plots/function-plot-3d/#include_1","title":"include  <p>int main() {     using namespace matplot;</p> <pre><code>auto xt = [](double t) { return sin(t); };\nauto yt = [](double t) { return cos(t); };\nauto zt = [](double t) { return t; };\nfplot3(xt, yt, zt);\n\nshow();\nreturn 0;\n</code></pre> <p>} `````</p>   <p>More examples</p> Plot <p></p>  C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto xt = [](double t) { return exp(-t / 10.) * sin(5 * t); };\n    auto yt = [](double t) { return exp(-t / 10.) * cos(5 * t); };\n    auto zt = [](double t) { return t; };\n    fplot3(xt, yt, zt, std::array&lt;double, 2&gt;{-10, 10});\n\n    show();\n    return 0;\n}\n</code></pre>   Plot <p></p>  C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto sin_t = [](double t) { return sin(t); };\n    auto cos_t = [](double t) { return cos(t); };\n    auto t_t = [](double t) { return t; };\n    auto fp = fplot3(sin_t, cos_t, t_t, std::array&lt;double, 2&gt;{0, 2 * pi})\n                  -&gt;line_width(2);\n    hold(on);\n    fplot3(sin_t, cos_t, t_t, std::array&lt;double, 2&gt;{2 * pi, 4 * pi}, \"--or\");\n    fplot3(sin_t, cos_t, t_t, std::array&lt;double, 2&gt;{4 * pi, 6 * pi}, \"-.*c\");\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre>   Plot <p></p>  C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto xt = [](double t) {\n        return exp(-std::abs(t) / 10) * sin(5 * std::abs(t));\n    };\n    auto yt = [](double t) {\n        return exp(-std::abs(t) / 10) * cos(5 * std::abs(t));\n    };\n    auto zt = [](double t) { return t; };\n    auto fp = fplot3(xt, yt, zt)-&gt;t_range({-10, 10}).color(\"r\");\n    xlabel(\"e^{-|z|/10} sin(2|z|)\");\n    ylabel(\"e^{-|z|/10} cos(2|z|)\");\n    zlabel(\"z\");\n    grid(true);\n\n    auto ax = gca();\n    float da = ax-&gt;azimuth();\n    float de = ax-&gt;elevation();\n    for (size_t i = 0; i &lt;= 180; ++i) {\n        view(da + 2 * i, de + i);\n        title(\"Azimuth: \" + num2str(da + 2 * i) +\n              \" Elevation: \" + num2str(de + i));\n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n\n    show();\n    return 0;\n}\n</code></pre>   Plot <p></p>  C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto xt = [](double t) { return t; };\n    auto yt = [](double t) { return t / 2.; };\n    auto zt = [](double t) { return sin(6. * t); };\n    fplot3(xt, yt, zt, std::array&lt;double, 2&gt;{-2 * pi, 2 * pi})\n        -&gt;mesh_density(300)\n        .line_width(1);\n\n    title(\"x=t, y=t/2, z=sin(6t) for -2\u03c0&lt;t&lt;2\u03c0\");\n    xlabel(\"x\");\n    ylabel(\"y\");\n    view(52.5, 30);\n    box(on);\n    xrange({-2 * pi, +2 * pi});\n    yrange({-pi, +pi});\n\n    auto ax = gca();\n    ax-&gt;xticks(iota(-2 * pi, pi / 2, 2 * pi));\n    ax-&gt;x_axis().ticklabels(\n        {\"-2\u03c0\", \"-3\u03c0/2\", \"-\u03c0\", \"-\u03c0/2\", \"0\", \"\u03c0/2\", \"\u03c0\", \"3\u03c0/2\", \"\u03c0\"});\n    ax-&gt;yticks(iota(-pi, pi / 2, pi));\n    ax-&gt;y_axis().ticklabels({\"-\u03c0\", \"-\u03c0/2\", \"0\", \"\u03c0/2\", \"\u03c0\"});\n\n    show();\n    return 0;\n}\n</code></pre>","text":""},{"location":"plot-types/line-plots/function-plot/","title":"Function Plot","text":"<pre><code>fplot(fx);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot(\"cos(x)\", \"o-r\")-&gt;line_width(2);\n    hold(on);\n    fplot([](double x) { return sin(x); }, std::array&lt;double, 2&gt;{-10, 10},\n          \"x--b\")\n        -&gt;line_width(2);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot([](double t) { return cos(3 * t); },\n          [](double t) { return sin(2 * t); });\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot([](double x) { return exp(x); }, std::array&lt;double, 2&gt;{-3, 0}, \"b\");\n    hold(on);\n    fplot([](double x) { return cos(x); }, std::array&lt;double, 2&gt;{0, 3}, \"b\");\n    hold(off);\n    grid(on);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto f = fplot([](double x) { return sin(x + pi / 5); });\n    f-&gt;line_width(2);\n    hold(on);\n    fplot([](double x) { return sin(x - pi / 5); }, \"--or\");\n    fplot([](double x) { return sin(x); }, \"-.*c\");\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto fp = fplot([](double x) { return sin(x); });\n    fp-&gt;line_style(\":\");\n    fp-&gt;color(\"r\");\n    fp-&gt;marker(\"x\");\n    fp-&gt;marker_color(\"b\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fplot([](double x) { return sin(x); },\n          std::array&lt;double, 2&gt;{-2 * pi, 2 * pi});\n    grid(on);\n    title(\"sin(x) from -2\u03c0 to 2\u03c0\");\n    xlabel(\"x\");\n    ylabel(\"y\");\n\n    auto ax = gca();\n    ax-&gt;x_axis().tick_values(iota(-2 * pi, pi / 2, 2 * pi));\n    ax-&gt;x_axis().ticklabels(\n        {\"-2\u03c0\", \"-3\u03c0/2\", \"-\u03c0\", \"-\u03c0/2\", \"0\", \"\u03c0/2\", \"\u03c0\", \"3\u03c0/2\", \"2\u03c0\"});\n\n    show();\n    return 0;\n}\n</code></pre> <p>Instead of storing data points, the objects <code>function line</code> and <code>string function</code> store a function as a lambda function or as a string with an expression. These objects use lazy evaluation to generate absolute data points. The data is generated only when the <code>draw</code> function is called.</p>"},{"location":"plot-types/line-plots/implicit-function/","title":"Implicit function","text":"<pre><code>fplot(fxy);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fimplicit([](double x, double y) { return pow(x, 2) - pow(y, 2) - 1; });\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fimplicit([](double x, double y) { return pow(x, 2) + pow(y, 2) - 3; },\n              std::array&lt;double, 4&gt;{-3, 0, -2, 2});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fimplicit([](double x, double y) { return pow(x, 2) + pow(y, 2) - 1; });\n    hold(on);\n    fimplicit([](double x, double y) { return pow(x, 2) + pow(y, 2) - 2; },\n              \"--g\")\n        -&gt;line_width(2);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fimplicit([](double x, double y) { return y * sin(x) + x * cos(y); })\n        -&gt;color(\"r\")\n        .line_style(\"--\")\n        .line_width(2);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/line-plot-3d/","title":"Line Plot 3D","text":"<pre><code>plot3(x,y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; t = iota(0, pi / 50, 10 * pi);\n    std::vector&lt;double&gt; st = transform(t, [](auto x) { return sin(x); });\n    std::vector&lt;double&gt; ct = transform(t, [](auto x) { return cos(x); });\n    auto l = plot3(st, ct, t);\n    show();\n    return 0;\n}\n</code></pre> <p>Tip</p> <p>With method chaining:</p> <pre><code>plot3(x,y)-&gt;line_width(2).color(\"red\");\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; t = iota(0, pi / 500, pi);\n    std::vector&lt;double&gt; xt1 =\n        transform(t, [](auto x) { return sin(x) * cos(10 * x); });\n    std::vector&lt;double&gt; yt1 =\n        transform(t, [](auto x) { return sin(x) * sin(10 * x); });\n    std::vector&lt;double&gt; zt1 = transform(t, [](auto x) { return cos(x); });\n    std::vector&lt;double&gt; xt2 =\n        transform(t, [](auto x) { return sin(x) * cos(12 * x); });\n    std::vector&lt;double&gt; yt2 =\n        transform(t, [](auto x) { return sin(x) * sin(12 * x); });\n    std::vector&lt;double&gt; zt2 = transform(t, [](auto x) { return cos(x); });\n    plot3(xt1, yt1, zt1, xt2, yt2, zt2);\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; t = iota(0, pi / 500, pi);\n    std::vector&lt;std::vector&lt;double&gt;&gt; X(3);\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(3);\n\n    X[0] = transform(t, [](auto x) { return sin(x) * cos(10 * x); });\n    X[1] = transform(t, [](auto x) { return sin(x) * cos(12 * x); });\n    X[2] = transform(t, [](auto x) { return sin(x) * cos(20 * x); });\n    Y[0] = transform(t, [](auto x) { return sin(x) * sin(10 * x); });\n    Y[1] = transform(t, [](auto x) { return sin(x) * sin(12 * x); });\n    Y[2] = transform(t, [](auto x) { return sin(x) * sin(20 * x); });\n    std::vector&lt;double&gt; z = transform(t, [](auto x) { return cos(x); });\n    plot3(X, Y, z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;thread&gt;\n\nint main() {\n    using namespace matplot;\n    auto t = iota(0, pi / 500, 40 * pi);\n    auto xt =\n        transform(t, [](auto t) { return (3. + cos(sqrt(32.) * t)) * cos(t); });\n    auto yt = transform(t, [](auto t) { return sin(sqrt(32.) * t); });\n    auto zt =\n        transform(t, [](auto t) { return (3. + cos(sqrt(32.) * t)) * sin(t); });\n    plot3(xt, yt, zt);\n    axis(equal);\n    xlabel(\"x(t)\");\n    ylabel(\"y(t)\");\n    zlabel(\"z(t)\");\n\n    auto ax = gca();\n    float da = ax-&gt;azimuth();\n    for (size_t i = 0; i &lt;= 360; ++i) {\n        ax-&gt;azimuth(da + 2 * i);\n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto t = iota(0, pi / 20, 10 * pi);\n    auto xt = transform(t, [](auto t) { return sin(t); });\n    auto yt = transform(t, [](auto t) { return cos(t); });\n    auto l = plot3(xt, yt, t, \"-ob\");\n    l-&gt;marker_size(10);\n    l-&gt;marker_face_color(\"#D9FFFF\");\n    xlabel(\"x(t)\");\n    ylabel(\"y(t)\");\n    zlabel(\"t\");\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto t = linspace(-10, 10, 1000);\n    auto xt = transform(t, [](auto t) { return exp(-t / 10) * sin(5 * t); });\n    auto yt = transform(t, [](auto t) { return exp(-t / 10) * cos(5 * t); });\n    auto p = plot3(xt, yt, t);\n    p-&gt;line_width(3);\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    tiledlayout(1, 2);\n\n    auto ax1 = nexttile();\n    auto t = iota(0, pi / 20, 10 * pi);\n    auto xt1 = transform(t, [](auto t) { return sin(t); });\n    auto yt1 = transform(t, [](auto t) { return cos(t); });\n    plot3(ax1, xt1, yt1, t);\n    title(ax1, \"Helix with 5 Turns\");\n\n    auto ax2 = nexttile();\n    t = iota(0, pi / 40, 10 * pi);\n    auto xt2 = transform(t, [](auto t) { return sin(2 * t); });\n    auto yt2 = transform(t, [](auto t) { return cos(2 * t); });\n    plot3(ax2, xt2, yt2, t);\n    ax2-&gt;box(false);\n    title(ax2, \"Helix with 10 Turns\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::default_random_engine g(0);\n    std::uniform_real_distribution&lt;double&gt; d;\n\n    std::vector&lt;double&gt; x(10);\n    std::generate(x.begin(), x.end(), [&amp;]() { return d(g); });\n\n    std::vector&lt;double&gt; y(10);\n    std::generate(y.begin(), y.end(), [&amp;]() { return d(g); });\n\n    std::uniform_real_distribution&lt;double&gt; d2(0, 90);\n    std::vector&lt;double&gt; z(10);\n    std::generate(z.begin(), z.end(), [&amp;]() { return d2(g); });\n\n    auto p = plot3(x, y, z, \"o\");\n    p-&gt;parent()-&gt;x_axis().tick_label_format(\"s\");\n    xlabel(\"X\");\n    ylabel(\"Y\");\n    zlabel(\"Duration\");\n    grid(on);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;random&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto t = iota(0, pi / 500, pi);\n    auto xt = transform(t, [](auto t) { return sin(t) * cos(10 * t); });\n    auto yt = transform(t, [](auto t) { return sin(t) * sin(10 * t); });\n    auto zt = transform(t, [](auto t) { return cos(t); });\n    auto p = plot3(xt, yt, zt, \"-o\");\n    p-&gt;marker_indices({200});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/line-plot/","title":"Line Plot","text":"<p>Tip</p> <p>Use these examples to understand how to quickly use the library for data visualization. If you are interested in understanding how the library works, you can later read the details in the complete article.</p> <pre><code>plot(x,y); \n</code></pre> <p>Where <code>x</code> and <code>y</code> are are any value ranges.</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return sin(x); });\n\n    plot(x, y, \"-o\");\n    hold(on);\n    plot(x, transform(y, [](auto y) { return -y; }), \"--xr\");\n    plot(x, transform(x, [](auto x) { return x / pi - 1.; }), \"-:gs\");\n    plot({1.0, 0.7, 0.4, 0.0, -0.4, -0.7, -1}, \"k\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>Tip</p> <p>Setters return a reference to <code>*this</code> to allow method chaining:</p> <pre><code>plot(x,y)-&gt;line_width(2).color(\"red\");\n</code></pre> <p>Tip</p> <p>These examples use free-standing functions to create plots. You can also use a object-oriented style for plots. We discuss these coding styles in the Section Coding Styles.</p> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::set&lt;std::vector&lt;double&gt;&gt; Y = {\n        {16, 5, 9, 4}, {2, 11, 7, 14}, {3, 10, 6, 15}, {13, 8, 12, 1}};\n    plot(Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return sin(x); });\n    std::vector&lt;double&gt; y2 = transform(x, [](auto x) { return sin(x - 0.25); });\n    std::vector&lt;double&gt; y3 = transform(x, [](auto x) { return sin(x - 0.5); });\n    plot(x, y1, x, y2, \"--\", x, y3, \":\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return sin(x); });\n    std::vector&lt;double&gt; y2 = transform(x, [](auto x) { return sin(x - 0.25); });\n    std::vector&lt;double&gt; y3 = transform(x, [](auto x) { return sin(x - 0.5); });\n    plot(x, y1, \"g\", x, y2, \"b--o\", x, y3, \"c*\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 10);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return sin(x); });\n    plot(x, y, \"-o\")-&gt;marker_indices({0,  5,  10, 15, 20, 25, 30, 35, 40, 45,\n                                      50, 55, 60, 65, 70, 75, 80, 85, 90, 95});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n#include &lt;set&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-pi, +pi, 20);\n    // test with set, just because...\n    std::set&lt;double&gt; x2(x.begin(), x.end());\n\n    std::vector&lt;double&gt; y =\n        transform(x, [](auto x) { return tan(sin(x)) - sin(tan(x)); });\n    plot(x2, y, \"--gs\")\n        -&gt;line_width(2)\n        .marker_size(10)\n        .marker_color(\"b\")\n        .marker_face_color({.5, .5, .5});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 10, 150);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return cos(5 * x); });\n    plot(x, y)-&gt;color({0.f, 0.7f, 0.9f});\n    title(\"2-D Line Plot\");\n    xlabel(\"x\");\n    ylabel(\"cos(5x)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 180, 7);\n    std::vector&lt;double&gt; y = {0.8, 0.9, 0.1, 0.9, 0.6, 0.1, 0.3};\n    plot(x, y);\n    title(\"Time Plot\");\n    xlabel(\"Time\");\n    yrange({0, 1});\n    xticks({0, 30, 60, 90, 120, 150, 180});\n    xticklabels(\n        {\"00:00s\", \"30:00\", \"01:00\", \"01:30\", \"02:00\", \"02:30\", \"03:00\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 3);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return sin(5 * x); });\n    std::vector&lt;double&gt; y2 = transform(x, [](auto x) { return sin(15 * x); });\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    plot(ax1, x, y1);\n    title(ax1, \"Top Plot\");\n    ylabel(ax1, \"sin(5x)\");\n\n    auto ax2 = nexttile();\n    plot(ax2, x, y2);\n    title(ax2, \"Bottom Plot\");\n    ylabel(ax2, \"sin(15x)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(-2 * pi, 3);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return sin(x); });\n    std::vector&lt;double&gt; y2 = transform(x, [](auto x) { return cos(x); });\n    auto p = plot(x, y1, x, y2);\n    p[0]-&gt;line_width(2);\n    p[1]-&gt;marker(line_spec::marker_style::asterisk);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    double r = 2;\n    double xc = 4;\n    double yc = 3;\n    std::vector&lt;double&gt; theta = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; x =\n        transform(theta, [=](auto theta) { return r * cos(theta) + xc; });\n    std::vector&lt;double&gt; y =\n        transform(theta, [=](auto theta) { return r * sin(theta) + yc; });\n    plot(x, y);\n    axis(equal);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;int&gt; y = {2, 4, 7, 7, 6, 3, 9, 7, 3, 5};\n    plot(y);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/loglog-plot/","title":"Loglog Plot","text":"<pre><code>loglog(x,y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = logspace(-1, 2);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return pow(2, x); });\n    loglog(x, y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = logspace(-1, 2);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return pow(10, x); });\n    std::vector&lt;double&gt; y2 =\n        transform(x, [](auto x) { return 1 / pow(10, x); });\n    loglog(x, y1, x, y2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = logspace(-1, 2, 10000);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return 5 + 3 * sin(x); });\n    loglog(x, y);\n    yticks({3, 4, 5, 6, 7});\n    xlabel(\"x\");\n    ylabel(\"5+3 sin(x)\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = logspace(-1, 2, 20);\n    std::vector&lt;double&gt; y =\n        transform(x, [](double x) { return std::pow(10., x); });\n    loglog(x, y, \"s\")-&gt;marker_face_color({0.f, 0.447f, 0.741f});\n    xlabel(\"x\");\n    ylabel(\"10^x\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = logspace(-1, 2, 10000);\n    std::vector&lt;double&gt; y1 =\n        transform(x, [](auto x) { return 5 + 3 * sin(x / 4); });\n    std::vector&lt;double&gt; y2 =\n        transform(x, [](auto x) { return 5 - 3 * sin(x / 4); });\n\n    loglog(x, y1, x, y2, \"--\");\n\n    legend(\"Signal 1\", \"Signal 2\")\n        -&gt;location(legend::general_alignment::topleft);\n\n    axis({0.1, 100, 2, 8});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = {0.001, 0.01, 0.1, 1, 10, 100};\n    loglog(y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y = {\n        {0.0010, 0.0100, 0.1000, 1.0000, 10.0000},\n        {0.0100, 0.1000, 1.0000, 10.0000, 100.0000},\n        {0.1000, 1.0000, 10.0000, 100.0000, 1000.0000}};\n    loglog(Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    tiledlayout(2, 1);\n    auto ax1 = nexttile();\n    std::vector&lt;double&gt; x = logspace(-1, 2);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return pow(10, x); });\n    loglog(ax1, x, y1);\n\n    auto ax2 = nexttile();\n    std::vector&lt;double&gt; y2 =\n        transform(x, [](auto x) { return 1. / pow(10, x); });\n    loglog(ax2, x, y2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = logspace(-1, 2);\n    std::vector&lt;double&gt; y1 = transform(x, [](auto x) { return pow(10, x); });\n    std::vector&lt;double&gt; y2 =\n        transform(x, [](auto x) { return 1. / pow(10, x); });\n    auto lg = loglog(x, y1, x, y2);\n    lg[0]-&gt;line_width(2);\n    lg[1]-&gt;color({0.4f, 0.f, 1.f});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/semilogx-plot/","title":"Semilogx Plot","text":"<pre><code>semilogx(x,y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 1000);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return log(x); });\n    semilogx(x, y);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/semilogy-plot/","title":"Semilogy Plot","text":"<pre><code>semilogy(x,y);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = iota(0, 0.1, 10);\n    std::vector&lt;double&gt; y = transform(x, [](auto x) { return exp(x); });\n    semilogy(x, y);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/line-plots/stairs/","title":"Stairs","text":"<pre><code>stairs(x,y);\n</code></pre> <p>The <code>stair</code> object renders the line with stairs between data points to denote discrete data.</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto X = linspace(0, 4 * pi, 40);\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(2);\n    Y[0] = transform(X, [](double x) { return 0.5 * cos(x); });\n    Y[1] = transform(X, [](double x) { return 2 * cos(x); });\n\n    figure();\n    stairs(Y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto X = linspace(0, 4 * pi, 40);\n    auto Y = transform(X, [](double x) { return sin(x); });\n\n    figure();\n    stairs(X, Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto X = linspace(0, 4 * pi, 50);\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(2);\n    Y[0] = transform(X, [](double x) { return 0.5 * cos(x); });\n    Y[1] = transform(X, [](double x) { return 2 * cos(x); });\n\n    figure();\n    stairs(X, Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x1 = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; x2 = linspace(0, pi);\n    std::vector&lt;std::vector&lt;double&gt;&gt; X = {x1, x2};\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(2);\n    Y[0] = transform(x1, [](double x) { return sin(5 * x); });\n    Y[1] = transform(x2, [](double x) { return exp(x) * sin(5 * x); });\n\n    figure();\n    stairs(X, Y);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; X = linspace(0, 4 * pi, 20);\n    std::vector&lt;double&gt; Y = transform(X, [](double x) { return sin(x); });\n\n    figure();\n    stairs(Y, \"-.or\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; X = linspace(0, 4 * pi, 20);\n    std::vector&lt;double&gt; Y = transform(X, [](double x) { return sin(x); });\n\n    auto s = stairs(Y)-&gt;line_width(2).marker(\"d\").marker_face_color(\"c\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; y1 = transform(x, [](double x) { return 5 * sin(x); });\n    std::vector&lt;double&gt; y2 = transform(x, [](double x) { return sin(5 * x); });\n    tiledlayout(2, 1);\n\n    auto ax1 = nexttile();\n    stairs(ax1, x, y1);\n\n    auto ax2 = nexttile();\n    stairs(ax2, x, y2);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = linspace(0, 1, 30);\n    std::vector&lt;std::vector&lt;double&gt;&gt; Y(2);\n    Y[0] = transform(x, [](double x) { return cos(10 * x); });\n    Y[1] = transform(x, [](double x) { return exp(x) * sin(10 * x); });\n\n    auto h = stairs(x, Y);\n    h[0]-&gt;marker(line_spec::marker_style::circle).marker_size(4);\n    h[1]-&gt;marker(line_spec::marker_style::circle).marker_face_color(\"m\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = {1, 3, 5, 7, 10};\n    std::vector&lt;double&gt; y = {2, 5, 6, 7, 11};\n    auto stair_handles = stairs(x, y, x, y, x, y, x, y);\n\n    stair_handles[0]-&gt;stair_style(stair::stair_style::fill);\n\n    stair_handles[1]\n        -&gt;stair_style(stair::stair_style::trace_x_first)\n        .line_width(4);\n\n    stair_handles[2]\n        -&gt;stair_style(stair::stair_style::trace_y_first)\n        .line_width(2);\n\n    stair_handles[3]\n        -&gt;stair_style(stair::stair_style::histogram)\n        .marker_style(line_spec::marker_style::circle)\n        .line_width(1)\n        .marker_color(\"m\")\n        .marker_face(true)\n        .marker_size(10);\n\n    axis({0, 12, 0, 13});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/polar-plots/compass/","title":"Compass","text":"<pre><code>compass(u, v);\n</code></pre> Plot C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = rand(20, -1, +1);\n    std::vector&lt;double&gt; y = rand(20, -1, +1);\n    compass(x, y);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; x = rand(20, -1, +1);\n    std::vector&lt;double&gt; y = rand(20, -1, +1);\n    auto ax1 = subplot(1, 2, 0);\n    compass(ax1, x, y);\n\n    auto ax2 = subplot(1, 2, 1);\n    vectors_handle l = std::make_shared&lt;class vectors&gt;(ax2, x, y);\n    ax2-&gt;emplace_object(l);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/polar-plots/polar-function/","title":"Polar Function","text":"<pre><code>ezpolar(fn);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    ezpolar(\"1+cos(t)\");\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    ezpolar([](double t) { return 1. + cos(t); });\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/polar-plots/polar-histogram/","title":"Polar Histogram","text":"<pre><code>polarhistogram(theta, 6);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = {0.1, 1.1, 5.4, 3.4, 2.3, 4.5, 3.2,\n                                 3.4, 5.6, 2.3, 2.1, 3.5, 0.6, 6.1};\n    polarhistogram(theta, 6);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r1 = rand(100000, 0, 1);\n    auto r2 = rand(100000, 0, 1);\n    std::vector&lt;double&gt; theta = transform(\n        r1, r2, [](double x, double y) { return atan2(x - .5, 2 * (y - .5)); });\n    polarhistogram(theta, 25);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r1 = rand(100000, 0, 1);\n    auto r2 = rand(100000, 0, 1);\n    std::vector&lt;double&gt; theta = transform(\n        r1, r2, [](double x, double y) { return atan2(x - .5, 2 * (y - .5)); });\n    auto h = polarhistogram(theta, 25);\n    h-&gt;face_color(\"red\");\n    h-&gt;face_alpha(1.f - 0.3f);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r1 = rand(100000, 0, 1);\n    auto r2 = rand(100000, 0, 1);\n    std::vector&lt;double&gt; theta = transform(\n        r1, r2, [](double x, double y) { return atan2(x - .5, 2 * (y - .5)); });\n    auto h = polarhistogram(theta, 25);\n    h-&gt;stairs_only(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; y = randp(100, 1.0, 0.5);\n    polarhistogram(y, 25);\n\n    show();\n    return 0;\n}\n</code></pre> <p>The function <code>polarhistogram</code> distributes the data into the number of bins provided as its second parameter.</p>"},{"location":"plot-types/polar-plots/polar-line-plot/","title":"Polar Line Plot","text":"<pre><code>polarplot(theta, rho);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = iota(0, 0.01, 2 * pi);\n    std::vector&lt;double&gt; rho =\n        transform(theta, [](auto t) { return sin(2 * t) * cos(2 * t); });\n    polarplot(theta, rho);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta_degrees = linspace(0, 360, 50);\n    std::vector&lt;double&gt; rho =\n        transform(theta_degrees, [](auto t) { return 0.005 * t / 10.; });\n    std::vector&lt;double&gt; theta_radians = deg2rad(theta_degrees);\n    polarplot(theta_radians, rho);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 6 * pi);\n    std::vector&lt;double&gt; rho1 = transform(theta, [](auto t) { return t / 10.; });\n    polarplot(theta, rho1);\n\n    std::vector&lt;double&gt; rho2 = transform(theta, [](auto t) { return t / 12.; });\n    hold(on);\n    polarplot(theta, rho2, \"--\");\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; rho = iota(10, 5, 70);\n    polarplot(rho, \"-o\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 2 * pi);\n    std::vector&lt;double&gt; rho = transform(theta, [](double t) { return sin(t); });\n    polarplot(theta, rho);\n    gca()-&gt;r_axis().limits({-1, 1});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 2 * pi, 25);\n    std::vector&lt;double&gt; rho = transform(theta, [](double t) { return 2 * t; });\n    polarplot(theta, rho, \"r-o\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 2 * pi, 25);\n    std::vector&lt;double&gt; rho = transform(theta, [](double t) { return 2 * t; });\n    auto p = polarplot(theta, rho);\n    p-&gt;color(\"magenta\");\n    p-&gt;marker(\"square\");\n    p-&gt;marker_size(8.);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;std::complex&lt;double&gt;&gt; z = {{2, 3},  {2, 0},   {-1, +4}, {3, -4},\n                                           {5, +2}, {-4, -2}, {-2, +3}, {-2, 0},\n                                           {0, -3}, {0, 1}};\n\n    polarplot(z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>By emplacing a polar plot in the <code>axes</code>, the <code>axes</code> move to a polar mode, where we use the  and  axis instead of the  and  axis.</p> <p>From the backend point of view, these axes are an abstraction to the user. The data points in the  and  axis are drawn by converting the positions from the polar coordinates  and  to the Cartesian coordinates  and  with the relationships  and .</p> <p>Aside from this conversion, these plot subcategories are analogous to line plots, scatter plots, histograms, quiver plots, and line functions. </p>"},{"location":"plot-types/polar-plots/polar-scatter-plot/","title":"Polar Scatter Plot","text":"<pre><code>polarscatter(theta, rho);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = iota(pi / 4, pi / 4, 2 * pi);\n    std::vector&lt;double&gt; rho = {19, 6, 12, 18, 16, 11, 15, 15};\n    polarscatter(theta, rho);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 2 * pi, 20);\n    std::vector&lt;double&gt; rho = rand(20, 0, 1);\n    double size = 10;\n    polarscatter(theta, rho, size, \"filled\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = iota(pi / 4, pi / 4, 2 * pi);\n    std::vector&lt;double&gt; rho = {19, 6, 12, 18, 16, 11, 15, 15};\n    std::vector&lt;double&gt; sizes = {\n        6 * 2, 15 * 2, 20 * 2, 3 * 2, 15 * 2, 3 * 2, 6 * 2, 40 * 2,\n    };\n    std::vector&lt;double&gt; colors = {\n        1, 2, 2, 2, 1, 1, 2, 1,\n    };\n    auto s = polarscatter(theta, rho, sizes, colors, \"filled\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = linspace(0, 360, 50);\n    std::vector&lt;double&gt; rho =\n        transform(theta, [](double t) { return 0.005 * t / 10.; });\n    std::vector&lt;double&gt; th_radians = deg2rad(theta);\n    auto s = polarscatter(th_radians, rho);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = iota(pi / 6, pi / 6, 2 * pi);\n    std::vector&lt;double&gt; rho1 = rand(12, 0, 1);\n    polarscatter(theta, rho1, \"filled\");\n\n    hold(on);\n    std::vector&lt;double&gt; rho2 = rand(12, 0, 1);\n    polarscatter(theta, rho2, \"filled\");\n    hold(off);\n\n    auto l = legend(\"Series A\", \"Series B\");\n    l-&gt;location(legend::general_alignment::topright);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    std::vector&lt;double&gt; theta = iota(pi / 6, pi / 6, 2 * pi);\n    std::vector&lt;double&gt; rho1 = rand(12, 0, 1);\n    auto ps = polarscatter(theta, rho1, \"filled\");\n    ps-&gt;marker(\"square\");\n    ps-&gt;marker_size(20);\n    ps-&gt;marker_color({0.5, 1, 0, 0});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/fence/","title":"Fence","text":"<pre><code>fence(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    fence(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    // the fence color will be the average Z in that row\n    vector_1d c;\n    for (const auto &amp;row : Z) {\n        c.emplace_back(mean(row));\n    }\n    fence(X, Y, Z, c);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, 5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    fence(X, Y, Z)-&gt;edge_color(\"b\").face_alpha(0.5);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/function-mesh/","title":"Function Mesh","text":"<pre><code>fmesh(fn);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fmesh([](double x, double y) { return sin(x) + cos(y); });\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r = [](double u, double v) { return 2 + sin(7 * u + 5 * v); };\n    auto funx = [r](double u, double v) { return r(u, v) * cos(u) * sin(v); };\n    auto funy = [r](double u, double v) { return r(u, v) * sin(u) * sin(v); };\n    auto funz = [r](double u, double v) { return r(u, v) * cos(v); };\n    fmesh(funx, funy, funz, std::array&lt;double, 4&gt;{0, 2 * pi, 0, pi});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fmesh([](double x, double y) { return erf(x) + cos(y); },\n          std::array&lt;double, 4&gt;{-5, 0, -5, 5});\n    hold(on);\n    fmesh([](double x, double y) { return sin(x) + cos(y); },\n          std::array&lt;double, 2&gt;{0, 5}, std::array&lt;double, 2&gt;{-5, 5});\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fmesh([](double x, double y) {\n        return sin(x) + cos(y);\n    })-&gt;edge_color(\"red\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/function-surface/","title":"Function Surface","text":"<pre><code>fsurf(fn);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fsurf([](double x, double y) { return sin(x) + cos(y); });\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fsurf([](double x, double y) { return erf(x) + cos(y); }, {-5, 0, -5, 5});\n    hold(on);\n    fsurf([](double x, double y) { return sin(x) + cos(y); }, {0, 5}, {-5, 5});\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto r = [](double u, double v) { return 2 + sin(7 * u + 5 * v); };\n    auto funx = [r](double u, double v) { return r(u, v) * cos(u) * sin(v); };\n    auto funy = [r](double u, double v) { return r(u, v) * sin(u) * sin(v); };\n    auto funz = [r](double u, double v) { return r(u, v) * cos(v); };\n    fsurf(funx, funy, funz, {0, 2 * pi, 0, pi})-&gt;lighting(on);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto fn = [](double x, double y) { return y * sin(x) - x * cos(y); };\n    fsurf(fn, {-2 * pi, 2 * pi});\n    title(\"ysin(x) - xcos(y) for x and y in [-2\u03c0,2\u03c0]\");\n    xlabel(\"x\");\n    ylabel(\"y\");\n    zlabel(\"z\");\n    box(on);\n\n    auto ax = gca();\n    ax-&gt;xticks(iota(-2 * pi, pi / 2, 2 * pi));\n    ax-&gt;xticklabels(\n        {\"-2\u03c0\", \"-3\u03c0/2\", \"-\u03c0\", \"-\u03c0/2\", \"0\", \"\u03c0/2\", \"\u03c0\", \"3\u03c0/2\", \"2\u03c0\"});\n\n    ax-&gt;yticks(iota(-2 * pi, pi / 2, 2 * pi));\n    ax-&gt;yticklabels(\n        {\"-2\u03c0\", \"-3\u03c0/2\", \"-\u03c0\", \"-\u03c0/2\", \"0\", \"\u03c0/2\", \"\u03c0\", \"3\u03c0/2\", \"2\u03c0\"});\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto funx = [](double u, double v) { return u * sin(v); };\n    auto funy = [](double u, double v) { return -u * cos(v); };\n    auto funz = [](double, double v) { return v; };\n    fsurf(funx, funy, funz, {-5, 5, -5, -2}, \"--\")-&gt;edge_color(\"g\");\n    hold(on);\n\n    fsurf(funx, funy, funz, {-5, 5, -2, +2})-&gt;edge_color(\"none\");\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto funx = [](double u, double v) {\n        return exp(-std::abs(u) / 10.) * sin(5 * std::abs(v));\n    };\n    auto funy = [](double u, double v) {\n        return exp(-std::abs(u) / 10.) * cos(5 * std::abs(v));\n    };\n    auto funz = [](double u, double) { return u; };\n    fsurf(funx, funy, funz, std::array&lt;double, 2&gt;{-30., +30.})-&gt;face_alpha(.5);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    fsurf([](double x, double y) { return peaks(x, y); }, {-3, +3})\n        -&gt;contour_base(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto funx = [](double s, double) { return sin(s); };\n    auto funy = [](double s, double) { return cos(s); };\n    auto funz = [](double s, double t) { return t / 10 * sin(1. / s); };\n\n    tiledlayout(2, 1);\n    nexttile();\n    fsurf(funx, funy, funz, std::array&lt;double, 2&gt;{-5, +5}, \"\", 20);\n    view(-172, 25);\n    title(\"Decreased Mesh Density\");\n\n    nexttile();\n    fsurf(funx, funy, funz, std::array&lt;double, 2&gt;{-5, +5}, \"\", 80);\n    view(-172, 25);\n    title(\"Increased Mesh Density\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/mesh-with-contour/","title":"Mesh with Contour","text":"<pre><code>meshc(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, +3));\n    auto Z = peaks(X, Y);\n    meshc(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, +3));\n    auto Z = peaks(X, Y);\n    auto C = transform(X, Y, [](double x, double y) { return x * y; });\n    meshc(X, Y, Z, C);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, +5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    auto sc = meshc(X, Y, Z);\n    sc-&gt;edge_color(\"r\");\n    sc-&gt;contour_line_spec().color(\"b\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/mesh-with-curtain/","title":"Mesh with Curtain","text":"<pre><code>meshz(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    meshz(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    auto [FX, FY] = gradient(Z);\n    meshz(X, Y, Z, FX);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, 5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    meshz(X, Y, Z)-&gt;edge_color(\"b\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/mesh/","title":"Mesh","text":"<pre><code>mesh(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-8, .5, +8));\n    auto Z = transform(X, Y, [](double x, double y) {\n        double eps = std::nextafter(0.0, 1.0);\n        double R = sqrt(pow(x, 2) + pow(y, 2)) + eps;\n        return sin(R) / R;\n    });\n    mesh(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-8, .5, +8));\n    auto Z = transform(X, Y, [](double x, double y) {\n        double eps = std::nextafter(0.0, 1.0);\n        double R = sqrt(pow(x, 2) + pow(y, 2)) + eps;\n        return sin(R) / R;\n    });\n    auto C = transform(X, Y, [](double x, double y) { return x * y; });\n    mesh(X, Y, Z, C);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, +5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    mesh(X, Y, Z)-&gt;palette_map_at_surface(true).face_alpha(0.5);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y, Z] = peaks();\n    mesh(X, Y, Z)-&gt;hidden_3d(false);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/ribbon/","title":"Ribbon","text":"<pre><code>ribbon(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .5, 3), iota(-3, .1, 3));\n    auto Z = peaks(X, Y);\n    ribbon(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .5, 3), iota(-3, .1, 3));\n    auto Z = peaks(X, Y);\n    auto [FX, FY] = gradient(Z);\n    ribbon(X, Y, Z, FX, 1.0);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, 5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    ribbon(X, Y, Z)-&gt;edge_color(\"green\").face_alpha(0.5);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n\n    auto rastrigin = [](double x, double y) {\n        return 10 * 2 + pow(x, 2) - 10 * cos(2 * pi * x) + pow(y, 2) -\n               10 * cos(2 * pi * y);\n    };\n\n    auto [X, Y] = meshgrid(iota(-5, 1., 5), iota(-5, .1, 5));\n    auto Z = transform(X, Y, rastrigin);\n    ribbon(X, Y, Z)-&gt;face_alpha(0.8f);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/surface-with-contour/","title":"Surface with Contour","text":"<pre><code>surfc(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(linspace(-5, +5, 70), linspace(-5, +5, 70));\n    auto Z = transform(X, Y, [](double x, double y) {\n        return 10 * 2 + pow(x, 2) - 10 * cos(2 * pi * x) + pow(y, 2) -\n               10 * cos(2 * pi * y);\n    });\n    surfc(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(1, .5, 10), iota(1, 20));\n    auto Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    auto s = surfc(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    auto C = transform(X, Y, [](double x, double y) { return x * y; });\n    surfc(X, Y, Z, C);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, 5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n\n    surfc(X, Y, Z)-&gt;edge_color({0, 1, 0, 0});\n    colormap({{0, 0, 1}});\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/surface/","title":"Surface","text":"<pre><code>surf(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(linspace(-5, +5, 40), linspace(-5, +5, 40));\n    auto Z = transform(X, Y, [](double x, double y) {\n        return 10 * 2 + pow(x, 2) - 10 * cos(2 * pi * x) + pow(y, 2) -\n               10 * cos(2 * pi * y);\n    });\n    surf(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(1, 0.5, 10), iota(1, 20));\n    auto Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    surf(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(1, 0.5, 10), iota(1, 20));\n    auto Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    auto C = transform(X, Y, [](double x, double y) { return x * y; });\n    surf(X, Y, Z, C);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, 0.5, 5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    auto C = transform(X, Y, [](double x, double y) { return x * y; });\n    surf(X, Y, Z)-&gt;face_alpha(0.5).edge_color(\"none\");\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(1, .5, 10), iota(1, 20));\n    auto Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    surf(X, Y, Z)-&gt;lighting(true);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(1, .5, 10), iota(1, 20));\n    auto Z =\n        transform(X, Y, [](double x, double y) { return sin(x) + cos(y); });\n    surf(X, Y, Z)-&gt;edge_color(\"none\").lighting(true);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/surfaces/waterfall/","title":"Waterfall","text":"<pre><code>waterfall(X, Y, Z);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    waterfall(X, Y, Z);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-3, .125, 3));\n    auto Z = peaks(X, Y);\n    auto [FX, FY] = gradient(Z);\n    waterfall(X, Y, Z, FX);\n    colorbar();\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [X, Y] = meshgrid(iota(-5, .5, 5));\n    auto Z = transform(\n        X, Y, [](double x, double y) { return y * sin(x) - x * cos(y); });\n    waterfall(X, Y, Z)-&gt;edge_color(\"b\");\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/vector-fields/feather/","title":"Feather","text":"<pre><code>feather(u, v);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    std::vector&lt;double&gt; theta = iota(-pi / 2, pi / 16, pi / 2);\n    std::vector&lt;double&gt; rho(theta.size(), 2.);\n    auto [u, v] = pol2cart(theta, rho);\n    feather(u, v);\n\n    show();\n    return 0;\n}\n</code></pre>"},{"location":"plot-types/vector-fields/quiver-3d/","title":"Quiver 3D","text":"<pre><code>quiver3(Z, U, V, W);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nmatplot::vector_2d get_u();\nmatplot::vector_2d get_v();\nmatplot::vector_2d get_w();\n\nint main() {\n    using namespace matplot;\n    vector_1d x = iota(-3, 0.5, 3);\n    vector_1d y = iota(-3, 0.5, 3);\n    auto [X, Y] = meshgrid(x, y);\n    vector_2d Z = transform(\n        X, Y, [](double x, double y) { return pow(y, 2) - pow(x, 2); });\n    auto U = get_u();\n    auto V = get_v();\n    auto W = get_w();\n\n    quiver3(Z, U, V, W);\n    view(-35, 45);\n\n    show();\n    return 0;\n}\n\nmatplot::vector_2d get_u() {\n    matplot::vector_2d x = {\n        {-0.688247, -0.620174, -0.534522, -0.428571, -0.301511, -0.156174, 0,\n         0.156174, 0.301511, 0.428571, 0.534522, 0.620174, 0.688247},\n        {-0.744208, -0.680414, -0.596285, -0.486664, -0.348155, -0.182574, 0,\n         0.182574, 0.348155, 0.486664, 0.596285, 0.680414, 0.744208},\n        {-0.801784, -0.745356, -0.666667, -0.557086, -0.408248, -0.218218, 0,\n         0.218218, 0.408248, 0.557086, 0.666667, 0.745356, 0.801784},\n        {-0.857143, -0.811107, -0.742781, -0.639602, -0.485071, -0.267261, 0,\n         0.267261, 0.485071, 0.639602, 0.742781, 0.811107, 0.857143},\n        {-0.904534, -0.870388, -0.816497, -0.727607, -0.57735, -0.333333, 0,\n         0.333333, 0.57735, 0.727607, 0.816497, 0.870388, 0.904534},\n        {-0.937043, -0.912871, -0.872872, -0.801784, -0.666667, -0.408248, 0,\n         0.408248, 0.666667, 0.801784, 0.872872, 0.912871, 0.937043},\n        {-0.948683, -0.928477, -0.894427, -0.83205, -0.707107, -0.447214, -0,\n         0.447214, 0.707107, 0.83205, 0.894427, 0.928477, 0.948683},\n        {-0.937043, -0.912871, -0.872872, -0.801784, -0.666667, -0.408248, -0,\n         0.408248, 0.666667, 0.801784, 0.872872, 0.912871, 0.937043},\n        {-0.904534, -0.870388, -0.816497, -0.727607, -0.57735, -0.333333, -0,\n         0.333333, 0.57735, 0.727607, 0.816497, 0.870388, 0.904534},\n        {-0.857143, -0.811107, -0.742781, -0.639602, -0.485071, -0.267261, -0,\n         0.267261, 0.485071, 0.639602, 0.742781, 0.811107, 0.857143},\n        {-0.801784, -0.745356, -0.666667, -0.557086, -0.408248, -0.218218, -0,\n         0.218218, 0.408248, 0.557086, 0.666667, 0.745356, 0.801784},\n        {-0.744208, -0.680414, -0.596285, -0.486664, -0.348155, -0.182574, -0,\n         0.182574, 0.348155, 0.486664, 0.596285, 0.680414, 0.744208},\n        {-0.688247, -0.620174, -0.534522, -0.428571, -0.301511, -0.156174, -0,\n         0.156174, 0.301511, 0.428571, 0.534522, 0.620174, 0.688247}};\n    return x;\n}\n\nmatplot::vector_2d get_v() {\n    matplot::vector_2d x = {\n        {0.688247, 0.744208, 0.801784, 0.857143, 0.904534, 0.937043, 0.948683,\n         0.937043, 0.904534, 0.857143, 0.801784, 0.744208, 0.688247},\n        {0.620174, 0.680414, 0.745356, 0.811107, 0.870388, 0.912871, 0.928477,\n         0.912871, 0.870388, 0.811107, 0.745356, 0.680414, 0.620174},\n        {0.534522, 0.596285, 0.666667, 0.742781, 0.816497, 0.872872, 0.894427,\n         0.872872, 0.816497, 0.742781, 0.666667, 0.596285, 0.534522},\n        {0.428571, 0.486664, 0.557086, 0.639602, 0.727607, 0.801784, 0.83205,\n         0.801784, 0.727607, 0.639602, 0.557086, 0.486664, 0.428571},\n        {0.301511, 0.348155, 0.408248, 0.485071, 0.57735, 0.666667, 0.707107,\n         0.666667, 0.57735, 0.485071, 0.408248, 0.348155, 0.301511},\n        {0.156174, 0.182574, 0.218218, 0.267261, 0.333333, 0.408248, 0.447214,\n         0.408248, 0.333333, 0.267261, 0.218218, 0.182574, 0.156174},\n        {-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0},\n        {-0.156174, -0.182574, -0.218218, -0.267261, -0.333333, -0.408248,\n         -0.447214, -0.408248, -0.333333, -0.267261, -0.218218, -0.182574,\n         -0.156174},\n        {-0.301511, -0.348155, -0.408248, -0.485071, -0.57735, -0.666667,\n         -0.707107, -0.666667, -0.57735, -0.485071, -0.408248, -0.348155,\n         -0.301511},\n        {-0.428571, -0.486664, -0.557086, -0.639602, -0.727607, -0.801784,\n         -0.83205, -0.801784, -0.727607, -0.639602, -0.557086, -0.486664,\n         -0.428571},\n        {-0.534522, -0.596285, -0.666667, -0.742781, -0.816497, -0.872872,\n         -0.894427, -0.872872, -0.816497, -0.742781, -0.666667, -0.596285,\n         -0.534522},\n        {-0.620174, -0.680414, -0.745356, -0.811107, -0.870388, -0.912871,\n         -0.928477, -0.912871, -0.870388, -0.811107, -0.745356, -0.680414,\n         -0.620174},\n        {-0.688247, -0.744208, -0.801784, -0.857143, -0.904534, -0.937043,\n         -0.948683, -0.937043, -0.904534, -0.857143, -0.801784, -0.744208,\n         -0.688247}};\n    return x;\n}\n\nmatplot::vector_2d get_w() {\n    matplot::vector_2d x = {\n        {0.229416, 0.248069, 0.267261, 0.285714, 0.301511, 0.312348, 0.316228,\n         0.312348, 0.301511, 0.285714, 0.267261, 0.248069, 0.229416},\n        {0.248069, 0.272166, 0.298142, 0.324443, 0.348155, 0.365148, 0.371391,\n         0.365148, 0.348155, 0.324443, 0.298142, 0.272166, 0.248069},\n        {0.267261, 0.298142, 0.333333, 0.371391, 0.408248, 0.436436, 0.447214,\n         0.436436, 0.408248, 0.371391, 0.333333, 0.298142, 0.267261},\n        {0.285714, 0.324443, 0.371391, 0.426401, 0.485071, 0.534522, 0.5547,\n         0.534522, 0.485071, 0.426401, 0.371391, 0.324443, 0.285714},\n        {0.301511, 0.348155, 0.408248, 0.485071, 0.57735, 0.666667, 0.707107,\n         0.666667, 0.57735, 0.485071, 0.408248, 0.348155, 0.301511},\n        {0.312348, 0.365148, 0.436436, 0.534522, 0.666667, 0.816497, 0.894427,\n         0.816497, 0.666667, 0.534522, 0.436436, 0.365148, 0.312348},\n        {0.316228, 0.371391, 0.447214, 0.5547, 0.707107, 0.894427, 1, 0.894427,\n         0.707107, 0.5547, 0.447214, 0.371391, 0.316228},\n        {0.312348, 0.365148, 0.436436, 0.534522, 0.666667, 0.816497, 0.894427,\n         0.816497, 0.666667, 0.534522, 0.436436, 0.365148, 0.312348},\n        {0.301511, 0.348155, 0.408248, 0.485071, 0.57735, 0.666667, 0.707107,\n         0.666667, 0.57735, 0.485071, 0.408248, 0.348155, 0.301511},\n        {0.285714, 0.324443, 0.371391, 0.426401, 0.485071, 0.534522, 0.5547,\n         0.534522, 0.485071, 0.426401, 0.371391, 0.324443, 0.285714},\n        {0.267261, 0.298142, 0.333333, 0.371391, 0.408248, 0.436436, 0.447214,\n         0.436436, 0.408248, 0.371391, 0.333333, 0.298142, 0.267261},\n        {0.248069, 0.272166, 0.298142, 0.324443, 0.348155, 0.365148, 0.371391,\n         0.365148, 0.348155, 0.324443, 0.298142, 0.272166, 0.248069},\n        {0.229416, 0.248069, 0.267261, 0.285714, 0.301511, 0.312348, 0.316228,\n         0.312348, 0.301511, 0.285714, 0.267261, 0.248069, 0.229416}};\n    return x;\n}\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;double&gt; get_x();\nstd::vector&lt;double&gt; get_y();\nstd::vector&lt;double&gt; get_z();\n\nint main() {\n    using namespace matplot;\n\n    // Positions\n    vector_1d x = get_x();\n    vector_1d y = get_y();\n    vector_1d z = get_z();\n\n    // Vectors\n    vector_1d u, v, w, m;\n    for (size_t i = 0; i &lt; x.size(); ++i) {\n        double t = std::exp(-std::pow(x[i], 2) - std::pow(y[i], 2) -\n                            std::pow(z[i], 2));\n        u.emplace_back(x[i] * t);\n        v.emplace_back(y[i] * t);\n        w.emplace_back(z[i] * t);\n        m.emplace_back(std::sqrt(x[i] * x[i] + y[i] * y[i] + z[i] * z[i]));\n    }\n\n    quiver3(x, y, z, u, v, w, m, 0.3)-&gt;normalize(true).line_width(2);\n\n    show();\n    return 0;\n}\n\nstd::vector&lt;double&gt; get_x() {\n    return {-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n            -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n            -1,   -1,   -1,   -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,\n            -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,\n            -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0,    0,    0,    0,    0,\n            0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n            0,    0,    0,    0,    0,    0,    0,    0,    0,    0.5,  0.5,\n            0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n            0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n            0.5,  1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n            1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,\n            1,    1,    1,    1};\n}\n\nstd::vector&lt;double&gt; get_y() {\n    return {-1,   -1,   -1, -1,  -1,  -0.5, -0.5, -0.5, -0.5, -0.5, 0,    0,\n            0,    0,    0,  0.5, 0.5, 0.5,  0.5,  0.5,  1,    1,    1,    1,\n            1,    -1,   -1, -1,  -1,  -1,   -0.5, -0.5, -0.5, -0.5, -0.5, 0,\n            0,    0,    0,  0,   0.5, 0.5,  0.5,  0.5,  0.5,  1,    1,    1,\n            1,    1,    -1, -1,  -1,  -1,   -1,   -0.5, -0.5, -0.5, -0.5, -0.5,\n            0,    0,    0,  0,   0,   0.5,  0.5,  0.5,  0.5,  0.5,  1,    1,\n            1,    1,    1,  -1,  -1,  -1,   -1,   -1,   -0.5, -0.5, -0.5, -0.5,\n            -0.5, 0,    0,  0,   0,   0,    0.5,  0.5,  0.5,  0.5,  0.5,  1,\n            1,    1,    1,  1,   -1,  -1,   -1,   -1,   -1,   -0.5, -0.5, -0.5,\n            -0.5, -0.5, 0,  0,   0,   0,    0,    0.5,  0.5,  0.5,  0.5,  0.5,\n            1,    1,    1,  1,   1};\n}\n\nstd::vector&lt;double&gt; get_z() {\n    return {-1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1, -1, -0.5, 0, 0.5, 1,\n            -1, -0.5, 0, 0.5, 1};\n}\n</code></pre>"},{"location":"plot-types/vector-fields/quiver/","title":"Quiver","text":"<pre><code>quiver(x, y, u, v);\n</code></pre> Plot C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [x, y] = meshgrid(iota(0, 0.2, 2), iota(0, 0.2, 2));\n    vector_2d u =\n        transform(x, y, [](double x, double y) { return cos(x) * y; });\n    vector_2d v =\n        transform(x, y, [](double x, double y) { return sin(x) * y; });\n\n    quiver(x, y, u, v);\n\n    show();\n    return 0;\n}\n</code></pre> <p>More examples</p> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [x, y] = meshgrid(iota(0, 0.2, 2), iota(0, 0.2, 2));\n    vector_2d u =\n        transform(x, y, [](double x, double y) { return cos(x) * y; });\n    vector_2d v =\n        transform(x, y, [](double x, double y) { return sin(x) * y; });\n\n    quiver(x, y, u, v, 2.);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [x, y] = meshgrid(iota(0, 0.2, 2), iota(0, 0.2, 2));\n    vector_2d u =\n        transform(x, y, [](double x, double y) { return cos(x) * y; });\n    vector_2d v =\n        transform(x, y, [](double x, double y) { return sin(x) * y; });\n\n    quiver(x, y, u, v, 0.);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [x, y] = meshgrid(iota(-2, 0.2, 2));\n    auto z = transform(x, y, [](double x, double y) {\n        return x * exp(-pow(x, 2) - pow(y, 2));\n    });\n    auto [dx, dy] = gradient(z, .2, .2);\n\n    contour(x, y, z);\n    hold(on);\n\n    quiver(x, y, dx, dy);\n    hold(off);\n\n    show();\n    return 0;\n}\n</code></pre> Plot <p></p> C++ <pre><code>#include &lt;cmath&gt;\n#include &lt;matplot/matplot.h&gt;\n\nint main() {\n    using namespace matplot;\n    auto [x, y] = meshgrid(iota(-2.5, 0.25, 2.5), iota(-2.5, 0.25, 2.5));\n    vector_2d u =\n        transform(x, y, [](double x, double y) { return cos(x) * sin(x + y); });\n    vector_2d v =\n        transform(x, y, [](double x, double y) { return sin(y) * cos(x + y); });\n\n    vector_2d m =\n        transform(u, v, [](double u, double v) { return sqrt(u * u + v * v); });\n\n    quiver(x, y, u, v, m, 0.2)-&gt;normalize(true).line_width(1.5);\n\n    colormap(palette::jet());\n    show();\n    return 0;\n}\n</code></pre> <p>All these subcategories depend on the <code>vectors</code> object type. In a two-dimensional plot, for each value of  and  with the position of a vector, it also requires the value of  and  indicating its direction and magnitude. In a three-dimensional plot, the direction and magnitude are defined by , , and .</p> <p>A quiver plot (or velocity plot) shows a grid of vectors whose direction and magnitude are scaled to prevent the overlap between vectors in subsequent quads. </p>"}]}